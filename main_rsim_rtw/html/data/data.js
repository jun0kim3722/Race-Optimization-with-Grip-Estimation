var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"main","ref":false,"files":[{"name":"main.c","type":"source","group":"model","path":"C:\\Users\\liam0\\OneDrive\\Desktop\\main_rsim_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * main.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"main\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Thu Oct 10 10:35:59 2024\r\n *\r\n * Target selection: rsim.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"main.h\"\r\n#include \"rtwtypes.h\"\r\n#include <string.h>\r\n#include <math.h>\r\n#include \"main_private.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include <emmintrin.h>\r\n#include \"rt_defines.h\"\r\n#include \"main_dt.h\"\r\n\r\n/* user code (top of parameter file) */\r\nconst int_T gblNumToFiles = 0;\r\nconst int_T gblNumFrFiles = 0;\r\nconst int_T gblNumFrWksBlocks = 0;\r\nconst char *gblSlvrJacPatternFileName = \"main_rsim_rtw\\\\main_Jpattern.mat\";\r\n\r\n/* Root inports information  */\r\nconst int_T gblNumRootInportBlks = 0;\r\nconst int_T gblNumModelInputs = 0;\r\nextern rtInportTUtable *gblInportTUtables;\r\nextern const char *gblInportFileName;\r\nconst int_T gblInportDataTypeIdx[] = { -1 };\r\n\r\nconst int_T gblInportDims[] = { -1 } ;\r\n\r\nconst int_T gblInportComplex[] = { -1 };\r\n\r\nconst int_T gblInportInterpoFlag[] = { -1 };\r\n\r\nconst int_T gblInportContinuous[] = { -1 };\r\n\r\n#include \"simstruc.h\"\r\n#include \"fixedpoint.h\"\r\n\r\n/* Block signals (default storage) */\r\nB rtB;\r\n\r\n/* Continuous states */\r\nX rtX;\r\n\r\n/* Disabled State Vector */\r\nXDis rtXDis;\r\n\r\n/* Block states (default storage) */\r\nDW rtDW;\r\n\r\n/* Parent Simstruct */\r\nstatic SimStruct model_S;\r\nSimStruct *const rtS = &model_S;\r\n\r\n/* Forward declaration for local functions */\r\nstatic void main_div0protect(real_T u, real_T tol, real_T *y, real_T *yabs);\r\nstatic void main_calculateFz(real_T RL, real_T b_LONGVL, real_T\r\n  b_UNLOADED_RADIUS, real_T b_ASPECT_RATIO, real_T b_WIDTH, real_T b_Q_RE0,\r\n  real_T b_Q_V1, real_T b_FNOMIN, real_T b_VERTICAL_STIFFNESS, real_T\r\n  b_RIM_RADIUS, real_T b_BOTTOM_STIFF, real_T b_BOTTOM_OFFST, real_T b_Q_V2,\r\n  real_T b_Q_FZ1, real_T b_Q_FZ2, real_T b_Q_FCX, real_T b_Q_FCY, real_T b_PFZ1,\r\n  real_T b_Q_FCY2, real_T b_Q_CAM1, real_T b_Q_CAM2, real_T b_Q_CAM3, real_T\r\n  b_Q_FYS1, real_T b_Q_FYS2, real_T b_Q_FYS3, real_T dpi, real_T omega, real_T\r\n  b_gamma, real_T Fx_ext, real_T Fy_ext, real_T *Fz, real_T *rhoz);\r\nstatic real_T main_solveRLwithRhoz(real_T b_LONGVL, real_T b_UNLOADED_RADIUS,\r\n  real_T b_ASPECT_RATIO, real_T b_WIDTH, real_T b_Q_RE0, real_T b_Q_V1, real_T\r\n  b_FNOMIN, real_T b_VERTICAL_STIFFNESS, real_T b_RIM_RADIUS, real_T\r\n  b_BOTTOM_STIFF, real_T b_BOTTOM_OFFST, real_T b_Q_V2, real_T b_Q_FZ1, real_T\r\n  b_Q_FZ2, real_T b_Q_FCX, real_T b_Q_FCY, real_T b_PFZ1, real_T b_Q_FCY2,\r\n  real_T b_Q_CAM1, real_T b_Q_CAM2, real_T b_Q_CAM3, real_T b_Q_FYS1, real_T\r\n  b_Q_FYS2, real_T b_Q_FYS3, real_T dpi, real_T omega, real_T b_gamma, real_T\r\n  Fx_ext, real_T Fy_ext, real_T rhoz);\r\nstatic real_T main_calculateFz_m(real_T RL, real_T b_LONGVL, real_T\r\n  b_UNLOADED_RADIUS, real_T b_ASPECT_RATIO, real_T b_WIDTH, real_T b_Q_RE0,\r\n  real_T b_Q_V1, real_T b_FNOMIN, real_T b_VERTICAL_STIFFNESS, real_T\r\n  b_RIM_RADIUS, real_T b_BOTTOM_STIFF, real_T b_BOTTOM_OFFST, real_T b_Q_V2,\r\n  real_T b_Q_FZ1, real_T b_Q_FZ2, real_T b_Q_FCX, real_T b_Q_FCY, real_T b_PFZ1,\r\n  real_T b_Q_FCY2, real_T b_Q_CAM1, real_T b_Q_CAM2, real_T b_Q_CAM3, real_T\r\n  b_Q_FYS1, real_T b_Q_FYS2, real_T b_Q_FYS3, real_T dpi, real_T omega, real_T\r\n  b_gamma, real_T Fx_ext, real_T Fy_ext);\r\nstatic real_T main_div0protect_k(real_T u);\r\nstatic void main_abs(const real_T x_data[], const int32_T x_size[2], real_T\r\n                     y_data[], int32_T y_size[2]);\r\nstatic void main_binary_expand_op_4(real_T *in1, real_T in3, const int32_T in4[2],\r\n  real_T in5, real_T in6);\r\nstatic void main_atan(real_T x_data[], const int32_T x_size[2]);\r\nstatic void main_cos(real_T x_data[], const int32_T x_size[2]);\r\nstatic void main_sqrt(real_T x_data[], const int32_T x_size[2]);\r\nstatic void main_binary_expand_op_3(real_T in1_data[], int32_T in1_size[2],\r\n  real_T in2, real_T in3, real_T in4, real_T in5, real_T in6, const int32_T in7\r\n  [2], real_T in8, real_T in9, int32_T in10, real_T in11);\r\nstatic void main_div0protect_kw(real_T u, real_T *y, real_T *yabs);\r\nstatic void main_binary_expand_op_2(real_T in1_data[], int32_T in1_size[2],\r\n  const real_T *in2, real_T in3, real_T in4, const real_T *in5, const real_T\r\n  *in6, const int32_T in7[2], real_T in8, const real_T *in9);\r\nstatic void main_acos(real_T x_data[], const int32_T x_size[2]);\r\nstatic void main_binary_expand_op_1(real_T *in1, real_T in3, real_T in4, real_T\r\n  in5, const int32_T in6[2], const real_T in7[27], const int32_T in8_size[2],\r\n  real_T in9, real_T in10, int32_T in11, real_T in12);\r\nstatic void main_binary_expand_op(real_T *in1, const int32_T in2_size[2], real_T\r\n  in3, real_T in4, real_T in5, const int32_T in6[2], const real_T in7[27], const\r\n  int32_T in8_size[2], real_T in9, real_T in10, real_T in11, real_T in12, const\r\n  real_T in13[9]);\r\nstatic real_T main_solveRLwithFz(real_T b_LONGVL, real_T b_UNLOADED_RADIUS,\r\n  real_T b_ASPECT_RATIO, real_T b_WIDTH, real_T b_Q_RE0, real_T b_Q_V1, real_T\r\n  b_FNOMIN, real_T b_VERTICAL_STIFFNESS, real_T b_RIM_RADIUS, real_T\r\n  b_BOTTOM_STIFF, real_T b_BOTTOM_OFFST, real_T b_Q_V2, real_T b_Q_FZ1, real_T\r\n  b_Q_FZ2, real_T b_Q_FCX, real_T b_Q_FCY, real_T b_PFZ1, real_T b_Q_FCY2,\r\n  real_T b_Q_CAM1, real_T b_Q_CAM2, real_T b_Q_CAM3, real_T b_Q_FYS1, real_T\r\n  b_Q_FYS2, real_T b_Q_FYS3, real_T dpi, real_T omega, real_T b_gamma, real_T\r\n  Fx_ext, real_T Fy_ext, real_T Fz);\r\nstatic void main_vdyncsmtire(real_T omega, real_T Vx, real_T Vy, real_T psidot,\r\n  real_T b_gamma, real_T press, const real_T scaleFactors[27], real_T *rhoz,\r\n  real_T b_turnslip, real_T b_PRESMAX, real_T b_PRESMIN, real_T b_FZMAX, real_T\r\n  b_FZMIN, real_T b_VXLOW, real_T b_KPUMAX, real_T b_KPUMIN, real_T b_ALPMAX,\r\n  real_T b_ALPMIN, real_T b_CAMMIN, real_T b_CAMMAX, real_T b_LONGVL, real_T\r\n  b_UNLOADED_RADIUS, real_T b_RIM_RADIUS, real_T b_NOMPRES, real_T b_FNOMIN,\r\n  real_T b_VERTICAL_STIFFNESS, real_T b_DREFF, real_T b_BREFF, real_T b_FREFF,\r\n  real_T b_Q_RE0, real_T b_Q_V1, real_T b_Q_V2, real_T b_Q_FZ1, real_T b_Q_FZ2,\r\n  real_T b_Q_FCX, real_T b_Q_FCY, real_T b_PFZ1, real_T b_Q_FCY2, real_T\r\n  b_BOTTOM_OFFST, real_T b_BOTTOM_STIFF, real_T b_PCX1, real_T b_PDX1, real_T\r\n  b_PDX2, real_T b_PDX3, real_T b_PEX1, real_T b_PEX2, real_T b_PEX3, real_T\r\n  b_PEX4, real_T b_PKX1, real_T b_PKX2, real_T b_PKX3, real_T b_PHX1, real_T\r\n  b_PHX2, real_T b_PVX1, real_T b_PVX2, real_T b_PPX1, real_T b_PPX2, real_T\r\n  b_PPX3, real_T b_PPX4, real_T b_RBX1, real_T b_RBX2, real_T b_RBX3, real_T\r\n  b_RCX1, real_T b_REX1, real_T b_REX2, real_T b_RHX1, real_T b_QSX1, real_T\r\n  b_QSX2, real_T b_QSX3, real_T b_QSX4, real_T b_QSX5, real_T b_QSX6, real_T\r\n  b_QSX7, real_T b_QSX8, real_T b_QSX9, real_T b_QSX10, real_T b_QSX11, real_T\r\n  b_PPMX1, real_T b_PCY1, real_T b_PDY1, real_T b_PDY2, real_T b_PDY3, real_T\r\n  b_PEY1, real_T b_PEY2, real_T b_PEY3, real_T b_PEY4, real_T b_PEY5, real_T\r\n  b_PKY1, real_T b_PKY2, real_T b_PKY3, real_T b_PKY4, real_T b_PKY5, real_T\r\n  b_PKY6, real_T b_PKY7, real_T b_PHY1, real_T b_PHY2, real_T b_PVY1, real_T\r\n  b_PVY2, real_T b_PVY3, real_T b_PVY4, real_T b_PPY1, real_T b_PPY2, real_T\r\n  b_PPY3, real_T b_PPY4, real_T b_PPY5, real_T b_RBY1, real_T b_RBY2, real_T\r\n  b_RBY3, real_T b_RBY4, real_T b_RCY1, real_T b_REY1, real_T b_REY2, real_T\r\n  b_RHY1, real_T b_RHY2, real_T b_RVY1, real_T b_RVY2, real_T b_RVY3, real_T\r\n  b_RVY4, real_T b_RVY5, real_T b_RVY6, real_T b_QSY1, real_T b_QSY2, real_T\r\n  b_QSY3, real_T b_QSY4, real_T b_QSY5, real_T b_QSY6, real_T b_QSY7, real_T\r\n  b_QSY8, real_T b_QBZ1, real_T b_QBZ2, real_T b_QBZ3, real_T b_QBZ4, real_T\r\n  b_QBZ5, real_T b_QBZ6, real_T b_QBZ9, real_T b_QBZ10, real_T b_QCZ1, real_T\r\n  b_QDZ1, real_T b_QDZ2, real_T b_QDZ3, real_T b_QDZ4, real_T b_QDZ6, real_T\r\n  b_QDZ7, real_T b_QDZ8, real_T b_QDZ9, real_T b_QDZ10, real_T b_QDZ11, real_T\r\n  b_QEZ1, real_T b_QEZ2, real_T b_QEZ3, real_T b_QEZ4, real_T b_QEZ5, real_T\r\n  b_QHZ1, real_T b_QHZ2, real_T b_QHZ3, real_T b_QHZ4, real_T b_PPZ1, real_T\r\n  b_PPZ2, real_T b_SSZ1, real_T b_SSZ2, real_T b_SSZ3, real_T b_SSZ4, real_T\r\n  b_PDXP1, real_T b_PDXP2, real_T b_PDXP3, real_T b_PKYP1, real_T b_PDYP1,\r\n  real_T b_PDYP2, real_T b_PDYP3, real_T b_PDYP4, real_T b_PHYP1, real_T b_PHYP2,\r\n  real_T b_PHYP3, real_T b_PHYP4, real_T b_PECP1, real_T b_PECP2, real_T b_QDTP1,\r\n  real_T b_QCRP1, real_T b_QCRP2, real_T b_QBRP1, real_T b_QDRP1, real_T b_QDRP2,\r\n  real_T b_WIDTH, real_T b_Q_RA1, real_T b_Q_RA2, real_T b_Q_RB1, real_T b_Q_RB2,\r\n  real_T b_QSX12, real_T b_QSX13, real_T b_QSX14, real_T\r\n  b_LONGITUDINAL_STIFFNESS, real_T b_LATERAL_STIFFNESS, real_T b_PCFX1, real_T\r\n  b_PCFX2, real_T b_PCFX3, real_T b_PCFY1, real_T b_PCFY2, real_T b_PCFY3,\r\n  real_T Fx_ext, real_T Fy_ext, real_T Fz_ext, real_T vertType, real_T b_Q_CAM1,\r\n  real_T b_Q_CAM2, real_T b_Q_CAM3, real_T b_Q_FYS1, real_T b_Q_FYS2, real_T\r\n  b_Q_FYS3, real_T b_ASPECT_RATIO, real_T *Fx, real_T *Fy, real_T *Fz, real_T\r\n  *Mx, real_T *My, real_T *Mz, real_T *Re, real_T *kappa, real_T *alpha, real_T *\r\n  sig_x, real_T *sig_y, real_T *patch_a, real_T *patch_b, real_T *RL, real_T *Tw);\r\n\r\n/* Function for MATLAB Function: '<S3>/Magic Tire Const Input' */\r\nstatic void main_div0protect(real_T u, real_T tol, real_T *y, real_T *yabs)\r\n{\r\n  real_T x;\r\n  *yabs = fabs(u);\r\n  x = 2.0 * tol;\r\n  if (*yabs < tol) {\r\n    real_T varargin_1;\r\n    varargin_1 = *yabs / tol;\r\n    varargin_1 *= varargin_1;\r\n    *yabs = x / (3.0 - varargin_1);\r\n  }\r\n\r\n  *y = *yabs;\r\n  if (u < 0.0) {\r\n    *y = -*yabs;\r\n  }\r\n}\r\n\r\nreal_T rt_powd_snf(real_T u0, real_T u1)\r\n{\r\n  real_T y;\r\n  if (rtIsNaN(u0) || rtIsNaN(u1)) {\r\n    y = (rtNaN);\r\n  } else {\r\n    real_T tmp;\r\n    real_T tmp_0;\r\n    tmp = fabs(u0);\r\n    tmp_0 = fabs(u1);\r\n    if (rtIsInf(u1)) {\r\n      if (tmp == 1.0) {\r\n        y = 1.0;\r\n      } else if (tmp > 1.0) {\r\n        if (u1 > 0.0) {\r\n          y = (rtInf);\r\n        } else {\r\n          y = 0.0;\r\n        }\r\n      } else if (u1 > 0.0) {\r\n        y = 0.0;\r\n      } else {\r\n        y = (rtInf);\r\n      }\r\n    } else if (tmp_0 == 0.0) {\r\n      y = 1.0;\r\n    } else if (tmp_0 == 1.0) {\r\n      if (u1 > 0.0) {\r\n        y = u0;\r\n      } else {\r\n        y = 1.0 / u0;\r\n      }\r\n    } else if (u1 == 2.0) {\r\n      y = u0 * u0;\r\n    } else if ((u1 == 0.5) && (u0 >= 0.0)) {\r\n      y = sqrt(u0);\r\n    } else if ((u0 < 0.0) && (u1 > floor(u1))) {\r\n      y = (rtNaN);\r\n    } else {\r\n      y = pow(u0, u1);\r\n    }\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\n/* Function for MATLAB Function: '<S3>/Magic Tire Const Input' */\r\nstatic void main_calculateFz(real_T RL, real_T b_LONGVL, real_T\r\n  b_UNLOADED_RADIUS, real_T b_ASPECT_RATIO, real_T b_WIDTH, real_T b_Q_RE0,\r\n  real_T b_Q_V1, real_T b_FNOMIN, real_T b_VERTICAL_STIFFNESS, real_T\r\n  b_RIM_RADIUS, real_T b_BOTTOM_STIFF, real_T b_BOTTOM_OFFST, real_T b_Q_V2,\r\n  real_T b_Q_FZ1, real_T b_Q_FZ2, real_T b_Q_FCX, real_T b_Q_FCY, real_T b_PFZ1,\r\n  real_T b_Q_FCY2, real_T b_Q_CAM1, real_T b_Q_CAM2, real_T b_Q_CAM3, real_T\r\n  b_Q_FYS1, real_T b_Q_FYS2, real_T b_Q_FYS3, real_T dpi, real_T omega, real_T\r\n  b_gamma, real_T Fx_ext, real_T Fy_ext, real_T *Fz, real_T *rhoz)\r\n{\r\n  real_T Q_FZ1_squared;\r\n  real_T Romega;\r\n  real_T rho_zfr;\r\n  real_T rho_zg;\r\n  boolean_T d;\r\n  Romega = omega * b_UNLOADED_RADIUS / b_LONGVL;\r\n  Romega = (Romega * Romega * b_Q_V1 + b_Q_RE0) * b_UNLOADED_RADIUS;\r\n  d = !(b_Q_FZ1 == 0.0);\r\n  if (!d) {\r\n    Q_FZ1_squared = b_VERTICAL_STIFFNESS * b_UNLOADED_RADIUS / b_FNOMIN;\r\n    Q_FZ1_squared = Q_FZ1_squared * Q_FZ1_squared - 4.0 * b_Q_FZ2;\r\n    if (Q_FZ1_squared < 0.0) {\r\n      b_Q_FZ1 = 0.0;\r\n    } else {\r\n      b_Q_FZ1 = sqrt(Q_FZ1_squared);\r\n    }\r\n  }\r\n\r\n  Q_FZ1_squared = RL / Romega;\r\n  rho_zfr = Romega - RL;\r\n  rho_zg = (RL * RL * b_Q_CAM2 + b_Q_CAM1 * RL) * b_gamma;\r\n  Romega = (Romega * Romega * b_Q_CAM2 + b_Q_CAM1 * Romega) * b_gamma;\r\n  rho_zg = (1.075 - 0.5 * b_ASPECT_RATIO) * b_WIDTH / 8.0 * (rho_zg * rho_zg) *\r\n    fabs(tan(b_gamma)) / (Romega * Romega) - b_Q_CAM3 * rho_zfr * fabs(b_gamma);\r\n  d = rtIsNaN(rho_zg);\r\n  if (d) {\r\n    rho_zg = 0.0;\r\n  }\r\n\r\n  *rhoz = fmax(rho_zfr + rho_zg, 1.0E-12);\r\n  rho_zfr = b_Q_FCX * Fx_ext / b_FNOMIN;\r\n  rho_zg = *rhoz / b_UNLOADED_RADIUS;\r\n  Romega = (Fy_ext - ((Q_FZ1_squared * b_Q_FYS2 + b_Q_FYS1) + Q_FZ1_squared *\r\n                      Q_FZ1_squared * b_Q_FYS3) * b_gamma) * b_Q_FCY / b_FNOMIN *\r\n    rt_powd_snf(rho_zg, b_Q_FCY2);\r\n  Q_FZ1_squared = rho_zg;\r\n  *Fz = fmax((((b_UNLOADED_RADIUS / b_LONGVL * b_Q_V2 * fabs(omega) + 1.0) -\r\n               rho_zfr * rho_zfr) - Romega * Romega) * (b_PFZ1 * dpi + 1.0) *\r\n             (Q_FZ1_squared * Q_FZ1_squared * b_Q_FZ2 + rho_zg * b_Q_FZ1) *\r\n             b_FNOMIN, ((b_RIM_RADIUS + b_BOTTOM_OFFST) - (b_UNLOADED_RADIUS +\r\n    *rhoz) / cos(b_gamma)) * b_BOTTOM_STIFF);\r\n}\r\n\r\n/* Function for MATLAB Function: '<S3>/Magic Tire Const Input' */\r\nstatic real_T main_solveRLwithRhoz(real_T b_LONGVL, real_T b_UNLOADED_RADIUS,\r\n  real_T b_ASPECT_RATIO, real_T b_WIDTH, real_T b_Q_RE0, real_T b_Q_V1, real_T\r\n  b_FNOMIN, real_T b_VERTICAL_STIFFNESS, real_T b_RIM_RADIUS, real_T\r\n  b_BOTTOM_STIFF, real_T b_BOTTOM_OFFST, real_T b_Q_V2, real_T b_Q_FZ1, real_T\r\n  b_Q_FZ2, real_T b_Q_FCX, real_T b_Q_FCY, real_T b_PFZ1, real_T b_Q_FCY2,\r\n  real_T b_Q_CAM1, real_T b_Q_CAM2, real_T b_Q_CAM3, real_T b_Q_FYS1, real_T\r\n  b_Q_FYS2, real_T b_Q_FYS3, real_T dpi, real_T omega, real_T b_gamma, real_T\r\n  Fx_ext, real_T Fy_ext, real_T rhoz)\r\n{\r\n  real_T RL;\r\n  real_T b_calcRhoz;\r\n  real_T b_y1;\r\n  real_T x0;\r\n  real_T x1;\r\n  real_T x2;\r\n  real_T ytol;\r\n  int32_T i;\r\n  boolean_T converged;\r\n  boolean_T exitg1;\r\n  x0 = b_UNLOADED_RADIUS * 0.5;\r\n  x1 = b_UNLOADED_RADIUS * 0.95;\r\n  ytol = b_UNLOADED_RADIUS * 1.0E-6;\r\n  RL = x1;\r\n  i = 0;\r\n  exitg1 = false;\r\n  while ((!exitg1) && (i < 30)) {\r\n    main_calculateFz(x0, b_LONGVL, b_UNLOADED_RADIUS, b_ASPECT_RATIO, b_WIDTH,\r\n                     b_Q_RE0, b_Q_V1, b_FNOMIN, b_VERTICAL_STIFFNESS,\r\n                     b_RIM_RADIUS, b_BOTTOM_STIFF, b_BOTTOM_OFFST, b_Q_V2,\r\n                     b_Q_FZ1, b_Q_FZ2, b_Q_FCX, b_Q_FCY, b_PFZ1, b_Q_FCY2,\r\n                     b_Q_CAM1, b_Q_CAM2, b_Q_CAM3, b_Q_FYS1, b_Q_FYS2, b_Q_FYS3,\r\n                     dpi, omega, b_gamma, Fx_ext, Fy_ext, &b_y1, &x2);\r\n    main_calculateFz(x1, b_LONGVL, b_UNLOADED_RADIUS, b_ASPECT_RATIO, b_WIDTH,\r\n                     b_Q_RE0, b_Q_V1, b_FNOMIN, b_VERTICAL_STIFFNESS,\r\n                     b_RIM_RADIUS, b_BOTTOM_STIFF, b_BOTTOM_OFFST, b_Q_V2,\r\n                     b_Q_FZ1, b_Q_FZ2, b_Q_FCX, b_Q_FCY, b_PFZ1, b_Q_FCY2,\r\n                     b_Q_CAM1, b_Q_CAM2, b_Q_CAM3, b_Q_FYS1, b_Q_FYS2, b_Q_FYS3,\r\n                     dpi, omega, b_gamma, Fx_ext, Fy_ext, &b_y1, &b_calcRhoz);\r\n    b_y1 = b_calcRhoz - rhoz;\r\n    converged = (fabs(b_y1) < ytol);\r\n    b_calcRhoz = RL;\r\n    if (converged) {\r\n      b_calcRhoz = x1;\r\n    }\r\n\r\n    RL = b_calcRhoz;\r\n    if (converged) {\r\n      exitg1 = true;\r\n    } else {\r\n      x2 = x1 - (x1 - x0) * b_y1 / (b_y1 - (x2 - rhoz));\r\n      b_calcRhoz = x1;\r\n      x0 = b_calcRhoz;\r\n      b_calcRhoz = x2;\r\n      x1 = b_calcRhoz;\r\n      i++;\r\n    }\r\n  }\r\n\r\n  if (RL <= 0.0) {\r\n    RL = 1.0E-8;\r\n  }\r\n\r\n  return RL;\r\n}\r\n\r\n/* Function for MATLAB Function: '<S3>/Magic Tire Const Input' */\r\nstatic real_T main_calculateFz_m(real_T RL, real_T b_LONGVL, real_T\r\n  b_UNLOADED_RADIUS, real_T b_ASPECT_RATIO, real_T b_WIDTH, real_T b_Q_RE0,\r\n  real_T b_Q_V1, real_T b_FNOMIN, real_T b_VERTICAL_STIFFNESS, real_T\r\n  b_RIM_RADIUS, real_T b_BOTTOM_STIFF, real_T b_BOTTOM_OFFST, real_T b_Q_V2,\r\n  real_T b_Q_FZ1, real_T b_Q_FZ2, real_T b_Q_FCX, real_T b_Q_FCY, real_T b_PFZ1,\r\n  real_T b_Q_FCY2, real_T b_Q_CAM1, real_T b_Q_CAM2, real_T b_Q_CAM3, real_T\r\n  b_Q_FYS1, real_T b_Q_FYS2, real_T b_Q_FYS3, real_T dpi, real_T omega, real_T\r\n  b_gamma, real_T Fx_ext, real_T Fy_ext)\r\n{\r\n  real_T Fz;\r\n  real_T Q_FZ1_squared;\r\n  real_T Romega;\r\n  real_T Romega_tmp;\r\n  real_T rho_zfr;\r\n  real_T rho_zg;\r\n  boolean_T d;\r\n  Romega = omega * b_UNLOADED_RADIUS / b_LONGVL;\r\n  Romega = (Romega * Romega * b_Q_V1 + b_Q_RE0) * b_UNLOADED_RADIUS;\r\n  d = !(b_Q_FZ1 == 0.0);\r\n  if (!d) {\r\n    Q_FZ1_squared = b_VERTICAL_STIFFNESS * b_UNLOADED_RADIUS / b_FNOMIN;\r\n    Q_FZ1_squared = Q_FZ1_squared * Q_FZ1_squared - 4.0 * b_Q_FZ2;\r\n    if (Q_FZ1_squared < 0.0) {\r\n      b_Q_FZ1 = 0.0;\r\n    } else {\r\n      b_Q_FZ1 = sqrt(Q_FZ1_squared);\r\n    }\r\n  }\r\n\r\n  Q_FZ1_squared = RL / Romega;\r\n  rho_zfr = Romega - RL;\r\n  rho_zg = (RL * RL * b_Q_CAM2 + b_Q_CAM1 * RL) * b_gamma;\r\n  Romega = (Romega * Romega * b_Q_CAM2 + b_Q_CAM1 * Romega) * b_gamma;\r\n  rho_zg = (1.075 - 0.5 * b_ASPECT_RATIO) * b_WIDTH / 8.0 * (rho_zg * rho_zg) *\r\n    fabs(tan(b_gamma)) / (Romega * Romega) - b_Q_CAM3 * rho_zfr * fabs(b_gamma);\r\n  d = rtIsNaN(rho_zg);\r\n  if (d) {\r\n    rho_zg = 0.0;\r\n  }\r\n\r\n  rho_zfr = fmax(rho_zfr + rho_zg, 1.0E-12);\r\n  rho_zg = b_Q_FCX * Fx_ext / b_FNOMIN;\r\n  Romega_tmp = rho_zfr / b_UNLOADED_RADIUS;\r\n  Romega = (Fy_ext - ((Q_FZ1_squared * b_Q_FYS2 + b_Q_FYS1) + Q_FZ1_squared *\r\n                      Q_FZ1_squared * b_Q_FYS3) * b_gamma) * b_Q_FCY / b_FNOMIN *\r\n    rt_powd_snf(Romega_tmp, b_Q_FCY2);\r\n  Q_FZ1_squared = Romega_tmp;\r\n  Fz = fmax((((b_UNLOADED_RADIUS / b_LONGVL * b_Q_V2 * fabs(omega) + 1.0) -\r\n              rho_zg * rho_zg) - Romega * Romega) * (b_PFZ1 * dpi + 1.0) *\r\n            (Q_FZ1_squared * Q_FZ1_squared * b_Q_FZ2 + Romega_tmp * b_Q_FZ1) *\r\n            b_FNOMIN, ((b_RIM_RADIUS + b_BOTTOM_OFFST) - (b_UNLOADED_RADIUS +\r\n              rho_zfr) / cos(b_gamma)) * b_BOTTOM_STIFF);\r\n  return Fz;\r\n}\r\n\r\nreal_T rt_atan2d_snf(real_T u0, real_T u1)\r\n{\r\n  real_T y;\r\n  if (rtIsNaN(u0) || rtIsNaN(u1)) {\r\n    y = (rtNaN);\r\n  } else if (rtIsInf(u0) && rtIsInf(u1)) {\r\n    int32_T tmp;\r\n    int32_T tmp_0;\r\n    if (u1 > 0.0) {\r\n      tmp = 1;\r\n    } else {\r\n      tmp = -1;\r\n    }\r\n\r\n    if (u0 > 0.0) {\r\n      tmp_0 = 1;\r\n    } else {\r\n      tmp_0 = -1;\r\n    }\r\n\r\n    y = atan2(tmp_0, tmp);\r\n  } else if (u1 == 0.0) {\r\n    if (u0 > 0.0) {\r\n      y = RT_PI / 2.0;\r\n    } else if (u0 < 0.0) {\r\n      y = -(RT_PI / 2.0);\r\n    } else {\r\n      y = 0.0;\r\n    }\r\n  } else {\r\n    y = atan2(u0, u1);\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\n/* Function for MATLAB Function: '<S3>/Magic Tire Const Input' */\r\nstatic real_T main_div0protect_k(real_T u)\r\n{\r\n  real_T y;\r\n  y = fabs(u);\r\n  if (y < 0.0001) {\r\n    y /= 0.0001;\r\n    y *= y;\r\n    y = 0.0002 / (3.0 - y);\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\n/* Function for MATLAB Function: '<S3>/Magic Tire Const Input' */\r\nstatic void main_abs(const real_T x_data[], const int32_T x_size[2], real_T\r\n                     y_data[], int32_T y_size[2])\r\n{\r\n  int32_T b;\r\n  y_size[0] = 1;\r\n  b = x_size[1];\r\n  y_size[1] = b;\r\n  if (b - 1 >= 0) {\r\n    y_data[0] = fabs(x_data[0]);\r\n  }\r\n}\r\n\r\nstatic void main_binary_expand_op_4(real_T *in1, real_T in3, const int32_T in4[2],\r\n  real_T in5, real_T in6)\r\n{\r\n  real_T tmp_data;\r\n  int32_T in5_size[2];\r\n  int32_T tmp_size[2];\r\n  int32_T in4_idx_0;\r\n  int32_T in4_idx_1;\r\n  int32_T in4_idx_1_0;\r\n\r\n  /* MATLAB Function: '<S3>/Magic Tire Const Input' */\r\n  in4_idx_1_0 = in4[1];\r\n  in4_idx_1 = in4[1];\r\n  in5_size[0] = 1;\r\n  in5_size[1] = in4_idx_1;\r\n  main_abs(&in5, in5_size, &tmp_data, tmp_size);\r\n  if (tmp_size[1] != 1) {\r\n    in4_idx_1_0 = tmp_size[1];\r\n  }\r\n\r\n  for (in4_idx_0 = 0; in4_idx_0 < in4_idx_1_0; in4_idx_0++) {\r\n    *in1 = tmp_data / in6 * in3;\r\n  }\r\n\r\n  /* End of MATLAB Function: '<S3>/Magic Tire Const Input' */\r\n}\r\n\r\n/* Function for MATLAB Function: '<S3>/Magic Tire Const Input' */\r\nstatic void main_atan(real_T x_data[], const int32_T x_size[2])\r\n{\r\n  int32_T b;\r\n  int32_T k;\r\n  b = x_size[1];\r\n  for (k = 0; k < b; k++) {\r\n    x_data[0] = atan(x_data[0]);\r\n  }\r\n}\r\n\r\n/* Function for MATLAB Function: '<S3>/Magic Tire Const Input' */\r\nstatic void main_cos(real_T x_data[], const int32_T x_size[2])\r\n{\r\n  int32_T b;\r\n  int32_T k;\r\n  b = x_size[1];\r\n  for (k = 0; k < b; k++) {\r\n    x_data[0] = cos(x_data[0]);\r\n  }\r\n}\r\n\r\n/* Function for MATLAB Function: '<S3>/Magic Tire Const Input' */\r\nstatic void main_sqrt(real_T x_data[], const int32_T x_size[2])\r\n{\r\n  int32_T b;\r\n  int32_T k;\r\n  b = x_size[1];\r\n  for (k = 0; k < b; k++) {\r\n    x_data[0] = sqrt(x_data[0]);\r\n  }\r\n}\r\n\r\nstatic void main_binary_expand_op_3(real_T in1_data[], int32_T in1_size[2],\r\n  real_T in2, real_T in3, real_T in4, real_T in5, real_T in6, const int32_T in7\r\n  [2], real_T in8, real_T in9, int32_T in10, real_T in11)\r\n{\r\n  real_T in9_data;\r\n  real_T tmp;\r\n  real_T tmp_data;\r\n  int32_T in9_size[2];\r\n  int32_T tmp_size[2];\r\n  int32_T i;\r\n  int32_T in7_idx_1;\r\n  int32_T stride_2_1;\r\n\r\n  /* MATLAB Function: '<S3>/Magic Tire Const Input' */\r\n  tmp = atan(in5 * in6);\r\n  tmp = cos(tmp);\r\n  in7_idx_1 = in7[1];\r\n  in9_size[0] = 1;\r\n  in9_size[1] = in10;\r\n  if (in10 - 1 >= 0) {\r\n    in9_data = in9;\r\n  }\r\n\r\n  main_abs(&in9_data, in9_size, &tmp_data, tmp_size);\r\n  if (in1_size[1] == 1) {\r\n    i = tmp_size[1];\r\n  } else {\r\n    i = in1_size[1];\r\n  }\r\n\r\n  if (i == 1) {\r\n    in9_size[1] = in7_idx_1;\r\n  } else if (in1_size[1] == 1) {\r\n    in9_size[1] = tmp_size[1];\r\n  } else {\r\n    in9_size[1] = in1_size[1];\r\n  }\r\n\r\n  stride_2_1 = (in1_size[1] != 1);\r\n  if (in1_size[1] == 1) {\r\n    i = tmp_size[1];\r\n  } else {\r\n    i = in1_size[1];\r\n  }\r\n\r\n  if (i != 1) {\r\n    if (in1_size[1] == 1) {\r\n      in7_idx_1 = tmp_size[1];\r\n    } else {\r\n      in7_idx_1 = in1_size[1];\r\n    }\r\n  }\r\n\r\n  for (i = 0; i < in7_idx_1; i++) {\r\n    in9_data = (in3 * in4 + 1.0) * in2 * tmp * (in1_data[i * stride_2_1] * in11\r\n      + tmp_data * in8);\r\n  }\r\n\r\n  in1_size[0] = 1;\r\n  in7_idx_1 = in9_size[1];\r\n  in1_size[1] = in7_idx_1;\r\n  for (i = 0; i < in7_idx_1; i++) {\r\n    in1_data[0] = in9_data;\r\n  }\r\n\r\n  /* End of MATLAB Function: '<S3>/Magic Tire Const Input' */\r\n}\r\n\r\n/* Function for MATLAB Function: '<S3>/Magic Tire Const Input' */\r\nstatic void main_div0protect_kw(real_T u, real_T *y, real_T *yabs)\r\n{\r\n  *yabs = fabs(u);\r\n  if (*yabs < 0.0001) {\r\n    real_T varargin_1;\r\n    varargin_1 = *yabs / 0.0001;\r\n    varargin_1 *= varargin_1;\r\n    *yabs = 0.0002 / (3.0 - varargin_1);\r\n  }\r\n\r\n  *y = *yabs;\r\n  if (u < 0.0) {\r\n    *y = -*yabs;\r\n  }\r\n}\r\n\r\nstatic void main_binary_expand_op_2(real_T in1_data[], int32_T in1_size[2],\r\n  const real_T *in2, real_T in3, real_T in4, const real_T *in5, const real_T\r\n  *in6, const int32_T in7[2], real_T in8, const real_T *in9)\r\n{\r\n  real_T tmp;\r\n  real_T tmp_data;\r\n  int32_T in8_size[2];\r\n  int32_T tmp_size[2];\r\n  int32_T in7_idx_0;\r\n  int32_T in7_idx_1;\r\n  int32_T in7_idx_1_0;\r\n\r\n  /* MATLAB Function: '<S3>/Magic Tire Const Input' */\r\n  tmp = fabs(*in5);\r\n  tmp = atan(in3 * in4 * tmp);\r\n  in7_idx_1_0 = in7[1];\r\n  in7_idx_1 = in7[1];\r\n  in8_size[0] = 1;\r\n  in8_size[1] = in7_idx_1;\r\n  main_abs(&in8, in8_size, &tmp_data, tmp_size);\r\n  in7_idx_1 = in7[1];\r\n  in1_size[0] = 1;\r\n  if (in7_idx_1 == 1) {\r\n    in7_idx_0 = tmp_size[1];\r\n  } else {\r\n    in7_idx_0 = in7_idx_1;\r\n  }\r\n\r\n  if (in7_idx_0 == 1) {\r\n    in1_size[1] = in7_idx_1_0;\r\n  } else if (in7_idx_1 == 1) {\r\n    in1_size[1] = tmp_size[1];\r\n  } else {\r\n    in1_size[1] = in7_idx_1;\r\n  }\r\n\r\n  if (in7_idx_1 == 1) {\r\n    in7_idx_0 = tmp_size[1];\r\n  } else {\r\n    in7_idx_0 = in7_idx_1;\r\n  }\r\n\r\n  if (in7_idx_0 == 1) {\r\n    in7_idx_1 = in7_idx_1_0;\r\n  } else if (in7_idx_1 == 1) {\r\n    in7_idx_1 = tmp_size[1];\r\n  }\r\n\r\n  for (in7_idx_0 = 0; in7_idx_0 < in7_idx_1; in7_idx_0++) {\r\n    in1_data[in7_idx_0] = *in2 * 2.0 / 3.1415926535897931 * tmp * *in6 / (0.0001\r\n      * *in9 + tmp_data);\r\n  }\r\n\r\n  /* End of MATLAB Function: '<S3>/Magic Tire Const Input' */\r\n}\r\n\r\n/* Function for MATLAB Function: '<S3>/Magic Tire Const Input' */\r\nstatic void main_acos(real_T x_data[], const int32_T x_size[2])\r\n{\r\n  int32_T b;\r\n  int32_T k;\r\n  b = x_size[1];\r\n  for (k = 0; k < b; k++) {\r\n    x_data[0] = acos(x_data[0]);\r\n  }\r\n}\r\n\r\nstatic void main_binary_expand_op_1(real_T *in1, real_T in3, real_T in4, real_T\r\n  in5, const int32_T in6[2], const real_T in7[27], const int32_T in8_size[2],\r\n  real_T in9, real_T in10, int32_T in11, real_T in12)\r\n{\r\n  int32_T i;\r\n  int32_T in6_idx_1;\r\n  int32_T in6_idx_1_0;\r\n\r\n  /* MATLAB Function: '<S3>/Magic Tire Const Input' incorporates:\r\n   *  SignalConversion generated from: '<S6>/ SFunction '\r\n   */\r\n  i = in8_size[1];\r\n  in6_idx_1_0 = in6[1];\r\n  in6_idx_1 = in6[1];\r\n  if (in11 == 1) {\r\n    if (in6_idx_1 == 1) {\r\n      if (i == 1) {\r\n        in6_idx_1 = in6_idx_1_0;\r\n      } else {\r\n        in6_idx_1 = i;\r\n      }\r\n    }\r\n  } else {\r\n    in6_idx_1 = in11;\r\n  }\r\n\r\n  for (i = 0; i < in6_idx_1; i++) {\r\n    *in1 = ((in4 * in5 + in3) * in7[11] + in9) - in10 / in12;\r\n  }\r\n\r\n  /* End of MATLAB Function: '<S3>/Magic Tire Const Input' */\r\n}\r\n\r\nstatic void main_binary_expand_op(real_T *in1, const int32_T in2_size[2], real_T\r\n  in3, real_T in4, real_T in5, const int32_T in6[2], const real_T in7[27], const\r\n  int32_T in8_size[2], real_T in9, real_T in10, real_T in11, real_T in12, const\r\n  real_T in13[9])\r\n{\r\n  real_T in3_data;\r\n  int32_T in6_idx_1;\r\n  int32_T in6_idx_1_0;\r\n  int32_T tmp;\r\n\r\n  /* MATLAB Function: '<S3>/Magic Tire Const Input' incorporates:\r\n   *  SignalConversion generated from: '<S6>/ SFunction '\r\n   */\r\n  tmp = in8_size[1];\r\n  in6_idx_1_0 = in6[1];\r\n  in6_idx_1 = in6[1];\r\n  if (in6_idx_1 == 1) {\r\n    if (tmp == 1) {\r\n      in6_idx_1 = in6_idx_1_0;\r\n    } else {\r\n      in6_idx_1 = tmp;\r\n    }\r\n  }\r\n\r\n  for (in6_idx_1_0 = 0; in6_idx_1_0 < in6_idx_1; in6_idx_1_0++) {\r\n    if (tmp - 1 >= 0) {\r\n      in3_data = (((in9 * in10 - in11) / in12 * in13[0] + (in4 * in5 + in3) *\r\n                   in7[11]) + in13[4]) - 1.0;\r\n    }\r\n  }\r\n\r\n  tmp = in2_size[1];\r\n  for (in6_idx_1_0 = 0; in6_idx_1_0 < tmp; in6_idx_1_0++) {\r\n    *in1 = in3_data;\r\n  }\r\n\r\n  /* End of MATLAB Function: '<S3>/Magic Tire Const Input' */\r\n}\r\n\r\n/* Function for MATLAB Function: '<S3>/Magic Tire Const Input' */\r\nstatic real_T main_solveRLwithFz(real_T b_LONGVL, real_T b_UNLOADED_RADIUS,\r\n  real_T b_ASPECT_RATIO, real_T b_WIDTH, real_T b_Q_RE0, real_T b_Q_V1, real_T\r\n  b_FNOMIN, real_T b_VERTICAL_STIFFNESS, real_T b_RIM_RADIUS, real_T\r\n  b_BOTTOM_STIFF, real_T b_BOTTOM_OFFST, real_T b_Q_V2, real_T b_Q_FZ1, real_T\r\n  b_Q_FZ2, real_T b_Q_FCX, real_T b_Q_FCY, real_T b_PFZ1, real_T b_Q_FCY2,\r\n  real_T b_Q_CAM1, real_T b_Q_CAM2, real_T b_Q_CAM3, real_T b_Q_FYS1, real_T\r\n  b_Q_FYS2, real_T b_Q_FYS3, real_T dpi, real_T omega, real_T b_gamma, real_T\r\n  Fx_ext, real_T Fy_ext, real_T Fz)\r\n{\r\n  real_T RL;\r\n  real_T b_y1;\r\n  real_T d_idx_0;\r\n  real_T x0;\r\n  real_T x1;\r\n  real_T ytol;\r\n  int32_T i;\r\n  boolean_T converged;\r\n  boolean_T exitg1;\r\n  x0 = b_UNLOADED_RADIUS * 0.5;\r\n  x1 = b_UNLOADED_RADIUS * 0.95;\r\n  ytol = b_FNOMIN * 1.0E-6;\r\n  RL = x1;\r\n  i = 0;\r\n  exitg1 = false;\r\n  while ((!exitg1) && (i < 30)) {\r\n    b_y1 = main_calculateFz_m(x1, b_LONGVL, b_UNLOADED_RADIUS, b_ASPECT_RATIO,\r\n      b_WIDTH, b_Q_RE0, b_Q_V1, b_FNOMIN, b_VERTICAL_STIFFNESS, b_RIM_RADIUS,\r\n      b_BOTTOM_STIFF, b_BOTTOM_OFFST, b_Q_V2, b_Q_FZ1, b_Q_FZ2, b_Q_FCX, b_Q_FCY,\r\n      b_PFZ1, b_Q_FCY2, b_Q_CAM1, b_Q_CAM2, b_Q_CAM3, b_Q_FYS1, b_Q_FYS2,\r\n      b_Q_FYS3, dpi, omega, b_gamma, Fx_ext, Fy_ext) - Fz;\r\n    converged = (fabs(b_y1) < ytol);\r\n    d_idx_0 = RL;\r\n    if (converged) {\r\n      d_idx_0 = x1;\r\n    }\r\n\r\n    RL = d_idx_0;\r\n    if (converged) {\r\n      exitg1 = true;\r\n    } else {\r\n      b_y1 = x1 - (x1 - x0) * b_y1 / (b_y1 - (main_calculateFz_m(x0, b_LONGVL,\r\n        b_UNLOADED_RADIUS, b_ASPECT_RATIO, b_WIDTH, b_Q_RE0, b_Q_V1, b_FNOMIN,\r\n        b_VERTICAL_STIFFNESS, b_RIM_RADIUS, b_BOTTOM_STIFF, b_BOTTOM_OFFST,\r\n        b_Q_V2, b_Q_FZ1, b_Q_FZ2, b_Q_FCX, b_Q_FCY, b_PFZ1, b_Q_FCY2, b_Q_CAM1,\r\n        b_Q_CAM2, b_Q_CAM3, b_Q_FYS1, b_Q_FYS2, b_Q_FYS3, dpi, omega, b_gamma,\r\n        Fx_ext, Fy_ext) - Fz));\r\n      d_idx_0 = x1;\r\n      x0 = d_idx_0;\r\n      d_idx_0 = b_y1;\r\n      x1 = d_idx_0;\r\n      i++;\r\n    }\r\n  }\r\n\r\n  if (RL <= 0.0) {\r\n    RL = 1.0E-8;\r\n  }\r\n\r\n  return RL;\r\n}\r\n\r\n/* Function for MATLAB Function: '<S3>/Magic Tire Const Input' */\r\nstatic void main_vdyncsmtire(real_T omega, real_T Vx, real_T Vy, real_T psidot,\r\n  real_T b_gamma, real_T press, const real_T scaleFactors[27], real_T *rhoz,\r\n  real_T b_turnslip, real_T b_PRESMAX, real_T b_PRESMIN, real_T b_FZMAX, real_T\r\n  b_FZMIN, real_T b_VXLOW, real_T b_KPUMAX, real_T b_KPUMIN, real_T b_ALPMAX,\r\n  real_T b_ALPMIN, real_T b_CAMMIN, real_T b_CAMMAX, real_T b_LONGVL, real_T\r\n  b_UNLOADED_RADIUS, real_T b_RIM_RADIUS, real_T b_NOMPRES, real_T b_FNOMIN,\r\n  real_T b_VERTICAL_STIFFNESS, real_T b_DREFF, real_T b_BREFF, real_T b_FREFF,\r\n  real_T b_Q_RE0, real_T b_Q_V1, real_T b_Q_V2, real_T b_Q_FZ1, real_T b_Q_FZ2,\r\n  real_T b_Q_FCX, real_T b_Q_FCY, real_T b_PFZ1, real_T b_Q_FCY2, real_T\r\n  b_BOTTOM_OFFST, real_T b_BOTTOM_STIFF, real_T b_PCX1, real_T b_PDX1, real_T\r\n  b_PDX2, real_T b_PDX3, real_T b_PEX1, real_T b_PEX2, real_T b_PEX3, real_T\r\n  b_PEX4, real_T b_PKX1, real_T b_PKX2, real_T b_PKX3, real_T b_PHX1, real_T\r\n  b_PHX2, real_T b_PVX1, real_T b_PVX2, real_T b_PPX1, real_T b_PPX2, real_T\r\n  b_PPX3, real_T b_PPX4, real_T b_RBX1, real_T b_RBX2, real_T b_RBX3, real_T\r\n  b_RCX1, real_T b_REX1, real_T b_REX2, real_T b_RHX1, real_T b_QSX1, real_T\r\n  b_QSX2, real_T b_QSX3, real_T b_QSX4, real_T b_QSX5, real_T b_QSX6, real_T\r\n  b_QSX7, real_T b_QSX8, real_T b_QSX9, real_T b_QSX10, real_T b_QSX11, real_T\r\n  b_PPMX1, real_T b_PCY1, real_T b_PDY1, real_T b_PDY2, real_T b_PDY3, real_T\r\n  b_PEY1, real_T b_PEY2, real_T b_PEY3, real_T b_PEY4, real_T b_PEY5, real_T\r\n  b_PKY1, real_T b_PKY2, real_T b_PKY3, real_T b_PKY4, real_T b_PKY5, real_T\r\n  b_PKY6, real_T b_PKY7, real_T b_PHY1, real_T b_PHY2, real_T b_PVY1, real_T\r\n  b_PVY2, real_T b_PVY3, real_T b_PVY4, real_T b_PPY1, real_T b_PPY2, real_T\r\n  b_PPY3, real_T b_PPY4, real_T b_PPY5, real_T b_RBY1, real_T b_RBY2, real_T\r\n  b_RBY3, real_T b_RBY4, real_T b_RCY1, real_T b_REY1, real_T b_REY2, real_T\r\n  b_RHY1, real_T b_RHY2, real_T b_RVY1, real_T b_RVY2, real_T b_RVY3, real_T\r\n  b_RVY4, real_T b_RVY5, real_T b_RVY6, real_T b_QSY1, real_T b_QSY2, real_T\r\n  b_QSY3, real_T b_QSY4, real_T b_QSY5, real_T b_QSY6, real_T b_QSY7, real_T\r\n  b_QSY8, real_T b_QBZ1, real_T b_QBZ2, real_T b_QBZ3, real_T b_QBZ4, real_T\r\n  b_QBZ5, real_T b_QBZ6, real_T b_QBZ9, real_T b_QBZ10, real_T b_QCZ1, real_T\r\n  b_QDZ1, real_T b_QDZ2, real_T b_QDZ3, real_T b_QDZ4, real_T b_QDZ6, real_T\r\n  b_QDZ7, real_T b_QDZ8, real_T b_QDZ9, real_T b_QDZ10, real_T b_QDZ11, real_T\r\n  b_QEZ1, real_T b_QEZ2, real_T b_QEZ3, real_T b_QEZ4, real_T b_QEZ5, real_T\r\n  b_QHZ1, real_T b_QHZ2, real_T b_QHZ3, real_T b_QHZ4, real_T b_PPZ1, real_T\r\n  b_PPZ2, real_T b_SSZ1, real_T b_SSZ2, real_T b_SSZ3, real_T b_SSZ4, real_T\r\n  b_PDXP1, real_T b_PDXP2, real_T b_PDXP3, real_T b_PKYP1, real_T b_PDYP1,\r\n  real_T b_PDYP2, real_T b_PDYP3, real_T b_PDYP4, real_T b_PHYP1, real_T b_PHYP2,\r\n  real_T b_PHYP3, real_T b_PHYP4, real_T b_PECP1, real_T b_PECP2, real_T b_QDTP1,\r\n  real_T b_QCRP1, real_T b_QCRP2, real_T b_QBRP1, real_T b_QDRP1, real_T b_QDRP2,\r\n  real_T b_WIDTH, real_T b_Q_RA1, real_T b_Q_RA2, real_T b_Q_RB1, real_T b_Q_RB2,\r\n  real_T b_QSX12, real_T b_QSX13, real_T b_QSX14, real_T\r\n  b_LONGITUDINAL_STIFFNESS, real_T b_LATERAL_STIFFNESS, real_T b_PCFX1, real_T\r\n  b_PCFX2, real_T b_PCFX3, real_T b_PCFY1, real_T b_PCFY2, real_T b_PCFY3,\r\n  real_T Fx_ext, real_T Fy_ext, real_T Fz_ext, real_T vertType, real_T b_Q_CAM1,\r\n  real_T b_Q_CAM2, real_T b_Q_CAM3, real_T b_Q_FYS1, real_T b_Q_FYS2, real_T\r\n  b_Q_FYS3, real_T b_ASPECT_RATIO, real_T *Fx, real_T *Fy, real_T *Fz, real_T\r\n  *Mx, real_T *My, real_T *Mz, real_T *Re, real_T *kappa, real_T *alpha, real_T *\r\n  sig_x, real_T *sig_y, real_T *patch_a, real_T *patch_b, real_T *RL, real_T *Tw)\r\n{\r\n  __m128d tmp_0;\r\n  real_T zeta[9];\r\n  real_T tmp_1[2];\r\n  real_T Cz;\r\n  real_T DHyphi;\r\n  real_T Fzo_prime;\r\n  real_T Kyalpha;\r\n  real_T Kyalpha_tmp;\r\n  real_T Kygammao;\r\n  real_T Re_tmp;\r\n  real_T SHy;\r\n  real_T SHykappa;\r\n  real_T SVygamma;\r\n  real_T SVygamma_tmp;\r\n  real_T Vc;\r\n  real_T Vs;\r\n  real_T Vsy;\r\n  real_T b_idx_0;\r\n  real_T c_u;\r\n  real_T dfz;\r\n  real_T dpi;\r\n  real_T epsilon_gamma;\r\n  real_T f_idx_0;\r\n  real_T gamma_star;\r\n  real_T ib;\r\n  real_T jb_idx_0;\r\n  real_T kappa_x;\r\n  real_T lam_mux_star;\r\n  real_T lam_mux_star_tmp;\r\n  real_T lam_muy_prime;\r\n  real_T lb_idx_0;\r\n  real_T mu_y;\r\n  real_T mu_y_tmp;\r\n  real_T n_idx_0;\r\n  real_T pb_idx_0;\r\n  real_T phi;\r\n  real_T phi_data;\r\n  real_T phi_data_0;\r\n  real_T phi_t;\r\n  real_T rb_idx_0;\r\n  real_T tmpDrphiVar_data;\r\n  real_T tmp_data_0;\r\n  int32_T ib_tmp[2];\r\n  int32_T nb_size[2];\r\n  int32_T nb_tmp_size[2];\r\n  int32_T phi_size[2];\r\n  int32_T phi_size_0[2];\r\n  int32_T tmpDrphiVar_size[2];\r\n  int32_T tmp_size[2];\r\n  int32_T vc_tmp_size[2];\r\n  int32_T i;\r\n  int32_T loop_ub;\r\n  int32_T ob_size_idx_0;\r\n  int32_T tmp;\r\n  int32_T tmp_data;\r\n  int32_T trueCount;\r\n  int8_T nb_data;\r\n  boolean_T isLowSpeed;\r\n  boolean_T tmp_2;\r\n  boolean_T turnslipinds;\r\n  main_div0protect(Vx, b_VXLOW, &dpi, &Vs);\r\n  b_idx_0 = b_gamma;\r\n  if (b_gamma < b_CAMMIN) {\r\n    b_idx_0 = b_CAMMIN;\r\n  }\r\n\r\n  if (b_idx_0 > b_CAMMAX) {\r\n    b_idx_0 = b_CAMMAX;\r\n  }\r\n\r\n  f_idx_0 = press;\r\n  if (press < b_PRESMIN) {\r\n    f_idx_0 = b_PRESMIN;\r\n  }\r\n\r\n  if (f_idx_0 > b_PRESMAX) {\r\n    f_idx_0 = b_PRESMAX;\r\n  }\r\n\r\n  dpi = (f_idx_0 - b_NOMPRES) / b_NOMPRES;\r\n  lam_mux_star = scaleFactors[1];\r\n  if (scaleFactors[1] <= 0.0) {\r\n    lam_mux_star = 1.0;\r\n  }\r\n\r\n  DHyphi = scaleFactors[2];\r\n  if (scaleFactors[2] <= 0.0) {\r\n    DHyphi = 1.0;\r\n  }\r\n\r\n  n_idx_0 = scaleFactors[0];\r\n  if (scaleFactors[0] <= 0.0) {\r\n    n_idx_0 = 1.0;\r\n  }\r\n\r\n  Cz = scaleFactors[22];\r\n  if (scaleFactors[22] <= 0.0) {\r\n    Cz = 1.0;\r\n  }\r\n\r\n  *RL = b_UNLOADED_RADIUS * 0.95;\r\n  if (vertType == 2.0) {\r\n    *RL = main_solveRLwithRhoz(b_LONGVL, b_UNLOADED_RADIUS, b_ASPECT_RATIO,\r\n      b_WIDTH, b_Q_RE0, b_Q_V1, b_FNOMIN, b_VERTICAL_STIFFNESS, b_RIM_RADIUS,\r\n      b_BOTTOM_STIFF, b_BOTTOM_OFFST, b_Q_V2, b_Q_FZ1, b_Q_FZ2, b_Q_FCX, b_Q_FCY,\r\n      b_PFZ1, b_Q_FCY2, b_Q_CAM1, b_Q_CAM2, b_Q_CAM3, b_Q_FYS1, b_Q_FYS2,\r\n      b_Q_FYS3, dpi, omega, b_idx_0, Fx_ext, Fy_ext, *rhoz);\r\n    *Fz = main_calculateFz_m(*RL, b_LONGVL, b_UNLOADED_RADIUS, b_ASPECT_RATIO,\r\n      b_WIDTH, b_Q_RE0, b_Q_V1, b_FNOMIN, b_VERTICAL_STIFFNESS, b_RIM_RADIUS,\r\n      b_BOTTOM_STIFF, b_BOTTOM_OFFST, b_Q_V2, b_Q_FZ1, b_Q_FZ2, b_Q_FCX, b_Q_FCY,\r\n      b_PFZ1, b_Q_FCY2, b_Q_CAM1, b_Q_CAM2, b_Q_CAM3, b_Q_FYS1, b_Q_FYS2,\r\n      b_Q_FYS3, dpi, omega, b_idx_0, Fx_ext, Fy_ext);\r\n  } else {\r\n    *Fz = Fz_ext;\r\n  }\r\n\r\n  Kyalpha = *Fz;\r\n  if (*Fz <= 0.0) {\r\n    Kyalpha = 1.0;\r\n  }\r\n\r\n  if (*Fz < b_FZMIN) {\r\n    *Fz = b_FZMIN;\r\n  }\r\n\r\n  if (*Fz > b_FZMAX) {\r\n    *Fz = b_FZMAX;\r\n  }\r\n\r\n  Fzo_prime = n_idx_0 * b_FNOMIN;\r\n  dfz = (*Fz - Fzo_prime) / Fzo_prime;\r\n  epsilon_gamma = (b_PECP2 * dfz + 1.0) * b_PECP1;\r\n  Cz = (b_PFZ1 * dpi + 1.0) * (b_VERTICAL_STIFFNESS * Cz);\r\n  gamma_star = omega * b_UNLOADED_RADIUS / b_LONGVL;\r\n  Re_tmp = Kyalpha / b_FNOMIN;\r\n  *Re = (gamma_star * gamma_star * b_Q_V1 + b_Q_RE0) * b_UNLOADED_RADIUS - (atan\r\n    (Re_tmp * b_BREFF) * b_DREFF + Re_tmp * b_FREFF) * (b_FNOMIN / Cz);\r\n  if (*Re < 0.001) {\r\n    *Re = 0.001;\r\n  }\r\n\r\n  *kappa = (*Re * omega - Vx) / Vs;\r\n  if (*kappa < b_KPUMIN) {\r\n    *kappa = b_KPUMIN;\r\n  }\r\n\r\n  if (*kappa > b_KPUMAX) {\r\n    *kappa = b_KPUMAX;\r\n  }\r\n\r\n  kappa_x = (b_PHX2 * dfz + b_PHX1) * scaleFactors[10] + *kappa;\r\n  *alpha = rt_atan2d_snf(Vy, Vs);\r\n  if (*alpha < b_ALPMIN) {\r\n    *alpha = b_ALPMIN;\r\n  }\r\n\r\n  if (*alpha > b_ALPMAX) {\r\n    *alpha = b_ALPMAX;\r\n  }\r\n\r\n  gamma_star = sin(b_idx_0);\r\n  phi_t = -Vs * *kappa;\r\n  Kyalpha = tan(*alpha);\r\n  Vsy = -Vs * Kyalpha;\r\n  Vsy *= Vsy;\r\n  Vs = sqrt(phi_t * phi_t + Vsy);\r\n  main_div0protect(Vx, b_VXLOW, &phi_t, &Vc);\r\n  Vc = sqrt(Vx * Vx + Vsy);\r\n  main_div0protect(Vc, b_VXLOW, &Vsy, &mu_y);\r\n  Vc = main_div0protect_k(Vc);\r\n  lam_mux_star_tmp = scaleFactors[3] * Vs / b_LONGVL + 1.0;\r\n  lam_mux_star /= lam_mux_star_tmp;\r\n  Vs = DHyphi / lam_mux_star_tmp;\r\n  lam_muy_prime = Vs * 10.0 / (9.0 * Vs + 1.0);\r\n  lam_mux_star_tmp = gamma_star * gamma_star;\r\n  mu_y_tmp = dpi * dpi;\r\n  mu_y = ((b_PPY3 * dpi + 1.0) + mu_y_tmp * b_PPY4) * (b_PDY2 * dfz + b_PDY1) *\r\n    (1.0 - lam_mux_star_tmp * b_PDY3) * Vs;\r\n  phi_t = -psidot / phi_t * cos(*alpha);\r\n  ib = phi_t;\r\n  trueCount = 0;\r\n  if (Vx < b_VXLOW) {\r\n    for (i = 0; i < 1; i++) {\r\n      trueCount++;\r\n    }\r\n  }\r\n\r\n  ib_tmp[0] = 1;\r\n  ib_tmp[1] = trueCount;\r\n  if (Vx < b_VXLOW) {\r\n    nb_data = 0;\r\n  }\r\n\r\n  tmpDrphiVar_size[0] = 1;\r\n  tmpDrphiVar_size[1] = ib_tmp[1];\r\n  loop_ub = ib_tmp[1];\r\n  if (loop_ub - 1 >= 0) {\r\n    tmpDrphiVar_data = Vx;\r\n  }\r\n\r\n  main_abs(&tmpDrphiVar_data, tmpDrphiVar_size, &tmp_data_0, tmp_size);\r\n  if (ib_tmp[1] == tmp_size[1]) {\r\n    tmpDrphiVar_size[0] = 1;\r\n    tmpDrphiVar_size[1] = ib_tmp[1];\r\n    loop_ub = ib_tmp[1];\r\n    if (loop_ub - 1 >= 0) {\r\n      tmpDrphiVar_data = Vx;\r\n    }\r\n\r\n    main_abs(&tmpDrphiVar_data, tmpDrphiVar_size, &tmp_data_0, tmp_size);\r\n    loop_ub = ib_tmp[1];\r\n    if (loop_ub - 1 >= 0) {\r\n      ib = tmp_data_0 / b_VXLOW * phi_t;\r\n    }\r\n  } else {\r\n    main_binary_expand_op_4(&ib, phi_t, ib_tmp, Vx, b_VXLOW);\r\n  }\r\n\r\n  phi = ((1.0 - epsilon_gamma) * fabs(omega) * gamma_star + psidot) * (1.0 / Vc);\r\n  turnslipinds = ((b_turnslip == 1.0) && (fabs(phi) > 0.01));\r\n  isLowSpeed = !turnslipinds;\r\n  SHykappa = b_RHY2 * dfz + b_RHY1;\r\n  phi_t = b_REY2 * dfz + b_REY1;\r\n  jb_idx_0 = phi_t;\r\n  if (phi_t > 1.0) {\r\n    jb_idx_0 = 1.0;\r\n  }\r\n\r\n  phi_t = (lam_mux_star_tmp * b_RBY4 + b_RBY1) * cos(atan((*alpha - b_RBY3) *\r\n    b_RBY2)) * scaleFactors[19];\r\n  lb_idx_0 = phi_t;\r\n  if (phi_t < 0.0) {\r\n    lb_idx_0 = 0.0;\r\n  }\r\n\r\n  c_u = *kappa + SHykappa;\r\n  for (i = 0; i < 9; i++) {\r\n    zeta[i] = 1.0;\r\n  }\r\n\r\n  trueCount = 0;\r\n  if (turnslipinds) {\r\n    for (i = 0; i < 1; i++) {\r\n      trueCount++;\r\n    }\r\n  }\r\n\r\n  nb_tmp_size[0] = 1;\r\n  nb_tmp_size[1] = trueCount;\r\n  tmp = nb_tmp_size[1];\r\n  if (tmp - 1 >= 0) {\r\n    zeta[0] = 0.0;\r\n  }\r\n\r\n  tmp_2 = !isLowSpeed;\r\n  if (tmp_2) {\r\n    trueCount = 0;\r\n    if (turnslipinds) {\r\n      for (i = 0; i < 1; i++) {\r\n        trueCount++;\r\n      }\r\n    }\r\n\r\n    ob_size_idx_0 = trueCount;\r\n    ib_tmp[0] = 1;\r\n    ib_tmp[1] = tmp;\r\n    tmpDrphiVar_size[0] = 1;\r\n    tmpDrphiVar_size[1] = ib_tmp[1];\r\n    SHy = atan(b_PDXP3 * *kappa);\r\n    SHy = cos(SHy);\r\n    loop_ub = ib_tmp[1];\r\n    if (loop_ub - 1 >= 0) {\r\n      tmpDrphiVar_data = (b_PDXP2 * dfz + 1.0) * b_PDXP1 * SHy *\r\n        b_UNLOADED_RADIUS * phi;\r\n    }\r\n\r\n    main_atan(&tmpDrphiVar_data, tmpDrphiVar_size);\r\n    main_cos(&tmpDrphiVar_data, tmpDrphiVar_size);\r\n    i = ob_size_idx_0;\r\n    if (i - 1 >= 0) {\r\n      zeta[1] = tmpDrphiVar_data;\r\n    }\r\n\r\n    trueCount = 0;\r\n    if (turnslipinds) {\r\n      for (i = 0; i < 1; i++) {\r\n        trueCount++;\r\n      }\r\n    }\r\n\r\n    ob_size_idx_0 = trueCount;\r\n    phi_size[0] = 1;\r\n    phi_size[1] = ib_tmp[1];\r\n    loop_ub = ib_tmp[1];\r\n    if (loop_ub - 1 >= 0) {\r\n      phi_data = phi;\r\n    }\r\n\r\n    main_abs(&phi_data, phi_size, &tmp_data_0, tmp_size);\r\n    tmpDrphiVar_size[0] = 1;\r\n    loop_ub = tmp_size[1];\r\n    tmpDrphiVar_size[1] = loop_ub;\r\n    if (loop_ub - 1 >= 0) {\r\n      tmpDrphiVar_data = b_UNLOADED_RADIUS * tmp_data_0;\r\n    }\r\n\r\n    main_sqrt(&tmpDrphiVar_data, tmpDrphiVar_size);\r\n    trueCount = 0;\r\n    if (turnslipinds) {\r\n      for (i = 0; i < 1; i++) {\r\n        trueCount++;\r\n      }\r\n    }\r\n\r\n    phi_size[0] = 1;\r\n    phi_size[1] = trueCount;\r\n    phi_size_0[0] = 1;\r\n    phi_size_0[1] = trueCount;\r\n    if (trueCount - 1 >= 0) {\r\n      phi_data = phi;\r\n      phi_data_0 = phi;\r\n    }\r\n\r\n    main_abs(&phi_data, phi_size, &tmp_data_0, tmp_size);\r\n    main_abs(&phi_data_0, phi_size_0, &phi_data, phi_size);\r\n    if (phi_size[1] == 1) {\r\n      i = tmpDrphiVar_size[1];\r\n    } else {\r\n      i = phi_size[1];\r\n    }\r\n\r\n    if ((tmp_size[1] == tmpDrphiVar_size[1]) && (i == ib_tmp[1])) {\r\n      SHy = atan(b_PDYP3 * Kyalpha);\r\n      SHy = cos(SHy);\r\n      phi_size[0] = 1;\r\n      phi_size[1] = trueCount;\r\n      if (trueCount - 1 >= 0) {\r\n        phi_data = phi;\r\n      }\r\n\r\n      main_abs(&phi_data, phi_size, &tmp_data_0, tmp_size);\r\n      loop_ub = ib_tmp[1] - 1;\r\n      tmpDrphiVar_size[0] = 1;\r\n      tmpDrphiVar_size[1] = ib_tmp[1];\r\n      for (i = 0; i <= loop_ub; i++) {\r\n        tmpDrphiVar_data = (b_PDYP2 * dfz + 1.0) * b_PDYP1 * SHy *\r\n          (b_UNLOADED_RADIUS * tmp_data_0 + b_PDYP4 * tmpDrphiVar_data);\r\n      }\r\n    } else {\r\n      main_binary_expand_op_3(&tmpDrphiVar_data, tmpDrphiVar_size, b_PDYP1,\r\n        b_PDYP2, dfz, b_PDYP3, Kyalpha, ib_tmp, b_UNLOADED_RADIUS, phi,\r\n        trueCount, b_PDYP4);\r\n    }\r\n\r\n    main_atan(&tmpDrphiVar_data, tmpDrphiVar_size);\r\n    main_cos(&tmpDrphiVar_data, tmpDrphiVar_size);\r\n    i = ob_size_idx_0;\r\n    if (i - 1 >= 0) {\r\n      zeta[2] = tmpDrphiVar_data;\r\n    }\r\n\r\n    trueCount = 0;\r\n    if (turnslipinds) {\r\n      for (i = 0; i < 1; i++) {\r\n        trueCount++;\r\n      }\r\n    }\r\n\r\n    ob_size_idx_0 = trueCount;\r\n    Kyalpha = b_UNLOADED_RADIUS * b_UNLOADED_RADIUS;\r\n    tmpDrphiVar_size[0] = 1;\r\n    tmpDrphiVar_size[1] = ib_tmp[1];\r\n    Kyalpha *= b_PKYP1;\r\n    loop_ub = ib_tmp[0] * ib_tmp[1];\r\n    if (loop_ub - 1 >= 0) {\r\n      phi_t = phi * phi;\r\n      tmpDrphiVar_data = Kyalpha * phi_t;\r\n    }\r\n\r\n    main_atan(&tmpDrphiVar_data, tmpDrphiVar_size);\r\n    main_cos(&tmpDrphiVar_data, tmpDrphiVar_size);\r\n    i = ob_size_idx_0;\r\n    if (i - 1 >= 0) {\r\n      zeta[3] = tmpDrphiVar_data;\r\n    }\r\n  }\r\n\r\n  Kygammao = (b_PKY7 * dfz + b_PKY6) * *Fz * (b_PPY5 * dpi + 1.0) *\r\n    scaleFactors[14];\r\n  SVygamma_tmp = *Fz / Fzo_prime;\r\n  SVygamma = sin(atan(SVygamma_tmp / (lam_mux_star_tmp * b_PKY5 + b_PKY2) /\r\n                      (b_PPY2 * dpi + 1.0)) * b_PKY4);\r\n  phi_t = fabs(gamma_star);\r\n  Kyalpha_tmp = (b_PPY1 * dpi + 1.0) * (b_PKY1 * Fzo_prime);\r\n  Kyalpha = (1.0 - b_PKY3 * phi_t) * Kyalpha_tmp * SVygamma * zeta[3] *\r\n    scaleFactors[5];\r\n  main_div0protect_kw(Kyalpha, &Vc, &SHy);\r\n  main_div0protect_kw(Kyalpha_tmp * (1.0 - b_PKY3 * 0.0) * SVygamma * zeta[3] *\r\n                      scaleFactors[5], &SHy, &DHyphi);\r\n  pb_idx_0 = b_PHYP1;\r\n  if (b_PHYP1 < 0.0) {\r\n    pb_idx_0 = 0.0;\r\n  }\r\n\r\n  SVygamma = tanh(Vx);\r\n  DHyphi = (b_PHYP3 * dfz + b_PHYP2) * SVygamma;\r\n  rb_idx_0 = b_PHYP4;\r\n  if (b_PHYP4 > 1.0) {\r\n    rb_idx_0 = 1.0;\r\n  }\r\n\r\n  SHy = Kygammao / (1.0 - epsilon_gamma) / (pb_idx_0 * DHyphi * SHy);\r\n  Kyalpha_tmp = b_UNLOADED_RADIUS * phi;\r\n  SHy *= Kyalpha_tmp;\r\n  DHyphi = sin(atan(SHy - (SHy - atan(SHy)) * rb_idx_0) * pb_idx_0) * DHyphi *\r\n    SVygamma;\r\n  SVygamma = (b_PVY4 * dfz + b_PVY3) * *Fz * gamma_star * zeta[2] *\r\n    scaleFactors[14] * lam_muy_prime;\r\n  SHy = 0.0;\r\n  pb_idx_0 = lb_idx_0 * c_u;\r\n  SHykappa *= lb_idx_0;\r\n  SHykappa = cos(atan(pb_idx_0 - (pb_idx_0 - atan(pb_idx_0)) * jb_idx_0) *\r\n                 b_RCY1) / cos(atan(SHykappa - (SHykappa - atan(SHykappa)) *\r\n    jb_idx_0) * b_RCY1);\r\n  rb_idx_0 = SHykappa;\r\n  if (SHykappa < 0.0) {\r\n    rb_idx_0 = 0.0;\r\n  }\r\n\r\n  if (tmp_2) {\r\n    trueCount = 0;\r\n    if (turnslipinds) {\r\n      for (i = 0; i < 1; i++) {\r\n        trueCount++;\r\n      }\r\n    }\r\n\r\n    ib_tmp[0] = 1;\r\n    ib_tmp[1] = tmp;\r\n    if (trueCount - 1 >= 0) {\r\n      zeta[4] = (DHyphi + 1.0) - SVygamma / Vc;\r\n    }\r\n\r\n    tmpDrphiVar_size[0] = 1;\r\n    tmpDrphiVar_size[1] = ib_tmp[1];\r\n    loop_ub = ib_tmp[1];\r\n    if (loop_ub - 1 >= 0) {\r\n      tmpDrphiVar_data = b_QDTP1 * b_UNLOADED_RADIUS * phi;\r\n    }\r\n\r\n    main_atan(&tmpDrphiVar_data, tmpDrphiVar_size);\r\n    main_cos(&tmpDrphiVar_data, tmpDrphiVar_size);\r\n    if (trueCount - 1 >= 0) {\r\n      zeta[5] = tmpDrphiVar_data;\r\n    }\r\n\r\n    tmpDrphiVar_size[0] = 1;\r\n    tmpDrphiVar_size[1] = ib_tmp[1];\r\n    loop_ub = ib_tmp[1];\r\n    if (loop_ub - 1 >= 0) {\r\n      tmpDrphiVar_data = b_QBRP1 * b_UNLOADED_RADIUS * phi;\r\n    }\r\n\r\n    main_atan(&tmpDrphiVar_data, tmpDrphiVar_size);\r\n    main_cos(&tmpDrphiVar_data, tmpDrphiVar_size);\r\n    if (trueCount - 1 >= 0) {\r\n      zeta[6] = tmpDrphiVar_data;\r\n    }\r\n\r\n    SHy = b_QCRP1 * mu_y * b_UNLOADED_RADIUS * *Fz * sqrt(SVygamma_tmp) *\r\n      scaleFactors[26];\r\n    jb_idx_0 = SHy;\r\n    if (SHy < 0.0) {\r\n      jb_idx_0 = 1.0E-6;\r\n    }\r\n\r\n    SHykappa = b_QDRP1;\r\n    if (b_QDRP1 < 0.0) {\r\n      SHykappa = 0.0;\r\n    }\r\n\r\n    pb_idx_0 = b_QDRP2;\r\n    if (b_QDRP2 < 0.0) {\r\n      pb_idx_0 = 0.0;\r\n    }\r\n\r\n    SHy = jb_idx_0 / sin(1.5707963267948966 * SHykappa);\r\n    c_u = 1.0 - epsilon_gamma;\r\n    if (rtIsNaN(c_u)) {\r\n      c_u = (rtNaN);\r\n    } else if (c_u < 0.0) {\r\n      c_u = -1.0;\r\n    } else {\r\n      c_u = (c_u > 0.0);\r\n    }\r\n\r\n    epsilon_gamma = ((b_QDZ11 * dfz + b_QDZ10) * fabs(b_idx_0) + (b_QDZ9 * dfz +\r\n      b_QDZ8)) * (*Fz * b_UNLOADED_RADIUS) * scaleFactors[15] / (SHykappa * SHy *\r\n      (1.0 - epsilon_gamma) + 0.0001 * c_u);\r\n    phi = Kyalpha_tmp;\r\n    c_u = epsilon_gamma * phi;\r\n    epsilon_gamma = sin(atan(c_u - (c_u - atan(c_u)) * pb_idx_0) * SHykappa) *\r\n      SHy;\r\n    if (rtIsNaN(epsilon_gamma)) {\r\n      SHy = (rtNaN);\r\n    } else if (epsilon_gamma < 0.0) {\r\n      SHy = -1.0;\r\n    } else {\r\n      SHy = (epsilon_gamma > 0.0);\r\n    }\r\n\r\n    phi = SHy;\r\n    if (SHy == 0.0) {\r\n      phi = 1.0;\r\n    }\r\n\r\n    phi_size[0] = 1;\r\n    phi_size[1] = ib_tmp[1];\r\n    loop_ub = ib_tmp[1];\r\n    phi_size_0[0] = 1;\r\n    phi_size_0[1] = ib_tmp[1];\r\n    if (loop_ub - 1 >= 0) {\r\n      phi_data = epsilon_gamma;\r\n      phi_data_0 = epsilon_gamma;\r\n    }\r\n\r\n    main_abs(&phi_data, phi_size, &tmp_data_0, tmp_size);\r\n    main_abs(&phi_data_0, phi_size_0, &phi_data, phi_size);\r\n    if (phi_size[1] == 1) {\r\n      i = ib_tmp[1];\r\n    } else {\r\n      i = phi_size[1];\r\n    }\r\n\r\n    if ((tmp_size[1] == ib_tmp[1]) && (i == ib_tmp[1])) {\r\n      SHy = fabs(ib);\r\n      SHy = atan(b_QCRP2 * b_UNLOADED_RADIUS * SHy);\r\n      phi_size[0] = 1;\r\n      phi_size[1] = ib_tmp[1];\r\n      loop_ub = ib_tmp[1];\r\n      if (loop_ub - 1 >= 0) {\r\n        phi_data = epsilon_gamma;\r\n      }\r\n\r\n      main_abs(&phi_data, phi_size, &tmp_data_0, tmp_size);\r\n      tmpDrphiVar_size[0] = 1;\r\n      tmpDrphiVar_size[1] = ib_tmp[1];\r\n      loop_ub = ib_tmp[1];\r\n      if (loop_ub - 1 >= 0) {\r\n        tmpDrphiVar_data = jb_idx_0 * 2.0 / 3.1415926535897931 * SHy * rb_idx_0 /\r\n          (0.0001 * phi + tmp_data_0);\r\n      }\r\n    } else {\r\n      main_binary_expand_op_2(&tmpDrphiVar_data, tmpDrphiVar_size, &jb_idx_0,\r\n        b_QCRP2, b_UNLOADED_RADIUS, &ib, &rb_idx_0, ib_tmp, epsilon_gamma, &phi);\r\n    }\r\n\r\n    loop_ub = tmpDrphiVar_size[1];\r\n    for (i = 0; i < loop_ub; i++) {\r\n      if (tmpDrphiVar_data > 1.0) {\r\n        tmpDrphiVar_data = 1.0;\r\n      }\r\n    }\r\n\r\n    for (i = 0; i < loop_ub; i++) {\r\n      if (tmpDrphiVar_data < -1.0) {\r\n        tmpDrphiVar_data = -1.0;\r\n      }\r\n    }\r\n\r\n    main_acos(&tmpDrphiVar_data, tmpDrphiVar_size);\r\n    if (trueCount - 1 >= 0) {\r\n      zeta[7] = 0.63661977236758138 * tmpDrphiVar_data;\r\n      zeta[8] = epsilon_gamma + 1.0;\r\n    }\r\n\r\n    SHy = 0.0;\r\n    if (tmp - 1 >= 0) {\r\n      tmp_data = 0;\r\n    }\r\n\r\n    trueCount = 0;\r\n    if (turnslipinds) {\r\n      for (i = 0; i < 1; i++) {\r\n        trueCount++;\r\n      }\r\n    }\r\n\r\n    if (ib_tmp[1] == 1) {\r\n      i = tmp;\r\n      loop_ub = tmp;\r\n    } else {\r\n      i = ib_tmp[1];\r\n      loop_ub = ib_tmp[1];\r\n    }\r\n\r\n    if (loop_ub == 1) {\r\n      loop_ub = ib_tmp[1];\r\n    } else if (ib_tmp[1] == 1) {\r\n      loop_ub = tmp;\r\n    } else {\r\n      loop_ub = ib_tmp[1];\r\n    }\r\n\r\n    if ((ib_tmp[1] == tmp) && (i == ib_tmp[1]) && (loop_ub == trueCount)) {\r\n      loop_ub = ib_tmp[0] * ib_tmp[1];\r\n      if (loop_ub - 1 >= 0) {\r\n        SHy = ((b_PHY2 * dfz + b_PHY1) * scaleFactors[11] + DHyphi) - SVygamma /\r\n          Vc;\r\n      }\r\n    } else {\r\n      main_binary_expand_op_1(&SHy, b_PHY1, b_PHY2, dfz, ib_tmp, scaleFactors,\r\n        nb_tmp_size, DHyphi, SVygamma, trueCount, Vc);\r\n    }\r\n  }\r\n\r\n  epsilon_gamma = b_PCX1 * scaleFactors[6];\r\n  Kyalpha_tmp = epsilon_gamma;\r\n  if (epsilon_gamma < 0.0) {\r\n    Kyalpha_tmp = 0.0;\r\n  }\r\n\r\n  c_u = b_idx_0 * b_idx_0;\r\n  epsilon_gamma = ((b_PPX3 * dpi + 1.0) + mu_y_tmp * b_PPX4) * (b_PDX2 * dfz +\r\n    b_PDX1) * (1.0 - c_u * b_PDX3) * lam_mux_star * *Fz * zeta[1];\r\n  jb_idx_0 = epsilon_gamma;\r\n  if (epsilon_gamma < 0.0) {\r\n    jb_idx_0 = 0.0;\r\n  }\r\n\r\n  DHyphi = dfz * dfz;\r\n  epsilon_gamma = ((b_PEX2 * dfz + b_PEX1) + DHyphi * b_PEX3) * (1.0 - tanh(10.0\r\n    * kappa_x) * b_PEX4) * scaleFactors[8];\r\n  lb_idx_0 = epsilon_gamma;\r\n  if (epsilon_gamma > 1.0) {\r\n    lb_idx_0 = 1.0;\r\n  }\r\n\r\n  epsilon_gamma = (b_PKX2 * dfz + b_PKX1) * *Fz * exp(b_PKX3 * dfz) * ((b_PPX1 *\r\n    dpi + 1.0) + mu_y_tmp * b_PPX2) * scaleFactors[4];\r\n  main_div0protect_kw(Kyalpha_tmp * jb_idx_0, &phi, &SHykappa);\r\n  phi = epsilon_gamma / phi;\r\n  SHykappa = b_REX2 * dfz + b_REX1;\r\n  mu_y_tmp = SHykappa;\r\n  if (SHykappa > 1.0) {\r\n    mu_y_tmp = 1.0;\r\n  }\r\n\r\n  SHykappa = (lam_mux_star_tmp * b_RBX3 + b_RBX1) * cos(atan(b_RBX2 * *kappa)) *\r\n    scaleFactors[18];\r\n  SVygamma_tmp = SHykappa;\r\n  if (SHykappa < 0.0) {\r\n    SVygamma_tmp = 0.0;\r\n  }\r\n\r\n  SHykappa = *alpha + b_RHX1;\r\n  pb_idx_0 = SVygamma_tmp * SHykappa;\r\n  SHykappa = SVygamma_tmp * b_RHX1;\r\n  SHykappa = cos(atan(pb_idx_0 - (pb_idx_0 - atan(pb_idx_0)) * mu_y_tmp) *\r\n                 b_RCX1) / cos(atan(SHykappa - (SHykappa - atan(SHykappa)) *\r\n    mu_y_tmp) * b_RCX1);\r\n  if (SHykappa < 0.0) {\r\n    SHykappa = 0.0;\r\n  }\r\n\r\n  kappa_x *= phi;\r\n  *Fx = ((b_PVX2 * dfz + b_PVX1) * *Fz * (lam_mux_star * 10.0 / (9.0 *\r\n           lam_mux_star + 1.0)) * scaleFactors[12] * zeta[1] + sin(atan(kappa_x\r\n           - (kappa_x - atan(kappa_x)) * lb_idx_0) * Kyalpha_tmp) * jb_idx_0) *\r\n    SHykappa;\r\n  kappa_x = b_PCY1 * scaleFactors[7];\r\n  mu_y_tmp = kappa_x;\r\n  if (kappa_x < 0.0) {\r\n    mu_y_tmp = 0.0;\r\n  }\r\n\r\n  mu_y *= *Fz;\r\n  phi = mu_y * zeta[2];\r\n  main_div0protect_kw(mu_y_tmp * phi, &kappa_x, &lam_mux_star);\r\n  kappa_x = Kyalpha / kappa_x;\r\n  if (isLowSpeed) {\r\n    trueCount = 0;\r\n    if (isLowSpeed) {\r\n      for (i = 0; i < 1; i++) {\r\n        trueCount++;\r\n      }\r\n    }\r\n\r\n    vc_tmp_size[0] = 1;\r\n    vc_tmp_size[1] = trueCount;\r\n    nb_size[0] = 1;\r\n    loop_ub = vc_tmp_size[1];\r\n    nb_size[1] = loop_ub;\r\n    if (loop_ub - 1 >= 0) {\r\n      nb_data = 0;\r\n    }\r\n\r\n    ib_tmp[0] = 1;\r\n    ib_tmp[1] = loop_ub;\r\n    if (ib_tmp[1] == 1) {\r\n      i = loop_ub;\r\n    } else {\r\n      i = ib_tmp[1];\r\n    }\r\n\r\n    if ((ib_tmp[1] == loop_ub) && (i == ib_tmp[1])) {\r\n      tmp = ib_tmp[1];\r\n      if ((tmp - 1 >= 0) && (loop_ub - 1 >= 0)) {\r\n        ib = (((Kygammao * gamma_star - SVygamma) / Vc * zeta[0] + (b_PHY2 * dfz\r\n                + b_PHY1) * scaleFactors[11]) + zeta[4]) - 1.0;\r\n      }\r\n\r\n      if (loop_ub - 1 >= 0) {\r\n        SHy = ib;\r\n      }\r\n    } else {\r\n      main_binary_expand_op(&SHy, nb_size, b_PHY1, b_PHY2, dfz, ib_tmp,\r\n                            scaleFactors, vc_tmp_size, Kygammao, gamma_star,\r\n                            SVygamma, Vc, zeta);\r\n    }\r\n  }\r\n\r\n  lam_mux_star = (b_PVY2 * dfz + b_PVY1) * *Fz * scaleFactors[13] *\r\n    lam_muy_prime * zeta[2] + SVygamma;\r\n  lam_muy_prime = *alpha + SHy;\r\n  if (rtIsNaN(lam_muy_prime)) {\r\n    Kygammao = (rtNaN);\r\n  } else if (lam_muy_prime < 0.0) {\r\n    Kygammao = -1.0;\r\n  } else {\r\n    Kygammao = (lam_muy_prime > 0.0);\r\n  }\r\n\r\n  if (Kygammao == 0.0) {\r\n    Kygammao = 1.0;\r\n  }\r\n\r\n  Kygammao = ((lam_mux_star_tmp * b_PEY5 + 1.0) - (b_PEY4 * gamma_star + b_PEY3)\r\n              * Kygammao) * (b_PEY2 * dfz + b_PEY1) * scaleFactors[9];\r\n  if (Kygammao > 1.0) {\r\n    Kygammao = 1.0;\r\n  }\r\n\r\n  mu_y = ((b_RVY2 * dfz + b_RVY1) + b_RVY3 * gamma_star) * mu_y * cos(atan\r\n    (b_RVY4 * *alpha)) * zeta[2] * sin(atan(b_RVY6 * *kappa) * b_RVY5) *\r\n    scaleFactors[20];\r\n  lam_muy_prime *= kappa_x;\r\n  *Fy = (sin(atan(lam_muy_prime - (lam_muy_prime - atan(lam_muy_prime)) *\r\n                  Kygammao) * mu_y_tmp) * phi + lam_mux_star) * rb_idx_0 + mu_y;\r\n  lam_muy_prime = Vx / b_LONGVL;\r\n  *My = ((((*Fx / b_FNOMIN * b_QSY2 + b_QSY1) + fabs(lam_muy_prime) * b_QSY3) +\r\n          rt_powd_snf(lam_muy_prime, 4.0) * b_QSY4) + (Re_tmp * b_QSY6 + b_QSY5)\r\n         * b_idx_0 * b_idx_0) * (-b_UNLOADED_RADIUS * b_FNOMIN * scaleFactors[25])\r\n    * (rt_powd_snf(fmax(f_idx_0 / b_NOMPRES, 0.05), b_QSY8) * rt_powd_snf(fmax\r\n        (Re_tmp, 0.05), b_QSY7)) * tanh(10.0 * omega);\r\n  lam_muy_prime = b_QSX6 * *Fz / b_FNOMIN;\r\n  Kygammao = fabs(b_idx_0);\r\n  Re_tmp = b_UNLOADED_RADIUS * *Fz;\r\n  *Mx = (((((b_QSX1 * scaleFactors[24] - (b_PPMX1 * dpi + 1.0) * (b_QSX2 *\r\n              b_idx_0)) - b_QSX12 * b_idx_0 * Kygammao) + b_QSX3 * *Fy /\r\n           b_FNOMIN) + sin(atan(b_QSX9 * *Fy / b_FNOMIN) * b_QSX8 + b_QSX7 *\r\n           b_idx_0) * (cos(atan(lam_muy_prime * lam_muy_prime) * b_QSX5) *\r\n                       b_QSX4)) + atan(b_QSX11 * *Fz / b_FNOMIN) * b_QSX10 *\r\n         b_idx_0) * (Re_tmp * scaleFactors[23]) + b_UNLOADED_RADIUS * *Fy *\r\n    scaleFactors[23] * (b_QSX14 * Kygammao + b_QSX13);\r\n  Vsy = Vx / Vsy;\r\n  lam_muy_prime = ((b_QHZ4 * dfz + b_QHZ3) * gamma_star + (b_QHZ2 * dfz + b_QHZ1))\r\n    + *alpha;\r\n  lam_mux_star = (lam_mux_star / Vc + SHy) + *alpha;\r\n  Kygammao = (((b_QBZ4 * b_idx_0 + 1.0) + b_QBZ5 * Kygammao) + lam_mux_star_tmp *\r\n              b_QBZ6) * ((b_QBZ2 * dfz + b_QBZ1) + DHyphi * b_QBZ3) *\r\n    scaleFactors[5] / Vs;\r\n  f_idx_0 = Kygammao;\r\n  if (Kygammao < 0.0) {\r\n    f_idx_0 = 0.0;\r\n  }\r\n\r\n  phi = b_QCZ1;\r\n  if (b_QCZ1 < 0.0) {\r\n    phi = 0.0;\r\n  }\r\n\r\n  Kygammao = ((b_QEZ5 * gamma_star + b_QEZ4) * 2.0 / 3.1415926535897931 * atan\r\n              (f_idx_0 * phi * lam_muy_prime) + 1.0) * ((b_QEZ2 * dfz + b_QEZ1)\r\n    + DHyphi * b_QEZ3);\r\n  SVygamma = Kygammao;\r\n  if (Kygammao > 1.0) {\r\n    SVygamma = 1.0;\r\n  }\r\n\r\n  kappa_x = (b_QBZ9 * scaleFactors[5] / Vs + b_QBZ10 * kappa_x * mu_y_tmp) *\r\n    zeta[6];\r\n  Kygammao = tan(lam_mux_star);\r\n  SHy = epsilon_gamma / Vc;\r\n  lam_mux_star_tmp = SHy * SHy * (*kappa * *kappa);\r\n  lam_mux_star = atan(sqrt(Kygammao * Kygammao + lam_mux_star_tmp)) * tanh\r\n    (1000.0 * lam_mux_star);\r\n  Kygammao = tan(lam_muy_prime);\r\n  Vc = atan(sqrt(Kygammao * Kygammao + lam_mux_star_tmp)) * tanh(1000.0 *\r\n    lam_muy_prime);\r\n  kappa_x *= lam_mux_star;\r\n  Vc *= f_idx_0;\r\n  *Mz = ((((((b_QDZ9 * dfz + b_QDZ8) * (b_PPZ2 * dpi + 1.0) + (b_QDZ11 * dfz +\r\n              b_QDZ10) * phi_t) * gamma_star * scaleFactors[15] * zeta[0] +\r\n            (b_QDZ7 * dfz + b_QDZ6) * scaleFactors[17] * zeta[2]) * Re_tmp * Vs *\r\n           tanh(10.0 * Vx) * Vsy + zeta[8]) - 1.0) * cos(atan(kappa_x - (kappa_x\r\n            - atan(kappa_x)) * 0.0) * zeta[7]) + -((b_QDZ2 * dfz + b_QDZ1) *\r\n          (1.0 - b_PPZ1 * dpi) * ((b_QDZ3 * b_idx_0 + 1.0) + c_u * b_QDZ4) * *Fz\r\n          * (b_UNLOADED_RADIUS / Fzo_prime) * scaleFactors[16] * zeta[5] * cos\r\n          (atan(Vc - (Vc - atan(Vc)) * SVygamma) * phi) * Vsy * n_idx_0) * (*Fy\r\n          - mu_y)) + ((b_SSZ2 * *Fy / b_FNOMIN + b_SSZ1) + (b_SSZ4 * dfz +\r\n    b_SSZ3) * gamma_star) * b_UNLOADED_RADIUS * scaleFactors[21] * *Fx;\r\n  if (vertType == 1.0) {\r\n    *RL = main_solveRLwithFz(b_LONGVL, b_UNLOADED_RADIUS, b_ASPECT_RATIO,\r\n      b_WIDTH, b_Q_RE0, b_Q_V1, b_FNOMIN, b_VERTICAL_STIFFNESS, b_RIM_RADIUS,\r\n      b_BOTTOM_STIFF, b_BOTTOM_OFFST, b_Q_V2, b_Q_FZ1, b_Q_FZ2, b_Q_FCX, b_Q_FCY,\r\n      b_PFZ1, b_Q_FCY2, b_Q_CAM1, b_Q_CAM2, b_Q_CAM3, b_Q_FYS1, b_Q_FYS2,\r\n      b_Q_FYS3, dpi, omega, b_idx_0, *Fx, *Fy, *Fz);\r\n    main_calculateFz(*RL, b_LONGVL, b_UNLOADED_RADIUS, b_ASPECT_RATIO, b_WIDTH,\r\n                     b_Q_RE0, b_Q_V1, b_FNOMIN, b_VERTICAL_STIFFNESS,\r\n                     b_RIM_RADIUS, b_BOTTOM_STIFF, b_BOTTOM_OFFST, b_Q_V2,\r\n                     b_Q_FZ1, b_Q_FZ2, b_Q_FCX, b_Q_FCY, b_PFZ1, b_Q_FCY2,\r\n                     b_Q_CAM1, b_Q_CAM2, b_Q_CAM3, b_Q_FYS1, b_Q_FYS2, b_Q_FYS3,\r\n                     dpi, omega, b_idx_0, *Fx, *Fy, &Fzo_prime, rhoz);\r\n  }\r\n\r\n  Cz *= b_UNLOADED_RADIUS;\r\n  Fzo_prime = *Fz / Cz;\r\n  if ((Cz == 0.0) || (Fzo_prime < 0.0)) {\r\n    Fzo_prime = 0.0;\r\n  }\r\n\r\n  tmp_0 = _mm_mul_pd(_mm_add_pd(_mm_mul_pd(_mm_set_pd(b_Q_RB2, b_Q_RA2),\r\n    _mm_set1_pd(Fzo_prime)), _mm_mul_pd(_mm_set_pd(b_Q_RB1, b_Q_RA1), _mm_set_pd\r\n    (rt_powd_snf(Fzo_prime, 0.33333333333333331), sqrt(Fzo_prime)))), _mm_set_pd\r\n                     (b_WIDTH, b_UNLOADED_RADIUS));\r\n  _mm_storeu_pd(&tmp_1[0], tmp_0);\r\n  *patch_a = tmp_1[0];\r\n  *patch_b = tmp_1[1];\r\n  if (*patch_a < 0.0) {\r\n    *patch_a = 0.0;\r\n  }\r\n\r\n  if (*patch_b < 0.0) {\r\n    *patch_b = 0.0;\r\n  }\r\n\r\n  *sig_x = fabs(epsilon_gamma / (((b_PCFX1 * dfz + 1.0) + DHyphi * b_PCFX2) *\r\n    b_LONGITUDINAL_STIFFNESS * (b_PCFX3 * dpi + 1.0)));\r\n  *sig_y = fabs(Kyalpha / (((b_PCFY1 * dfz + 1.0) + DHyphi * b_PCFY2) *\r\n    b_LATERAL_STIFFNESS * (b_PCFY3 * dpi + 1.0)));\r\n  *Tw = *Fx * *RL - *My;\r\n}\r\n\r\n/* System initialize for root system: '<Root>' */\r\nvoid MdlInitialize(void)\r\n{\r\n  /* InitializeConditions for Integrator: '<S4>/Integrator' */\r\n  rtX.Integrator_CSTATE = rtP.Integrator_IC;\r\n\r\n  /* InitializeConditions for Integrator: '<S5>/Integrator' */\r\n  rtX.Integrator_CSTATE_a = rtP.Integrator_IC_e;\r\n\r\n  /* InitializeConditions for Integrator: '<S7>/Integrator' */\r\n  rtX.Integrator_CSTATE_h = rtP.Integrator_IC_j;\r\n\r\n  /* InitializeConditions for Integrator: '<S8>/Integrator' */\r\n  rtX.Integrator_CSTATE_e = rtP.Integrator_IC_i;\r\n}\r\n\r\n/* Start for root system: '<Root>' */\r\nvoid MdlStart(void)\r\n{\r\n  MdlInitialize();\r\n}\r\n\r\n/* Outputs for root system: '<Root>' */\r\nvoid MdlOutputs(int_T tid)\r\n{\r\n  __m128d tmp_1;\r\n  real_T zeta[9];\r\n  real_T tmp_2[2];\r\n  real_T Alpha;\r\n  real_T Cz;\r\n  real_T DHyphi;\r\n  real_T FzTire;\r\n  real_T Fzo_prime;\r\n  real_T Kappa;\r\n  real_T Kyalpha;\r\n  real_T Kyalpha_tmp;\r\n  real_T Kygammao;\r\n  real_T RL;\r\n  real_T RadialDeflct;\r\n  real_T Re;\r\n  real_T Re_tmp;\r\n  real_T SHy;\r\n  real_T SHykappa;\r\n  real_T SVygamma;\r\n  real_T SVygamma_tmp;\r\n  real_T Vc;\r\n  real_T Vs;\r\n  real_T Vsy;\r\n  real_T c;\r\n  real_T c_u;\r\n  real_T dfz;\r\n  real_T dpi;\r\n  real_T e_idx_0;\r\n  real_T epsilon_gamma;\r\n  real_T g_idx_0;\r\n  real_T gamma_star;\r\n  real_T jb;\r\n  real_T kappa_x;\r\n  real_T kb_idx_0;\r\n  real_T lam_mux_star;\r\n  real_T lam_muy_prime;\r\n  real_T mb_idx_0;\r\n  real_T mu_y;\r\n  real_T mu_y_tmp;\r\n  real_T mu_y_tmp_0;\r\n  real_T phi;\r\n  real_T phi_data;\r\n  real_T phi_data_0;\r\n  real_T phi_t;\r\n  real_T qb_idx_0;\r\n  real_T sb_idx_0;\r\n  real_T tmpDrphiVar_data;\r\n  int32_T jb_tmp[2];\r\n  int32_T ob_size[2];\r\n  int32_T ob_tmp_size[2];\r\n  int32_T phi_size[2];\r\n  int32_T phi_size_0[2];\r\n  int32_T tmpDrphiVar_size[2];\r\n  int32_T tmp_size[2];\r\n  int32_T wc_tmp_size[2];\r\n  int32_T i;\r\n  int32_T pb_size_idx_0;\r\n  int32_T tmp_0;\r\n  int32_T tmp_data;\r\n  int32_T trueCount;\r\n  int8_T ob_data;\r\n  boolean_T isLowSpeed;\r\n  boolean_T tmp;\r\n  boolean_T tmp_3;\r\n  boolean_T turnslipinds;\r\n\r\n  /* Integrator: '<S4>/Integrator' */\r\n  rtB.Integrator = rtX.Integrator_CSTATE;\r\n\r\n  /* Integrator: '<S5>/Integrator' */\r\n  rtB.Integrator_f = rtX.Integrator_CSTATE_a;\r\n\r\n  /* Gain: '<S2>/Flip Tire1' */\r\n  rtB.FlipTire1 = rtP.FlipTire1_Gain * rtB.Integrator_f;\r\n  tmp = ssIsSampleHit(rtS, 1, 0);\r\n  if (tmp) {\r\n    /* Gain: '<S1>/Flip Tire' incorporates:\r\n     *  Constant: '<Root>/Constant2'\r\n     */\r\n    rtB.FlipTire = rtP.FlipTire_Gain * rtP.Constant2_Value;\r\n\r\n    /* Gain: '<S1>/Flip Tire1' incorporates:\r\n     *  Constant: '<Root>/Constant3'\r\n     */\r\n    rtB.FlipTire1_n = rtP.FlipTire1_Gain_g * rtP.Constant3_Value;\r\n\r\n    /* Gain: '<S3>/Gain' incorporates:\r\n     *  Constant: '<Root>/Constant'\r\n     */\r\n    rtB.Gain = rtP.Gain_Gain * rtP.Constant_Value;\r\n\r\n    /* Sum: '<S3>/Sum2' incorporates:\r\n     *  Constant: '<S1>/RadialDeflctConstant'\r\n     */\r\n    rtB.Sum2 = rtP.RadialDeflctConstant_Value + rtB.Gain;\r\n\r\n    /* Sum: '<S3>/Sum1' incorporates:\r\n     *  Constant: '<Root>/Constant5'\r\n     */\r\n    rtB.Sum1 = rtB.Gain + rtP.Constant5_Value;\r\n  }\r\n\r\n  /* SignalConversion generated from: '<S6>/ SFunction ' incorporates:\r\n   *  MATLAB Function: '<S3>/Magic Tire Const Input'\r\n   */\r\n  memset(&rtB.TmpSignalConversionAtSFunctionI[0], 0, 27U * sizeof(real_T));\r\n\r\n  /* MATLAB Function: '<S3>/Magic Tire Const Input' incorporates:\r\n   *  Constant: '<Root>/Constant'\r\n   *  Constant: '<Root>/Constant1'\r\n   *  Constant: '<Root>/Constant4'\r\n   *  Constant: '<Root>/Constant7'\r\n   *  Constant: '<S1>/vertType'\r\n   *  SignalConversion generated from: '<S6>/ SFunction '\r\n   */\r\n  RadialDeflct = rtB.Sum2;\r\n\r\n  /* :  [Fx,Fy,FzTire,Mx,My,Mz,Re,Kappa,Alpha,sig_x,sig_y,a,b,RL,RadialDeflct,Tw] = vdyncsmtire(Omega,Vx,Vy,psidot,Gamma,TirePrs,ScaleFactors,rhoz,plySteer,turnslip,... */\r\n  /* :      PRESMAX,... */\r\n  /* :      PRESMIN,... */\r\n  /* :      FZMAX,... */\r\n  /* :      FZMIN,... */\r\n  /* :      VXLOW,... */\r\n  /* :      KPUMAX,... */\r\n  /* :      KPUMIN,... */\r\n  /* :      ALPMAX,... */\r\n  /* :      ALPMIN,... */\r\n  /* :      CAMMIN,... */\r\n  /* :      CAMMAX,... */\r\n  /* :      LONGVL,... */\r\n  /* :      UNLOADED_RADIUS,... */\r\n  /* :      RIM_RADIUS,... */\r\n  /* :      NOMPRES,... */\r\n  /* :      FNOMIN,... */\r\n  /* :      VERTICAL_STIFFNESS,...% vertical */\r\n  /* :      DREFF,... */\r\n  /* :      BREFF,... */\r\n  /* :      FREFF,... */\r\n  /* :      Q_RE0,... */\r\n  /* :      Q_V1,... */\r\n  /* :      Q_V2,... */\r\n  /* :      Q_FZ1,... */\r\n  /* :      Q_FZ2,... */\r\n  /* :      Q_FCX,... */\r\n  /* :      Q_FCY,... */\r\n  /* :      PFZ1,... */\r\n  /* :      Q_FCY2,... */\r\n  /* :      BOTTOM_OFFST,... */\r\n  /* :      BOTTOM_STIFF,... */\r\n  /* :      PCX1,...% longitudinal */\r\n  /* :      PDX1,... */\r\n  /* :      PDX2,... */\r\n  /* :      PDX3,... */\r\n  /* :      PEX1,... */\r\n  /* :      PEX2,... */\r\n  /* :      PEX3,... */\r\n  /* :      PEX4,... */\r\n  /* :      PKX1,... */\r\n  /* :      PKX2,... */\r\n  /* :      PKX3,... */\r\n  /* :      PHX1,... */\r\n  /* :      PHX2,... */\r\n  /* :      PVX1,... */\r\n  /* :      PVX2,... */\r\n  /* :      PPX1,... */\r\n  /* :      PPX2,... */\r\n  /* :      PPX3,... */\r\n  /* :      PPX4,... */\r\n  /* :      RBX1,... */\r\n  /* :      RBX2,... */\r\n  /* :      RBX3,... */\r\n  /* :      RCX1,... */\r\n  /* :      REX1,... */\r\n  /* :      REX2,... */\r\n  /* :      RHX1,... */\r\n  /* :      QSX1,...% overturning */\r\n  /* :      QSX2,... */\r\n  /* :      QSX3,... */\r\n  /* :      QSX4,... */\r\n  /* :      QSX5,... */\r\n  /* :      QSX6,... */\r\n  /* :      QSX7,... */\r\n  /* :      QSX8,... */\r\n  /* :      QSX9,... */\r\n  /* :      QSX10,... */\r\n  /* :      QSX11,... */\r\n  /* :      PPMX1,... */\r\n  /* :      PCY1,...% lateral */\r\n  /* :      PDY1,... */\r\n  /* :      PDY2,... */\r\n  /* :      PDY3,... */\r\n  /* :      PEY1,... */\r\n  /* :      PEY2,... */\r\n  /* :      PEY3,... */\r\n  /* :      PEY4,... */\r\n  /* :      PEY5,... */\r\n  /* :      PKY1,... */\r\n  /* :      PKY2,... */\r\n  /* :      PKY3,... */\r\n  /* :      PKY4,... */\r\n  /* :      PKY5,... */\r\n  /* :      PKY6,... */\r\n  /* :      PKY7,... */\r\n  /* :      PHY1,... */\r\n  /* :      PHY2,... */\r\n  /* :      PVY1,... */\r\n  /* :      PVY2,... */\r\n  /* :      PVY3,... */\r\n  /* :      PVY4,... */\r\n  /* :      PPY1,... */\r\n  /* :      PPY2,... */\r\n  /* :      PPY3,... */\r\n  /* :      PPY4,... */\r\n  /* :      PPY5,... */\r\n  /* :      RBY1,... */\r\n  /* :      RBY2,... */\r\n  /* :      RBY3,... */\r\n  /* :      RBY4,... */\r\n  /* :      RCY1,... */\r\n  /* :      REY1,... */\r\n  /* :      REY2,... */\r\n  /* :      RHY1,... */\r\n  /* :      RHY2,... */\r\n  /* :      RVY1,... */\r\n  /* :      RVY2,... */\r\n  /* :      RVY3,... */\r\n  /* :      RVY4,... */\r\n  /* :      RVY5,... */\r\n  /* :      RVY6,... */\r\n  /* :      QSY1,...% rolling */\r\n  /* :      QSY2,... */\r\n  /* :      QSY3,... */\r\n  /* :      QSY4,... */\r\n  /* :      QSY5,... */\r\n  /* :      QSY6,... */\r\n  /* :      QSY7,... */\r\n  /* :      QSY8,... */\r\n  /* :      QBZ1,... */\r\n  /* :      QBZ2,... */\r\n  /* :      QBZ3,... */\r\n  /* :      QBZ4,... */\r\n  /* :      QBZ5,... */\r\n  /* :      QBZ6,... */\r\n  /* :      QBZ9,... */\r\n  /* :      QBZ10,... */\r\n  /* :      QCZ1,... */\r\n  /* :      QDZ1,... */\r\n  /* :      QDZ2,... */\r\n  /* :      QDZ3,... */\r\n  /* :      QDZ4,... */\r\n  /* :      QDZ6,... */\r\n  /* :      QDZ7,... */\r\n  /* :      QDZ8,... */\r\n  /* :      QDZ9,... */\r\n  /* :      QDZ10,... */\r\n  /* :      QDZ11,... */\r\n  /* :      QEZ1,... */\r\n  /* :      QEZ2,... */\r\n  /* :      QEZ3,... */\r\n  /* :      QEZ4,... */\r\n  /* :      QEZ5,... */\r\n  /* :      QHZ1,... */\r\n  /* :      QHZ2,... */\r\n  /* :      QHZ3,... */\r\n  /* :      QHZ4,... */\r\n  /* :      PPZ1,... */\r\n  /* :      PPZ2,... */\r\n  /* :      SSZ1,... */\r\n  /* :      SSZ2,... */\r\n  /* :      SSZ3,... */\r\n  /* :      SSZ4,... */\r\n  /* :      PDXP1,...% turn slip */\r\n  /* :      PDXP2,... */\r\n  /* :      PDXP3,... */\r\n  /* :      PKYP1,... */\r\n  /* :      PDYP1,... */\r\n  /* :      PDYP2,... */\r\n  /* :      PDYP3,... */\r\n  /* :      PDYP4,... */\r\n  /* :      PHYP1,... */\r\n  /* :      PHYP2,... */\r\n  /* :      PHYP3,... */\r\n  /* :      PHYP4,... */\r\n  /* :      PECP1,... */\r\n  /* :      PECP2,... */\r\n  /* :      QDTP1,... */\r\n  /* :      QCRP1,...% aligning moment */\r\n  /* :      QCRP2,... */\r\n  /* :      QBRP1,... */\r\n  /* :      QDRP1,... */\r\n  /* :      QDRP2,... */\r\n  /* :      WIDTH,... */\r\n  /* :      Q_RA1,... % contact patch */\r\n  /* :      Q_RA2,... */\r\n  /* :      Q_RB1,... */\r\n  /* :      Q_RB2,... */\r\n  /* :      QSX12,... */\r\n  /* :      QSX13,... */\r\n  /* :      QSX14,... */\r\n  /* :      Q_FZ3,... */\r\n  /* :      LONGITUDINAL_STIFFNESS,...% structural */\r\n  /* :      LATERAL_STIFFNESS,... */\r\n  /* :      PCFX1,... */\r\n  /* :      PCFX2,... */\r\n  /* :      PCFX3,... */\r\n  /* :      PCFY1,... */\r\n  /* :      PCFY2,... */\r\n  /* :      PCFY3,... */\r\n  /* :      Fx_ext,... */\r\n  /* :      Fy_ext,... */\r\n  /* :      Fz_ext,... */\r\n  /* :      0,... */\r\n  /* :      vdynMF,... */\r\n  /* :      vertType,... */\r\n  /* :      2,... */\r\n  /* :      Q_CAM1, ... */\r\n  /* :      Q_CAM2, ... */\r\n  /* :      Q_CAM3,... */\r\n  /* :      Q_FYS1, ... */\r\n  /* :      Q_FYS2, ... */\r\n  /* :      Q_FYS3, ... */\r\n  /* :      ASPECT_RATIO); */\r\n  if (rtP.MagicTireConstInput_vdynMF[3] == 1.0) {\r\n    main_div0protect(rtP.Constant1_Value, rtP.CombinedSlipWheelCPI_VXLOW,\r\n                     &FzTire, &Vs);\r\n    c = rtB.FlipTire1_n;\r\n    if (rtB.FlipTire1_n < rtP.CombinedSlipWheelCPI_CAMMIN) {\r\n      c = rtP.CombinedSlipWheelCPI_CAMMIN;\r\n    }\r\n\r\n    e_idx_0 = c;\r\n    if (c > rtP.CombinedSlipWheelCPI_CAMMAX) {\r\n      e_idx_0 = rtP.CombinedSlipWheelCPI_CAMMAX;\r\n    }\r\n\r\n    g_idx_0 = rtP.Constant7_Value;\r\n    if (rtP.Constant7_Value < rtP.CombinedSlipWheelCPI_PRESMIN) {\r\n      g_idx_0 = rtP.CombinedSlipWheelCPI_PRESMIN;\r\n    }\r\n\r\n    if (g_idx_0 > rtP.CombinedSlipWheelCPI_PRESMAX) {\r\n      g_idx_0 = rtP.CombinedSlipWheelCPI_PRESMAX;\r\n    }\r\n\r\n    dpi = (g_idx_0 - rtP.CombinedSlipWheelCPI_NOMPRES) /\r\n      rtP.CombinedSlipWheelCPI_NOMPRES;\r\n    RL = rtP.CombinedSlipWheelCPI_UNLOADED_R * 0.95;\r\n    if (rtP.vertType_Value == 2.0) {\r\n      RL = main_solveRLwithRhoz(rtP.CombinedSlipWheelCPI_LONGVL,\r\n        rtP.CombinedSlipWheelCPI_UNLOADED_R, rtP.CombinedSlipWheelCPI_ASPECT_RAT,\r\n        rtP.CombinedSlipWheelCPI_WIDTH, rtP.CombinedSlipWheelCPI_Q_RE0,\r\n        rtP.CombinedSlipWheelCPI_Q_V1, rtP.CombinedSlipWheelCPI_FNOMIN,\r\n        rtP.CombinedSlipWheelCPI_VERTICAL_S, rtP.CombinedSlipWheelCPI_RIM_RADIUS,\r\n        rtP.CombinedSlipWheelCPI_BOTTOM_STI, rtP.CombinedSlipWheelCPI_BOTTOM_OFF,\r\n        rtP.CombinedSlipWheelCPI_Q_V2, rtP.CombinedSlipWheelCPI_Q_FZ1,\r\n        rtP.CombinedSlipWheelCPI_Q_FZ2, rtP.CombinedSlipWheelCPI_Q_FCX,\r\n        rtP.CombinedSlipWheelCPI_Q_FCY, rtP.CombinedSlipWheelCPI_PFZ1,\r\n        rtP.CombinedSlipWheelCPI_Q_FCY2, rtP.CombinedSlipWheelCPI_Q_CAM1,\r\n        rtP.CombinedSlipWheelCPI_Q_CAM2, rtP.CombinedSlipWheelCPI_Q_CAM3,\r\n        rtP.CombinedSlipWheelCPI_Q_FYS1, rtP.CombinedSlipWheelCPI_Q_FYS2,\r\n        rtP.CombinedSlipWheelCPI_Q_FYS3, dpi, rtP.Constant_Value, e_idx_0,\r\n        rtB.Integrator, rtB.Integrator_f, rtB.Sum2);\r\n      FzTire = main_calculateFz_m(RL, rtP.CombinedSlipWheelCPI_LONGVL,\r\n        rtP.CombinedSlipWheelCPI_UNLOADED_R, rtP.CombinedSlipWheelCPI_ASPECT_RAT,\r\n        rtP.CombinedSlipWheelCPI_WIDTH, rtP.CombinedSlipWheelCPI_Q_RE0,\r\n        rtP.CombinedSlipWheelCPI_Q_V1, rtP.CombinedSlipWheelCPI_FNOMIN,\r\n        rtP.CombinedSlipWheelCPI_VERTICAL_S, rtP.CombinedSlipWheelCPI_RIM_RADIUS,\r\n        rtP.CombinedSlipWheelCPI_BOTTOM_STI, rtP.CombinedSlipWheelCPI_BOTTOM_OFF,\r\n        rtP.CombinedSlipWheelCPI_Q_V2, rtP.CombinedSlipWheelCPI_Q_FZ1,\r\n        rtP.CombinedSlipWheelCPI_Q_FZ2, rtP.CombinedSlipWheelCPI_Q_FCX,\r\n        rtP.CombinedSlipWheelCPI_Q_FCY, rtP.CombinedSlipWheelCPI_PFZ1,\r\n        rtP.CombinedSlipWheelCPI_Q_FCY2, rtP.CombinedSlipWheelCPI_Q_CAM1,\r\n        rtP.CombinedSlipWheelCPI_Q_CAM2, rtP.CombinedSlipWheelCPI_Q_CAM3,\r\n        rtP.CombinedSlipWheelCPI_Q_FYS1, rtP.CombinedSlipWheelCPI_Q_FYS2,\r\n        rtP.CombinedSlipWheelCPI_Q_FYS3, dpi, rtP.Constant_Value, e_idx_0,\r\n        rtB.Integrator, rtB.Integrator_f);\r\n    } else {\r\n      FzTire = rtB.Sum1;\r\n    }\r\n\r\n    kappa_x = FzTire;\r\n    if (FzTire <= 0.0) {\r\n      kappa_x = 1.0;\r\n    }\r\n\r\n    if (FzTire < rtP.CombinedSlipWheelCPI_FZMIN) {\r\n      FzTire = rtP.CombinedSlipWheelCPI_FZMIN;\r\n    }\r\n\r\n    if (FzTire > rtP.CombinedSlipWheelCPI_FZMAX) {\r\n      FzTire = rtP.CombinedSlipWheelCPI_FZMAX;\r\n    }\r\n\r\n    Fzo_prime = 1.0 * rtP.CombinedSlipWheelCPI_FNOMIN;\r\n    dfz = (FzTire - Fzo_prime) / Fzo_prime;\r\n    epsilon_gamma = (rtP.CombinedSlipWheelCPI_PECP2 * dfz + 1.0) *\r\n      rtP.CombinedSlipWheelCPI_PECP1;\r\n    Cz = (rtP.CombinedSlipWheelCPI_PFZ1 * dpi + 1.0) *\r\n      (rtP.CombinedSlipWheelCPI_VERTICAL_S * 1.0);\r\n    Re = rtP.Constant_Value * rtP.CombinedSlipWheelCPI_UNLOADED_R /\r\n      rtP.CombinedSlipWheelCPI_LONGVL;\r\n    Re_tmp = kappa_x / rtP.CombinedSlipWheelCPI_FNOMIN;\r\n    Re = (Re * Re * rtP.CombinedSlipWheelCPI_Q_V1 +\r\n          rtP.CombinedSlipWheelCPI_Q_RE0) * rtP.CombinedSlipWheelCPI_UNLOADED_R\r\n      - (atan(Re_tmp * rtP.CombinedSlipWheelCPI_BREFF) *\r\n         rtP.CombinedSlipWheelCPI_DREFF + Re_tmp *\r\n         rtP.CombinedSlipWheelCPI_FREFF) * (rtP.CombinedSlipWheelCPI_FNOMIN / Cz);\r\n    if (Re < 0.001) {\r\n      Re = 0.001;\r\n    }\r\n\r\n    Kappa = (Re * rtP.Constant_Value - rtP.Constant1_Value) / Vs;\r\n    if (Kappa < rtP.CombinedSlipWheelCPI_KPUMIN) {\r\n      Kappa = rtP.CombinedSlipWheelCPI_KPUMIN;\r\n    }\r\n\r\n    if (Kappa > rtP.CombinedSlipWheelCPI_KPUMAX) {\r\n      Kappa = rtP.CombinedSlipWheelCPI_KPUMAX;\r\n    }\r\n\r\n    kappa_x = (rtP.CombinedSlipWheelCPI_PHX2 * dfz +\r\n               rtP.CombinedSlipWheelCPI_PHX1) * 0.0 + Kappa;\r\n    Alpha = rt_atan2d_snf(rtB.FlipTire, Vs);\r\n    if (Alpha < rtP.CombinedSlipWheelCPI_ALPMIN) {\r\n      Alpha = rtP.CombinedSlipWheelCPI_ALPMIN;\r\n    }\r\n\r\n    if (Alpha > rtP.CombinedSlipWheelCPI_ALPMAX) {\r\n      Alpha = rtP.CombinedSlipWheelCPI_ALPMAX;\r\n    }\r\n\r\n    gamma_star = sin(e_idx_0);\r\n    phi_t = -Vs * Kappa;\r\n    Kyalpha = tan(Alpha);\r\n    Vsy = -Vs * Kyalpha;\r\n    mu_y = Vsy * Vsy;\r\n    Vs = sqrt(phi_t * phi_t + mu_y);\r\n    main_div0protect(rtP.Constant1_Value, rtP.CombinedSlipWheelCPI_VXLOW, &phi_t,\r\n                     &Vc);\r\n    Vc = sqrt(rtP.Constant1_Value * rtP.Constant1_Value + mu_y);\r\n    main_div0protect(Vc, rtP.CombinedSlipWheelCPI_VXLOW, &Vsy, &mu_y);\r\n    Vc = main_div0protect_k(Vc);\r\n    lam_mux_star = 1.0 / (0.0 * Vs / rtP.CombinedSlipWheelCPI_LONGVL + 1.0);\r\n    Vs = lam_mux_star;\r\n    lam_muy_prime = Vs * 10.0 / (9.0 * Vs + 1.0);\r\n    mu_y_tmp = gamma_star * gamma_star;\r\n    mu_y_tmp_0 = dpi * dpi;\r\n    mu_y = ((rtP.CombinedSlipWheelCPI_PPY3 * dpi + 1.0) + mu_y_tmp_0 *\r\n            rtP.CombinedSlipWheelCPI_PPY4) * (rtP.CombinedSlipWheelCPI_PDY2 *\r\n      dfz + rtP.CombinedSlipWheelCPI_PDY1) * (1.0 - mu_y_tmp *\r\n      rtP.CombinedSlipWheelCPI_PDY3) * Vs;\r\n    phi_t = -rtP.Constant4_Value / phi_t * cos(Alpha);\r\n    jb = phi_t;\r\n    trueCount = 0;\r\n    if (rtP.Constant1_Value < rtP.CombinedSlipWheelCPI_VXLOW) {\r\n      for (i = 0; i < 1; i++) {\r\n        trueCount++;\r\n      }\r\n    }\r\n\r\n    jb_tmp[0] = 1;\r\n    jb_tmp[1] = trueCount;\r\n    if (rtP.Constant1_Value < rtP.CombinedSlipWheelCPI_VXLOW) {\r\n      ob_data = 0;\r\n    }\r\n\r\n    tmp_size[0] = 1;\r\n    tmp_size[1] = jb_tmp[1];\r\n    trueCount = jb_tmp[1];\r\n    if (trueCount - 1 >= 0) {\r\n      c = rtP.Constant1_Value;\r\n    }\r\n\r\n    main_abs(&c, tmp_size, &phi_data, phi_size);\r\n    if (jb_tmp[1] == phi_size[1]) {\r\n      tmp_size[0] = 1;\r\n      tmp_size[1] = jb_tmp[1];\r\n      trueCount = jb_tmp[1];\r\n      if (trueCount - 1 >= 0) {\r\n        c = rtP.Constant1_Value;\r\n      }\r\n\r\n      main_abs(&c, tmp_size, &phi_data, phi_size);\r\n      trueCount = jb_tmp[1];\r\n      if (trueCount - 1 >= 0) {\r\n        jb = phi_data / rtP.CombinedSlipWheelCPI_VXLOW * phi_t;\r\n      }\r\n    } else {\r\n      main_binary_expand_op_4(&jb, phi_t, jb_tmp, rtP.Constant1_Value,\r\n        rtP.CombinedSlipWheelCPI_VXLOW);\r\n    }\r\n\r\n    phi = ((1.0 - epsilon_gamma) * fabs(rtP.Constant_Value) * gamma_star +\r\n           rtP.Constant4_Value) * (1.0 / Vc);\r\n    turnslipinds = ((rtP.CombinedSlipWheelCPI_turnslip == 1.0) && (fabs(phi) >\r\n      0.01));\r\n    isLowSpeed = !turnslipinds;\r\n    SHykappa = rtP.CombinedSlipWheelCPI_RHY2 * dfz +\r\n      rtP.CombinedSlipWheelCPI_RHY1;\r\n    phi_t = rtP.CombinedSlipWheelCPI_REY2 * dfz + rtP.CombinedSlipWheelCPI_REY1;\r\n    kb_idx_0 = phi_t;\r\n    if (phi_t > 1.0) {\r\n      kb_idx_0 = 1.0;\r\n    }\r\n\r\n    phi_t = (mu_y_tmp * rtP.CombinedSlipWheelCPI_RBY4 +\r\n             rtP.CombinedSlipWheelCPI_RBY1) * cos(atan((Alpha -\r\n      rtP.CombinedSlipWheelCPI_RBY3) * rtP.CombinedSlipWheelCPI_RBY2)) * 0.0;\r\n    mb_idx_0 = phi_t;\r\n    c_u = Kappa + SHykappa;\r\n    for (i = 0; i < 9; i++) {\r\n      zeta[i] = 1.0;\r\n    }\r\n\r\n    trueCount = 0;\r\n    if (turnslipinds) {\r\n      for (i = 0; i < 1; i++) {\r\n        trueCount++;\r\n      }\r\n    }\r\n\r\n    ob_tmp_size[0] = 1;\r\n    ob_tmp_size[1] = trueCount;\r\n    tmp_0 = ob_tmp_size[1];\r\n    if (tmp_0 - 1 >= 0) {\r\n      zeta[0] = 0.0;\r\n    }\r\n\r\n    tmp_3 = !isLowSpeed;\r\n    if (tmp_3) {\r\n      trueCount = 0;\r\n      if (turnslipinds) {\r\n        for (i = 0; i < 1; i++) {\r\n          trueCount++;\r\n        }\r\n      }\r\n\r\n      pb_size_idx_0 = trueCount;\r\n      jb_tmp[0] = 1;\r\n      jb_tmp[1] = tmp_0;\r\n      tmpDrphiVar_size[0] = 1;\r\n      tmpDrphiVar_size[1] = jb_tmp[1];\r\n      SHy = atan(rtP.CombinedSlipWheelCPI_PDXP3 * Kappa);\r\n      SHy = cos(SHy);\r\n      trueCount = jb_tmp[1];\r\n      if (trueCount - 1 >= 0) {\r\n        tmpDrphiVar_data = (rtP.CombinedSlipWheelCPI_PDXP2 * dfz + 1.0) *\r\n          rtP.CombinedSlipWheelCPI_PDXP1 * SHy *\r\n          rtP.CombinedSlipWheelCPI_UNLOADED_R * phi;\r\n      }\r\n\r\n      main_atan(&tmpDrphiVar_data, tmpDrphiVar_size);\r\n      main_cos(&tmpDrphiVar_data, tmpDrphiVar_size);\r\n      i = pb_size_idx_0;\r\n      if (i - 1 >= 0) {\r\n        zeta[1] = tmpDrphiVar_data;\r\n      }\r\n\r\n      trueCount = 0;\r\n      if (turnslipinds) {\r\n        for (i = 0; i < 1; i++) {\r\n          trueCount++;\r\n        }\r\n      }\r\n\r\n      pb_size_idx_0 = trueCount;\r\n      phi_size[0] = 1;\r\n      phi_size[1] = jb_tmp[1];\r\n      trueCount = jb_tmp[1];\r\n      if (trueCount - 1 >= 0) {\r\n        phi_data = phi;\r\n      }\r\n\r\n      main_abs(&phi_data, phi_size, &c, tmp_size);\r\n      tmpDrphiVar_size[0] = 1;\r\n      trueCount = tmp_size[1];\r\n      tmpDrphiVar_size[1] = trueCount;\r\n      if (trueCount - 1 >= 0) {\r\n        tmpDrphiVar_data = rtP.CombinedSlipWheelCPI_UNLOADED_R * c;\r\n      }\r\n\r\n      main_sqrt(&tmpDrphiVar_data, tmpDrphiVar_size);\r\n      trueCount = 0;\r\n      if (turnslipinds) {\r\n        for (i = 0; i < 1; i++) {\r\n          trueCount++;\r\n        }\r\n      }\r\n\r\n      phi_size[0] = 1;\r\n      phi_size[1] = trueCount;\r\n      phi_size_0[0] = 1;\r\n      phi_size_0[1] = trueCount;\r\n      if (trueCount - 1 >= 0) {\r\n        phi_data = phi;\r\n        phi_data_0 = phi;\r\n      }\r\n\r\n      main_abs(&phi_data, phi_size, &c, tmp_size);\r\n      main_abs(&phi_data_0, phi_size_0, &phi_data, phi_size);\r\n      if (phi_size[1] == 1) {\r\n        i = tmpDrphiVar_size[1];\r\n      } else {\r\n        i = phi_size[1];\r\n      }\r\n\r\n      if ((tmp_size[1] == tmpDrphiVar_size[1]) && (i == jb_tmp[1])) {\r\n        SHy = atan(rtP.CombinedSlipWheelCPI_PDYP3 * Kyalpha);\r\n        SHy = cos(SHy);\r\n        phi_size[0] = 1;\r\n        phi_size[1] = trueCount;\r\n        if (trueCount - 1 >= 0) {\r\n          phi_data = phi;\r\n        }\r\n\r\n        main_abs(&phi_data, phi_size, &c, tmp_size);\r\n        trueCount = jb_tmp[1] - 1;\r\n        tmpDrphiVar_size[0] = 1;\r\n        tmpDrphiVar_size[1] = jb_tmp[1];\r\n        for (i = 0; i <= trueCount; i++) {\r\n          tmpDrphiVar_data = (rtP.CombinedSlipWheelCPI_PDYP2 * dfz + 1.0) *\r\n            rtP.CombinedSlipWheelCPI_PDYP1 * SHy *\r\n            (rtP.CombinedSlipWheelCPI_UNLOADED_R * c +\r\n             rtP.CombinedSlipWheelCPI_PDYP4 * tmpDrphiVar_data);\r\n        }\r\n      } else {\r\n        main_binary_expand_op_3(&tmpDrphiVar_data, tmpDrphiVar_size,\r\n          rtP.CombinedSlipWheelCPI_PDYP1, rtP.CombinedSlipWheelCPI_PDYP2, dfz,\r\n          rtP.CombinedSlipWheelCPI_PDYP3, Kyalpha, jb_tmp,\r\n          rtP.CombinedSlipWheelCPI_UNLOADED_R, phi, trueCount,\r\n          rtP.CombinedSlipWheelCPI_PDYP4);\r\n      }\r\n\r\n      main_atan(&tmpDrphiVar_data, tmpDrphiVar_size);\r\n      main_cos(&tmpDrphiVar_data, tmpDrphiVar_size);\r\n      i = pb_size_idx_0;\r\n      if (i - 1 >= 0) {\r\n        zeta[2] = tmpDrphiVar_data;\r\n      }\r\n\r\n      trueCount = 0;\r\n      if (turnslipinds) {\r\n        for (i = 0; i < 1; i++) {\r\n          trueCount++;\r\n        }\r\n      }\r\n\r\n      pb_size_idx_0 = trueCount;\r\n      Kyalpha = rtP.CombinedSlipWheelCPI_UNLOADED_R *\r\n        rtP.CombinedSlipWheelCPI_UNLOADED_R;\r\n      tmpDrphiVar_size[0] = 1;\r\n      tmpDrphiVar_size[1] = jb_tmp[1];\r\n      SHy = rtP.CombinedSlipWheelCPI_PKYP1 * Kyalpha;\r\n      trueCount = jb_tmp[0] * jb_tmp[1];\r\n      if (trueCount - 1 >= 0) {\r\n        Kyalpha = phi * phi;\r\n        tmpDrphiVar_data = SHy * Kyalpha;\r\n      }\r\n\r\n      main_atan(&tmpDrphiVar_data, tmpDrphiVar_size);\r\n      main_cos(&tmpDrphiVar_data, tmpDrphiVar_size);\r\n      i = pb_size_idx_0;\r\n      if (i - 1 >= 0) {\r\n        zeta[3] = tmpDrphiVar_data;\r\n      }\r\n    }\r\n\r\n    Kygammao = (rtP.CombinedSlipWheelCPI_PKY7 * dfz +\r\n                rtP.CombinedSlipWheelCPI_PKY6) * FzTire *\r\n      (rtP.CombinedSlipWheelCPI_PPY5 * dpi + 1.0) * 0.0;\r\n    SVygamma_tmp = FzTire / Fzo_prime;\r\n    SVygamma = sin(atan(SVygamma_tmp / (mu_y_tmp * rtP.CombinedSlipWheelCPI_PKY5\r\n      + rtP.CombinedSlipWheelCPI_PKY2) / (rtP.CombinedSlipWheelCPI_PPY2 * dpi +\r\n      1.0)) * rtP.CombinedSlipWheelCPI_PKY4);\r\n    phi_t = fabs(gamma_star);\r\n    Kyalpha_tmp = (rtP.CombinedSlipWheelCPI_PPY1 * dpi + 1.0) *\r\n      (rtP.CombinedSlipWheelCPI_PKY1 * Fzo_prime);\r\n    Kyalpha = (1.0 - rtP.CombinedSlipWheelCPI_PKY3 * phi_t) * Kyalpha_tmp *\r\n      SVygamma * zeta[3] * 0.0;\r\n    main_div0protect_kw(Kyalpha, &Vc, &SHy);\r\n    main_div0protect_kw(Kyalpha_tmp * (1.0 - rtP.CombinedSlipWheelCPI_PKY3 * 0.0)\r\n                        * SVygamma * zeta[3] * 0.0, &SHy, &DHyphi);\r\n    qb_idx_0 = rtP.CombinedSlipWheelCPI_PHYP1;\r\n    if (rtP.CombinedSlipWheelCPI_PHYP1 < 0.0) {\r\n      qb_idx_0 = 0.0;\r\n    }\r\n\r\n    SVygamma = tanh(rtP.Constant1_Value);\r\n    DHyphi = (rtP.CombinedSlipWheelCPI_PHYP3 * dfz +\r\n              rtP.CombinedSlipWheelCPI_PHYP2) * SVygamma;\r\n    sb_idx_0 = rtP.CombinedSlipWheelCPI_PHYP4;\r\n    if (rtP.CombinedSlipWheelCPI_PHYP4 > 1.0) {\r\n      sb_idx_0 = 1.0;\r\n    }\r\n\r\n    SHy = Kygammao / (1.0 - epsilon_gamma) / (qb_idx_0 * DHyphi * SHy);\r\n    Kyalpha_tmp = rtP.CombinedSlipWheelCPI_UNLOADED_R * phi;\r\n    SHy *= Kyalpha_tmp;\r\n    DHyphi = sin(atan(SHy - (SHy - atan(SHy)) * sb_idx_0) * qb_idx_0) * DHyphi *\r\n      SVygamma;\r\n    SVygamma = (rtP.CombinedSlipWheelCPI_PVY4 * dfz +\r\n                rtP.CombinedSlipWheelCPI_PVY3) * FzTire * gamma_star * zeta[2] *\r\n      0.0 * lam_muy_prime;\r\n    SHy = 0.0;\r\n    c_u *= mb_idx_0;\r\n    SHykappa *= mb_idx_0;\r\n    SHykappa = cos(atan(c_u - (c_u - atan(c_u)) * kb_idx_0) *\r\n                   rtP.CombinedSlipWheelCPI_RCY1) / cos(atan(SHykappa -\r\n      (SHykappa - atan(SHykappa)) * kb_idx_0) * rtP.CombinedSlipWheelCPI_RCY1);\r\n    qb_idx_0 = SHykappa;\r\n    if (SHykappa < 0.0) {\r\n      qb_idx_0 = 0.0;\r\n    }\r\n\r\n    if (tmp_3) {\r\n      trueCount = 0;\r\n      if (turnslipinds) {\r\n        for (i = 0; i < 1; i++) {\r\n          trueCount++;\r\n        }\r\n      }\r\n\r\n      pb_size_idx_0 = trueCount;\r\n      jb_tmp[0] = 1;\r\n      jb_tmp[1] = tmp_0;\r\n      if (pb_size_idx_0 - 1 >= 0) {\r\n        zeta[4] = (DHyphi + 1.0) - SVygamma / Vc;\r\n      }\r\n\r\n      tmpDrphiVar_size[0] = 1;\r\n      tmpDrphiVar_size[1] = jb_tmp[1];\r\n      trueCount = jb_tmp[1];\r\n      if (trueCount - 1 >= 0) {\r\n        tmpDrphiVar_data = rtP.CombinedSlipWheelCPI_QDTP1 *\r\n          rtP.CombinedSlipWheelCPI_UNLOADED_R * phi;\r\n      }\r\n\r\n      main_atan(&tmpDrphiVar_data, tmpDrphiVar_size);\r\n      main_cos(&tmpDrphiVar_data, tmpDrphiVar_size);\r\n      if (pb_size_idx_0 - 1 >= 0) {\r\n        zeta[5] = tmpDrphiVar_data;\r\n      }\r\n\r\n      tmpDrphiVar_size[0] = 1;\r\n      tmpDrphiVar_size[1] = jb_tmp[1];\r\n      trueCount = jb_tmp[1];\r\n      if (trueCount - 1 >= 0) {\r\n        tmpDrphiVar_data = rtP.CombinedSlipWheelCPI_QBRP1 *\r\n          rtP.CombinedSlipWheelCPI_UNLOADED_R * phi;\r\n      }\r\n\r\n      main_atan(&tmpDrphiVar_data, tmpDrphiVar_size);\r\n      main_cos(&tmpDrphiVar_data, tmpDrphiVar_size);\r\n      if (pb_size_idx_0 - 1 >= 0) {\r\n        zeta[6] = tmpDrphiVar_data;\r\n      }\r\n\r\n      SHy = rtP.CombinedSlipWheelCPI_QCRP1 * mu_y *\r\n        rtP.CombinedSlipWheelCPI_UNLOADED_R * FzTire * sqrt(SVygamma_tmp) * 0.0;\r\n      kb_idx_0 = SHy;\r\n      SHykappa = rtP.CombinedSlipWheelCPI_QDRP1;\r\n      if (rtP.CombinedSlipWheelCPI_QDRP1 < 0.0) {\r\n        SHykappa = 0.0;\r\n      }\r\n\r\n      c_u = rtP.CombinedSlipWheelCPI_QDRP2;\r\n      if (rtP.CombinedSlipWheelCPI_QDRP2 < 0.0) {\r\n        c_u = 0.0;\r\n      }\r\n\r\n      SHy = kb_idx_0 / sin(1.5707963267948966 * SHykappa);\r\n      phi = 1.0 - epsilon_gamma;\r\n      if (rtIsNaN(phi)) {\r\n        phi = (rtNaN);\r\n      } else if (phi < 0.0) {\r\n        phi = -1.0;\r\n      } else {\r\n        phi = (phi > 0.0);\r\n      }\r\n\r\n      epsilon_gamma = ((rtP.CombinedSlipWheelCPI_QDZ11 * dfz +\r\n                        rtP.CombinedSlipWheelCPI_QDZ10) * fabs(e_idx_0) +\r\n                       (rtP.CombinedSlipWheelCPI_QDZ9 * dfz +\r\n                        rtP.CombinedSlipWheelCPI_QDZ8)) * (FzTire *\r\n        rtP.CombinedSlipWheelCPI_UNLOADED_R) * 0.0 / (SHykappa * SHy * (1.0 -\r\n        epsilon_gamma) + 0.0001 * phi);\r\n      phi = Kyalpha_tmp;\r\n      Kyalpha_tmp = epsilon_gamma * phi;\r\n      epsilon_gamma = sin(atan(Kyalpha_tmp - (Kyalpha_tmp - atan(Kyalpha_tmp)) *\r\n        c_u) * SHykappa) * SHy;\r\n      if (rtIsNaN(epsilon_gamma)) {\r\n        SHy = (rtNaN);\r\n      } else {\r\n        SHy = 0.0;\r\n      }\r\n\r\n      phi = SHy;\r\n      if (SHy == 0.0) {\r\n        phi = 1.0;\r\n      }\r\n\r\n      phi_size[0] = 1;\r\n      phi_size[1] = jb_tmp[1];\r\n      trueCount = jb_tmp[1];\r\n      phi_size_0[0] = 1;\r\n      phi_size_0[1] = jb_tmp[1];\r\n      if (trueCount - 1 >= 0) {\r\n        phi_data = epsilon_gamma;\r\n        phi_data_0 = epsilon_gamma;\r\n      }\r\n\r\n      main_abs(&phi_data, phi_size, &c, tmp_size);\r\n      main_abs(&phi_data_0, phi_size_0, &phi_data, phi_size);\r\n      if (phi_size[1] == 1) {\r\n        i = jb_tmp[1];\r\n      } else {\r\n        i = phi_size[1];\r\n      }\r\n\r\n      if ((tmp_size[1] == jb_tmp[1]) && (i == jb_tmp[1])) {\r\n        SHy = fabs(jb);\r\n        SHy = atan(rtP.CombinedSlipWheelCPI_QCRP2 *\r\n                   rtP.CombinedSlipWheelCPI_UNLOADED_R * SHy);\r\n        phi_size[0] = 1;\r\n        phi_size[1] = jb_tmp[1];\r\n        trueCount = jb_tmp[1];\r\n        if (trueCount - 1 >= 0) {\r\n          phi_data = epsilon_gamma;\r\n        }\r\n\r\n        main_abs(&phi_data, phi_size, &c, tmp_size);\r\n        tmpDrphiVar_size[0] = 1;\r\n        tmpDrphiVar_size[1] = jb_tmp[1];\r\n        trueCount = jb_tmp[1];\r\n        if (trueCount - 1 >= 0) {\r\n          tmpDrphiVar_data = kb_idx_0 * 2.0 / 3.1415926535897931 * SHy *\r\n            qb_idx_0 / (0.0001 * phi + c);\r\n        }\r\n      } else {\r\n        main_binary_expand_op_2(&tmpDrphiVar_data, tmpDrphiVar_size, &kb_idx_0,\r\n          rtP.CombinedSlipWheelCPI_QCRP2, rtP.CombinedSlipWheelCPI_UNLOADED_R,\r\n          &jb, &qb_idx_0, jb_tmp, epsilon_gamma, &phi);\r\n      }\r\n\r\n      trueCount = tmpDrphiVar_size[1];\r\n      for (i = 0; i < trueCount; i++) {\r\n        if (tmpDrphiVar_data > 1.0) {\r\n          tmpDrphiVar_data = 1.0;\r\n        }\r\n      }\r\n\r\n      for (i = 0; i < trueCount; i++) {\r\n        if (tmpDrphiVar_data < -1.0) {\r\n          tmpDrphiVar_data = -1.0;\r\n        }\r\n      }\r\n\r\n      main_acos(&tmpDrphiVar_data, tmpDrphiVar_size);\r\n      if (pb_size_idx_0 - 1 >= 0) {\r\n        zeta[7] = 0.63661977236758138 * tmpDrphiVar_data;\r\n        zeta[8] = epsilon_gamma + 1.0;\r\n      }\r\n\r\n      c = 0.0;\r\n      if (tmp_0 - 1 >= 0) {\r\n        tmp_data = 0;\r\n      }\r\n\r\n      trueCount = 0;\r\n      if (turnslipinds) {\r\n        for (i = 0; i < 1; i++) {\r\n          trueCount++;\r\n        }\r\n      }\r\n\r\n      if (jb_tmp[1] == 1) {\r\n        i = tmp_0;\r\n        pb_size_idx_0 = tmp_0;\r\n      } else {\r\n        i = jb_tmp[1];\r\n        pb_size_idx_0 = jb_tmp[1];\r\n      }\r\n\r\n      if (pb_size_idx_0 == 1) {\r\n        pb_size_idx_0 = jb_tmp[1];\r\n      } else if (jb_tmp[1] == 1) {\r\n        pb_size_idx_0 = tmp_0;\r\n      } else {\r\n        pb_size_idx_0 = jb_tmp[1];\r\n      }\r\n\r\n      if ((jb_tmp[1] == tmp_0) && (i == jb_tmp[1]) && (pb_size_idx_0 ==\r\n           trueCount)) {\r\n        trueCount = jb_tmp[0] * jb_tmp[1];\r\n        for (i = 0; i < trueCount; i++) {\r\n          c = ((rtP.CombinedSlipWheelCPI_PHY2 * dfz +\r\n                rtP.CombinedSlipWheelCPI_PHY1) * 0.0 + DHyphi) - SVygamma / Vc;\r\n        }\r\n      } else {\r\n        main_binary_expand_op_1(&c, rtP.CombinedSlipWheelCPI_PHY1,\r\n          rtP.CombinedSlipWheelCPI_PHY2, dfz, jb_tmp,\r\n          rtB.TmpSignalConversionAtSFunctionI, ob_tmp_size, DHyphi, SVygamma,\r\n          trueCount, Vc);\r\n      }\r\n\r\n      SHy = c;\r\n    }\r\n\r\n    epsilon_gamma = rtP.CombinedSlipWheelCPI_PCX1 *\r\n      rtB.TmpSignalConversionAtSFunctionI[6];\r\n    kb_idx_0 = epsilon_gamma;\r\n    if (epsilon_gamma < 0.0) {\r\n      kb_idx_0 = 0.0;\r\n    }\r\n\r\n    Kyalpha_tmp = e_idx_0 * e_idx_0;\r\n    epsilon_gamma = ((rtP.CombinedSlipWheelCPI_PPX3 * dpi + 1.0) + mu_y_tmp_0 *\r\n                     rtP.CombinedSlipWheelCPI_PPX4) *\r\n      (rtP.CombinedSlipWheelCPI_PDX2 * dfz + rtP.CombinedSlipWheelCPI_PDX1) *\r\n      (1.0 - Kyalpha_tmp * rtP.CombinedSlipWheelCPI_PDX3) * lam_mux_star *\r\n      FzTire * zeta[1];\r\n    lam_mux_star = epsilon_gamma;\r\n    if (epsilon_gamma < 0.0) {\r\n      lam_mux_star = 0.0;\r\n    }\r\n\r\n    DHyphi = dfz * dfz;\r\n    epsilon_gamma = ((rtP.CombinedSlipWheelCPI_PEX2 * dfz +\r\n                      rtP.CombinedSlipWheelCPI_PEX1) + DHyphi *\r\n                     rtP.CombinedSlipWheelCPI_PEX3) * (1.0 - tanh(10.0 * kappa_x)\r\n      * rtP.CombinedSlipWheelCPI_PEX4) * rtB.TmpSignalConversionAtSFunctionI[8];\r\n    mb_idx_0 = epsilon_gamma;\r\n    if (epsilon_gamma > 1.0) {\r\n      mb_idx_0 = 1.0;\r\n    }\r\n\r\n    epsilon_gamma = (rtP.CombinedSlipWheelCPI_PKX2 * dfz +\r\n                     rtP.CombinedSlipWheelCPI_PKX1) * FzTire * exp\r\n      (rtP.CombinedSlipWheelCPI_PKX3 * dfz) * ((rtP.CombinedSlipWheelCPI_PPX1 *\r\n      dpi + 1.0) + mu_y_tmp_0 * rtP.CombinedSlipWheelCPI_PPX2) *\r\n      rtB.TmpSignalConversionAtSFunctionI[4];\r\n    main_div0protect_kw(kb_idx_0 * lam_mux_star, &phi, &SHykappa);\r\n    phi = epsilon_gamma / phi;\r\n    SHykappa = rtP.CombinedSlipWheelCPI_REX2 * dfz +\r\n      rtP.CombinedSlipWheelCPI_REX1;\r\n    mu_y_tmp_0 = SHykappa;\r\n    if (SHykappa > 1.0) {\r\n      mu_y_tmp_0 = 1.0;\r\n    }\r\n\r\n    SHykappa = (mu_y_tmp * rtP.CombinedSlipWheelCPI_RBX3 +\r\n                rtP.CombinedSlipWheelCPI_RBX1) * cos(atan\r\n      (rtP.CombinedSlipWheelCPI_RBX2 * Kappa)) *\r\n      rtB.TmpSignalConversionAtSFunctionI[18];\r\n    SVygamma_tmp = SHykappa;\r\n    if (SHykappa < 0.0) {\r\n      SVygamma_tmp = 0.0;\r\n    }\r\n\r\n    SHykappa = Alpha + rtP.CombinedSlipWheelCPI_RHX1;\r\n    c_u = SVygamma_tmp * SHykappa;\r\n    SHykappa = SVygamma_tmp * rtP.CombinedSlipWheelCPI_RHX1;\r\n    SHykappa = cos(atan(c_u - (c_u - atan(c_u)) * mu_y_tmp_0) *\r\n                   rtP.CombinedSlipWheelCPI_RCX1) / cos(atan(SHykappa -\r\n      (SHykappa - atan(SHykappa)) * mu_y_tmp_0) * rtP.CombinedSlipWheelCPI_RCX1);\r\n    if (SHykappa < 0.0) {\r\n      SHykappa = 0.0;\r\n    }\r\n\r\n    kappa_x *= phi;\r\n    kappa_x = ((rtP.CombinedSlipWheelCPI_PVX2 * dfz +\r\n                rtP.CombinedSlipWheelCPI_PVX1) * FzTire * lam_muy_prime *\r\n               rtB.TmpSignalConversionAtSFunctionI[12] * zeta[1] + sin(atan\r\n                (kappa_x - (kappa_x - atan(kappa_x)) * mb_idx_0) * kb_idx_0) *\r\n               lam_mux_star) * SHykappa;\r\n    lam_mux_star = rtP.CombinedSlipWheelCPI_PCY1 *\r\n      rtB.TmpSignalConversionAtSFunctionI[7];\r\n    kb_idx_0 = lam_mux_star;\r\n    if (lam_mux_star < 0.0) {\r\n      kb_idx_0 = 0.0;\r\n    }\r\n\r\n    c_u = mu_y * FzTire;\r\n    SHykappa = c_u * zeta[2];\r\n    main_div0protect_kw(kb_idx_0 * SHykappa, &lam_mux_star, &phi);\r\n    phi = Kyalpha / lam_mux_star;\r\n    if (isLowSpeed) {\r\n      trueCount = 0;\r\n      if (isLowSpeed) {\r\n        for (i = 0; i < 1; i++) {\r\n          trueCount++;\r\n        }\r\n      }\r\n\r\n      wc_tmp_size[0] = 1;\r\n      wc_tmp_size[1] = trueCount;\r\n      ob_size[0] = 1;\r\n      trueCount = wc_tmp_size[1];\r\n      ob_size[1] = trueCount;\r\n      if (trueCount - 1 >= 0) {\r\n        ob_data = 0;\r\n      }\r\n\r\n      jb_tmp[0] = 1;\r\n      jb_tmp[1] = trueCount;\r\n      if (jb_tmp[1] == 1) {\r\n        i = trueCount;\r\n      } else {\r\n        i = jb_tmp[1];\r\n      }\r\n\r\n      if ((jb_tmp[1] == trueCount) && (i == jb_tmp[1])) {\r\n        tmp_0 = jb_tmp[1];\r\n        for (i = 0; i < tmp_0; i++) {\r\n          for (pb_size_idx_0 = 0; pb_size_idx_0 < trueCount; pb_size_idx_0++) {\r\n            c = (((Kygammao * gamma_star - SVygamma) / Vc * zeta[0] +\r\n                  (rtP.CombinedSlipWheelCPI_PHY2 * dfz +\r\n                   rtP.CombinedSlipWheelCPI_PHY1) *\r\n                  rtB.TmpSignalConversionAtSFunctionI[11]) + zeta[4]) - 1.0;\r\n          }\r\n        }\r\n\r\n        if (trueCount - 1 >= 0) {\r\n          SHy = c;\r\n        }\r\n      } else {\r\n        main_binary_expand_op(&SHy, ob_size, rtP.CombinedSlipWheelCPI_PHY1,\r\n                              rtP.CombinedSlipWheelCPI_PHY2, dfz, jb_tmp,\r\n                              rtB.TmpSignalConversionAtSFunctionI, wc_tmp_size,\r\n                              Kygammao, gamma_star, SVygamma, Vc, zeta);\r\n      }\r\n    }\r\n\r\n    SVygamma += (rtP.CombinedSlipWheelCPI_PVY2 * dfz +\r\n                 rtP.CombinedSlipWheelCPI_PVY1) * FzTire *\r\n      rtB.TmpSignalConversionAtSFunctionI[13] * lam_muy_prime * zeta[2];\r\n    lam_muy_prime = Alpha + SHy;\r\n    if (rtIsNaN(lam_muy_prime)) {\r\n      lam_mux_star = (rtNaN);\r\n    } else if (lam_muy_prime < 0.0) {\r\n      lam_mux_star = -1.0;\r\n    } else {\r\n      lam_mux_star = (lam_muy_prime > 0.0);\r\n    }\r\n\r\n    if (lam_mux_star == 0.0) {\r\n      lam_mux_star = 1.0;\r\n    }\r\n\r\n    lam_mux_star = ((mu_y_tmp * rtP.CombinedSlipWheelCPI_PEY5 + 1.0) -\r\n                    (rtP.CombinedSlipWheelCPI_PEY4 * gamma_star +\r\n                     rtP.CombinedSlipWheelCPI_PEY3) * lam_mux_star) *\r\n      (rtP.CombinedSlipWheelCPI_PEY2 * dfz + rtP.CombinedSlipWheelCPI_PEY1) *\r\n      rtB.TmpSignalConversionAtSFunctionI[9];\r\n    mu_y = lam_mux_star;\r\n    if (lam_mux_star > 1.0) {\r\n      mu_y = 1.0;\r\n    }\r\n\r\n    lam_mux_star = ((rtP.CombinedSlipWheelCPI_RVY2 * dfz +\r\n                     rtP.CombinedSlipWheelCPI_RVY1) +\r\n                    rtP.CombinedSlipWheelCPI_RVY3 * gamma_star) * c_u * cos(atan\r\n      (rtP.CombinedSlipWheelCPI_RVY4 * Alpha)) * zeta[2] * sin(atan\r\n      (rtP.CombinedSlipWheelCPI_RVY6 * Kappa) * rtP.CombinedSlipWheelCPI_RVY5) *\r\n      rtB.TmpSignalConversionAtSFunctionI[20];\r\n    mu_y_tmp_0 = phi * lam_muy_prime;\r\n    mu_y = (sin(atan(mu_y_tmp_0 - (mu_y_tmp_0 - atan(mu_y_tmp_0)) * mu_y) *\r\n                kb_idx_0) * SHykappa + SVygamma) * qb_idx_0 + lam_mux_star;\r\n    lam_muy_prime = rtP.Constant1_Value / rtP.CombinedSlipWheelCPI_LONGVL;\r\n    lam_muy_prime = ((((kappa_x / rtP.CombinedSlipWheelCPI_FNOMIN *\r\n                        rtP.CombinedSlipWheelCPI_QSY2 +\r\n                        rtP.CombinedSlipWheelCPI_QSY1) + fabs(lam_muy_prime) *\r\n                       rtP.CombinedSlipWheelCPI_QSY3) + rt_powd_snf\r\n                      (lam_muy_prime, 4.0) * rtP.CombinedSlipWheelCPI_QSY4) +\r\n                     (Re_tmp * rtP.CombinedSlipWheelCPI_QSY6 +\r\n                      rtP.CombinedSlipWheelCPI_QSY5) * e_idx_0 * e_idx_0) *\r\n      (-rtP.CombinedSlipWheelCPI_UNLOADED_R * rtP.CombinedSlipWheelCPI_FNOMIN *\r\n       rtB.TmpSignalConversionAtSFunctionI[25]) * (rt_powd_snf(fmax(g_idx_0 /\r\n      rtP.CombinedSlipWheelCPI_NOMPRES, 0.05), rtP.CombinedSlipWheelCPI_QSY8) *\r\n      rt_powd_snf(fmax(Re_tmp, 0.05), rtP.CombinedSlipWheelCPI_QSY7)) * tanh\r\n      (10.0 * rtP.Constant_Value);\r\n    Kygammao = rtP.CombinedSlipWheelCPI_QSX6 * FzTire /\r\n      rtP.CombinedSlipWheelCPI_FNOMIN;\r\n    SHykappa = fabs(e_idx_0);\r\n    Re_tmp = rtP.CombinedSlipWheelCPI_UNLOADED_R * FzTire;\r\n    rtB.Mx = (((((rtP.CombinedSlipWheelCPI_QSX1 *\r\n                  rtB.TmpSignalConversionAtSFunctionI[24] -\r\n                  (rtP.CombinedSlipWheelCPI_PPMX1 * dpi + 1.0) *\r\n                  (rtP.CombinedSlipWheelCPI_QSX2 * e_idx_0)) -\r\n                 rtP.CombinedSlipWheelCPI_QSX12 * e_idx_0 * SHykappa) +\r\n                rtP.CombinedSlipWheelCPI_QSX3 * mu_y /\r\n                rtP.CombinedSlipWheelCPI_FNOMIN) + sin(atan\r\n                (rtP.CombinedSlipWheelCPI_QSX9 * mu_y /\r\n                 rtP.CombinedSlipWheelCPI_FNOMIN) *\r\n                rtP.CombinedSlipWheelCPI_QSX8 + rtP.CombinedSlipWheelCPI_QSX7 *\r\n                e_idx_0) * (cos(atan(Kygammao * Kygammao) *\r\n      rtP.CombinedSlipWheelCPI_QSX5) * rtP.CombinedSlipWheelCPI_QSX4)) + atan\r\n              (rtP.CombinedSlipWheelCPI_QSX11 * FzTire /\r\n               rtP.CombinedSlipWheelCPI_FNOMIN) * rtP.CombinedSlipWheelCPI_QSX10\r\n              * e_idx_0) * (Re_tmp * rtB.TmpSignalConversionAtSFunctionI[23]) +\r\n      rtP.CombinedSlipWheelCPI_UNLOADED_R * mu_y *\r\n      rtB.TmpSignalConversionAtSFunctionI[23] * (rtP.CombinedSlipWheelCPI_QSX14 *\r\n      SHykappa + rtP.CombinedSlipWheelCPI_QSX13);\r\n    Vsy = rtP.Constant1_Value / Vsy;\r\n    Kygammao = ((rtP.CombinedSlipWheelCPI_QHZ4 * dfz +\r\n                 rtP.CombinedSlipWheelCPI_QHZ3) * gamma_star +\r\n                (rtP.CombinedSlipWheelCPI_QHZ2 * dfz +\r\n                 rtP.CombinedSlipWheelCPI_QHZ1)) + Alpha;\r\n    SHy = (SVygamma / Vc + SHy) + Alpha;\r\n    SVygamma = (((rtP.CombinedSlipWheelCPI_QBZ4 * e_idx_0 + 1.0) +\r\n                 rtP.CombinedSlipWheelCPI_QBZ5 * SHykappa) + mu_y_tmp *\r\n                rtP.CombinedSlipWheelCPI_QBZ6) * ((rtP.CombinedSlipWheelCPI_QBZ2\r\n      * dfz + rtP.CombinedSlipWheelCPI_QBZ1) + DHyphi *\r\n      rtP.CombinedSlipWheelCPI_QBZ3) * rtB.TmpSignalConversionAtSFunctionI[5] /\r\n      Vs;\r\n    g_idx_0 = SVygamma;\r\n    if (SVygamma < 0.0) {\r\n      g_idx_0 = 0.0;\r\n    }\r\n\r\n    mu_y_tmp_0 = rtP.CombinedSlipWheelCPI_QCZ1;\r\n    if (rtP.CombinedSlipWheelCPI_QCZ1 < 0.0) {\r\n      mu_y_tmp_0 = 0.0;\r\n    }\r\n\r\n    SVygamma = ((rtP.CombinedSlipWheelCPI_QEZ5 * gamma_star +\r\n                 rtP.CombinedSlipWheelCPI_QEZ4) * 2.0 / 3.1415926535897931 *\r\n                atan(g_idx_0 * mu_y_tmp_0 * Kygammao) + 1.0) *\r\n      ((rtP.CombinedSlipWheelCPI_QEZ2 * dfz + rtP.CombinedSlipWheelCPI_QEZ1) +\r\n       DHyphi * rtP.CombinedSlipWheelCPI_QEZ3);\r\n    c_u = SVygamma;\r\n    if (SVygamma > 1.0) {\r\n      c_u = 1.0;\r\n    }\r\n\r\n    SVygamma = (rtP.CombinedSlipWheelCPI_QBZ9 *\r\n                rtB.TmpSignalConversionAtSFunctionI[5] / Vs +\r\n                rtP.CombinedSlipWheelCPI_QBZ10 * phi * kb_idx_0) * zeta[6];\r\n    phi = tan(SHy);\r\n    SHykappa = epsilon_gamma / Vc;\r\n    Vc = SHykappa * SHykappa * (Kappa * Kappa);\r\n    SHy = atan(sqrt(phi * phi + Vc)) * tanh(1000.0 * SHy);\r\n    phi = tan(Kygammao);\r\n    Vc = atan(sqrt(phi * phi + Vc)) * tanh(1000.0 * Kygammao);\r\n    mu_y_tmp = SVygamma * SHy;\r\n    Vc *= g_idx_0;\r\n    rtB.Mz = ((((((rtP.CombinedSlipWheelCPI_QDZ9 * dfz +\r\n                   rtP.CombinedSlipWheelCPI_QDZ8) *\r\n                  (rtP.CombinedSlipWheelCPI_PPZ2 * dpi + 1.0) +\r\n                  (rtP.CombinedSlipWheelCPI_QDZ11 * dfz +\r\n                   rtP.CombinedSlipWheelCPI_QDZ10) * phi_t) * gamma_star *\r\n                 rtB.TmpSignalConversionAtSFunctionI[15] * zeta[0] +\r\n                 (rtP.CombinedSlipWheelCPI_QDZ7 * dfz +\r\n                  rtP.CombinedSlipWheelCPI_QDZ6) *\r\n                 rtB.TmpSignalConversionAtSFunctionI[17] * zeta[2]) * Re_tmp *\r\n                Vs * tanh(10.0 * rtP.Constant1_Value) * Vsy + zeta[8]) - 1.0) *\r\n              cos(atan(mu_y_tmp - (mu_y_tmp - atan(mu_y_tmp)) * 0.0) * zeta[7])\r\n              + -((rtP.CombinedSlipWheelCPI_QDZ2 * dfz +\r\n                   rtP.CombinedSlipWheelCPI_QDZ1) * (1.0 -\r\n                rtP.CombinedSlipWheelCPI_PPZ1 * dpi) *\r\n                  ((rtP.CombinedSlipWheelCPI_QDZ3 * e_idx_0 + 1.0) + Kyalpha_tmp\r\n                   * rtP.CombinedSlipWheelCPI_QDZ4) * FzTire *\r\n                  (rtP.CombinedSlipWheelCPI_UNLOADED_R / Fzo_prime) *\r\n                  rtB.TmpSignalConversionAtSFunctionI[16] * zeta[5] * cos(atan\r\n                (Vc - (Vc - atan(Vc)) * c_u) * mu_y_tmp_0) * Vsy * 1.0) * (mu_y\r\n               - lam_mux_star)) + ((rtP.CombinedSlipWheelCPI_SSZ2 * mu_y /\r\n      rtP.CombinedSlipWheelCPI_FNOMIN + rtP.CombinedSlipWheelCPI_SSZ1) +\r\n      (rtP.CombinedSlipWheelCPI_SSZ4 * dfz + rtP.CombinedSlipWheelCPI_SSZ3) *\r\n      gamma_star) * rtP.CombinedSlipWheelCPI_UNLOADED_R *\r\n      rtB.TmpSignalConversionAtSFunctionI[21] * kappa_x;\r\n    if (rtP.vertType_Value == 1.0) {\r\n      RL = main_solveRLwithFz(rtP.CombinedSlipWheelCPI_LONGVL,\r\n        rtP.CombinedSlipWheelCPI_UNLOADED_R, rtP.CombinedSlipWheelCPI_ASPECT_RAT,\r\n        rtP.CombinedSlipWheelCPI_WIDTH, rtP.CombinedSlipWheelCPI_Q_RE0,\r\n        rtP.CombinedSlipWheelCPI_Q_V1, rtP.CombinedSlipWheelCPI_FNOMIN,\r\n        rtP.CombinedSlipWheelCPI_VERTICAL_S, rtP.CombinedSlipWheelCPI_RIM_RADIUS,\r\n        rtP.CombinedSlipWheelCPI_BOTTOM_STI, rtP.CombinedSlipWheelCPI_BOTTOM_OFF,\r\n        rtP.CombinedSlipWheelCPI_Q_V2, rtP.CombinedSlipWheelCPI_Q_FZ1,\r\n        rtP.CombinedSlipWheelCPI_Q_FZ2, rtP.CombinedSlipWheelCPI_Q_FCX,\r\n        rtP.CombinedSlipWheelCPI_Q_FCY, rtP.CombinedSlipWheelCPI_PFZ1,\r\n        rtP.CombinedSlipWheelCPI_Q_FCY2, rtP.CombinedSlipWheelCPI_Q_CAM1,\r\n        rtP.CombinedSlipWheelCPI_Q_CAM2, rtP.CombinedSlipWheelCPI_Q_CAM3,\r\n        rtP.CombinedSlipWheelCPI_Q_FYS1, rtP.CombinedSlipWheelCPI_Q_FYS2,\r\n        rtP.CombinedSlipWheelCPI_Q_FYS3, dpi, rtP.Constant_Value, e_idx_0,\r\n        kappa_x, mu_y, FzTire);\r\n      main_calculateFz(RL, rtP.CombinedSlipWheelCPI_LONGVL,\r\n                       rtP.CombinedSlipWheelCPI_UNLOADED_R,\r\n                       rtP.CombinedSlipWheelCPI_ASPECT_RAT,\r\n                       rtP.CombinedSlipWheelCPI_WIDTH,\r\n                       rtP.CombinedSlipWheelCPI_Q_RE0,\r\n                       rtP.CombinedSlipWheelCPI_Q_V1,\r\n                       rtP.CombinedSlipWheelCPI_FNOMIN,\r\n                       rtP.CombinedSlipWheelCPI_VERTICAL_S,\r\n                       rtP.CombinedSlipWheelCPI_RIM_RADIUS,\r\n                       rtP.CombinedSlipWheelCPI_BOTTOM_STI,\r\n                       rtP.CombinedSlipWheelCPI_BOTTOM_OFF,\r\n                       rtP.CombinedSlipWheelCPI_Q_V2,\r\n                       rtP.CombinedSlipWheelCPI_Q_FZ1,\r\n                       rtP.CombinedSlipWheelCPI_Q_FZ2,\r\n                       rtP.CombinedSlipWheelCPI_Q_FCX,\r\n                       rtP.CombinedSlipWheelCPI_Q_FCY,\r\n                       rtP.CombinedSlipWheelCPI_PFZ1,\r\n                       rtP.CombinedSlipWheelCPI_Q_FCY2,\r\n                       rtP.CombinedSlipWheelCPI_Q_CAM1,\r\n                       rtP.CombinedSlipWheelCPI_Q_CAM2,\r\n                       rtP.CombinedSlipWheelCPI_Q_CAM3,\r\n                       rtP.CombinedSlipWheelCPI_Q_FYS1,\r\n                       rtP.CombinedSlipWheelCPI_Q_FYS2,\r\n                       rtP.CombinedSlipWheelCPI_Q_FYS3, dpi, rtP.Constant_Value,\r\n                       e_idx_0, kappa_x, mu_y, &Fzo_prime, &RadialDeflct);\r\n    }\r\n\r\n    Vs = Cz * rtP.CombinedSlipWheelCPI_UNLOADED_R;\r\n    Fzo_prime = FzTire / Vs;\r\n    if ((Vs == 0.0) || (Fzo_prime < 0.0)) {\r\n      Fzo_prime = 0.0;\r\n    }\r\n\r\n    tmp_1 = _mm_mul_pd(_mm_add_pd(_mm_mul_pd(_mm_set_pd\r\n      (rtP.CombinedSlipWheelCPI_Q_RB2, rtP.CombinedSlipWheelCPI_Q_RA2),\r\n      _mm_set1_pd(Fzo_prime)), _mm_mul_pd(_mm_set_pd\r\n      (rtP.CombinedSlipWheelCPI_Q_RB1, rtP.CombinedSlipWheelCPI_Q_RA1),\r\n      _mm_set_pd(rt_powd_snf(Fzo_prime, 0.33333333333333331), sqrt(Fzo_prime)))),\r\n                       _mm_set_pd(rtP.CombinedSlipWheelCPI_WIDTH,\r\n      rtP.CombinedSlipWheelCPI_UNLOADED_R));\r\n    _mm_storeu_pd(&tmp_2[0], tmp_1);\r\n    Cz = tmp_2[0];\r\n    Fzo_prime = tmp_2[1];\r\n    if (Cz < 0.0) {\r\n      Cz = 0.0;\r\n    }\r\n\r\n    rtB.a = Cz;\r\n    if (Fzo_prime < 0.0) {\r\n      Fzo_prime = 0.0;\r\n    }\r\n\r\n    rtB.b = Fzo_prime;\r\n    rtB.sig_x = fabs(epsilon_gamma / (((rtP.CombinedSlipWheelCPI_PCFX1 * dfz +\r\n      1.0) + DHyphi * rtP.CombinedSlipWheelCPI_PCFX2) *\r\n      rtP.CombinedSlipWheelCPI_LONGITUDIN * (rtP.CombinedSlipWheelCPI_PCFX3 *\r\n      dpi + 1.0)));\r\n    rtB.sig_y = Kyalpha / (((rtP.CombinedSlipWheelCPI_PCFY1 * dfz + 1.0) +\r\n      DHyphi * rtP.CombinedSlipWheelCPI_PCFY2) *\r\n      rtP.CombinedSlipWheelCPI_LATERAL_ST * (rtP.CombinedSlipWheelCPI_PCFY3 *\r\n      dpi + 1.0));\r\n    rtB.Tw = kappa_x * RL - lam_muy_prime;\r\n  } else {\r\n    main_vdyncsmtire(rtP.Constant_Value, rtP.Constant1_Value, rtB.FlipTire,\r\n                     rtP.Constant4_Value, rtB.FlipTire1_n, rtP.Constant7_Value,\r\n                     rtB.TmpSignalConversionAtSFunctionI, &RadialDeflct,\r\n                     rtP.CombinedSlipWheelCPI_turnslip,\r\n                     rtP.CombinedSlipWheelCPI_PRESMAX,\r\n                     rtP.CombinedSlipWheelCPI_PRESMIN,\r\n                     rtP.CombinedSlipWheelCPI_FZMAX,\r\n                     rtP.CombinedSlipWheelCPI_FZMIN,\r\n                     rtP.CombinedSlipWheelCPI_VXLOW,\r\n                     rtP.CombinedSlipWheelCPI_KPUMAX,\r\n                     rtP.CombinedSlipWheelCPI_KPUMIN,\r\n                     rtP.CombinedSlipWheelCPI_ALPMAX,\r\n                     rtP.CombinedSlipWheelCPI_ALPMIN,\r\n                     rtP.CombinedSlipWheelCPI_CAMMIN,\r\n                     rtP.CombinedSlipWheelCPI_CAMMAX,\r\n                     rtP.CombinedSlipWheelCPI_LONGVL,\r\n                     rtP.CombinedSlipWheelCPI_UNLOADED_R,\r\n                     rtP.CombinedSlipWheelCPI_RIM_RADIUS,\r\n                     rtP.CombinedSlipWheelCPI_NOMPRES,\r\n                     rtP.CombinedSlipWheelCPI_FNOMIN,\r\n                     rtP.MagicTireConstInput_vdynMF[38],\r\n                     rtP.MagicTireConstInput_vdynMF[43],\r\n                     rtP.MagicTireConstInput_vdynMF[42],\r\n                     rtP.MagicTireConstInput_vdynMF[44],\r\n                     rtP.MagicTireConstInput_vdynMF[45],\r\n                     rtP.MagicTireConstInput_vdynMF[46],\r\n                     rtP.MagicTireConstInput_vdynMF[47],\r\n                     rtP.MagicTireConstInput_vdynMF[48],\r\n                     rtP.MagicTireConstInput_vdynMF[49],\r\n                     rtP.MagicTireConstInput_vdynMF[51],\r\n                     rtP.MagicTireConstInput_vdynMF[52],\r\n                     rtP.MagicTireConstInput_vdynMF[54],\r\n                     rtP.MagicTireConstInput_vdynMF[55],\r\n                     rtP.MagicTireConstInput_vdynMF[62],\r\n                     rtP.MagicTireConstInput_vdynMF[63],\r\n                     rtP.MagicTireConstInput_vdynMF[134],\r\n                     rtP.MagicTireConstInput_vdynMF[135],\r\n                     rtP.MagicTireConstInput_vdynMF[136],\r\n                     rtP.MagicTireConstInput_vdynMF[137],\r\n                     rtP.MagicTireConstInput_vdynMF[138],\r\n                     rtP.MagicTireConstInput_vdynMF[139],\r\n                     rtP.MagicTireConstInput_vdynMF[140],\r\n                     rtP.MagicTireConstInput_vdynMF[141],\r\n                     rtP.MagicTireConstInput_vdynMF[142],\r\n                     rtP.MagicTireConstInput_vdynMF[143],\r\n                     rtP.MagicTireConstInput_vdynMF[144],\r\n                     rtP.MagicTireConstInput_vdynMF[145],\r\n                     rtP.MagicTireConstInput_vdynMF[146],\r\n                     rtP.MagicTireConstInput_vdynMF[147],\r\n                     rtP.MagicTireConstInput_vdynMF[148],\r\n                     rtP.MagicTireConstInput_vdynMF[149],\r\n                     rtP.MagicTireConstInput_vdynMF[150],\r\n                     rtP.MagicTireConstInput_vdynMF[151],\r\n                     rtP.MagicTireConstInput_vdynMF[152],\r\n                     rtP.MagicTireConstInput_vdynMF[153],\r\n                     rtP.MagicTireConstInput_vdynMF[154],\r\n                     rtP.MagicTireConstInput_vdynMF[155],\r\n                     rtP.MagicTireConstInput_vdynMF[156],\r\n                     rtP.MagicTireConstInput_vdynMF[157],\r\n                     rtP.MagicTireConstInput_vdynMF[158],\r\n                     rtP.MagicTireConstInput_vdynMF[159],\r\n                     rtP.MagicTireConstInput_vdynMF[160],\r\n                     rtP.MagicTireConstInput_vdynMF[161],\r\n                     rtP.MagicTireConstInput_vdynMF[162],\r\n                     rtP.MagicTireConstInput_vdynMF[163],\r\n                     rtP.MagicTireConstInput_vdynMF[164],\r\n                     rtP.MagicTireConstInput_vdynMF[165],\r\n                     rtP.MagicTireConstInput_vdynMF[166],\r\n                     rtP.MagicTireConstInput_vdynMF[167],\r\n                     rtP.MagicTireConstInput_vdynMF[168],\r\n                     rtP.MagicTireConstInput_vdynMF[169],\r\n                     rtP.MagicTireConstInput_vdynMF[170],\r\n                     rtP.MagicTireConstInput_vdynMF[174],\r\n                     rtP.MagicTireConstInput_vdynMF[175],\r\n                     rtP.MagicTireConstInput_vdynMF[176],\r\n                     rtP.MagicTireConstInput_vdynMF[177],\r\n                     rtP.MagicTireConstInput_vdynMF[178],\r\n                     rtP.MagicTireConstInput_vdynMF[179],\r\n                     rtP.MagicTireConstInput_vdynMF[180],\r\n                     rtP.MagicTireConstInput_vdynMF[181],\r\n                     rtP.MagicTireConstInput_vdynMF[182],\r\n                     rtP.MagicTireConstInput_vdynMF[183],\r\n                     rtP.MagicTireConstInput_vdynMF[184],\r\n                     rtP.MagicTireConstInput_vdynMF[185],\r\n                     rtP.MagicTireConstInput_vdynMF[186],\r\n                     rtP.MagicTireConstInput_vdynMF[187],\r\n                     rtP.MagicTireConstInput_vdynMF[188],\r\n                     rtP.MagicTireConstInput_vdynMF[189],\r\n                     rtP.MagicTireConstInput_vdynMF[190],\r\n                     rtP.MagicTireConstInput_vdynMF[191],\r\n                     rtP.MagicTireConstInput_vdynMF[192],\r\n                     rtP.MagicTireConstInput_vdynMF[193],\r\n                     rtP.MagicTireConstInput_vdynMF[194],\r\n                     rtP.MagicTireConstInput_vdynMF[195],\r\n                     rtP.MagicTireConstInput_vdynMF[196],\r\n                     rtP.MagicTireConstInput_vdynMF[197],\r\n                     rtP.MagicTireConstInput_vdynMF[198],\r\n                     rtP.MagicTireConstInput_vdynMF[199],\r\n                     rtP.MagicTireConstInput_vdynMF[200],\r\n                     rtP.MagicTireConstInput_vdynMF[201],\r\n                     rtP.MagicTireConstInput_vdynMF[202],\r\n                     rtP.MagicTireConstInput_vdynMF[203],\r\n                     rtP.MagicTireConstInput_vdynMF[204],\r\n                     rtP.MagicTireConstInput_vdynMF[205],\r\n                     rtP.MagicTireConstInput_vdynMF[206],\r\n                     rtP.MagicTireConstInput_vdynMF[207],\r\n                     rtP.MagicTireConstInput_vdynMF[208],\r\n                     rtP.MagicTireConstInput_vdynMF[209],\r\n                     rtP.MagicTireConstInput_vdynMF[210],\r\n                     rtP.MagicTireConstInput_vdynMF[211],\r\n                     rtP.MagicTireConstInput_vdynMF[212],\r\n                     rtP.MagicTireConstInput_vdynMF[213],\r\n                     rtP.MagicTireConstInput_vdynMF[214],\r\n                     rtP.MagicTireConstInput_vdynMF[215],\r\n                     rtP.MagicTireConstInput_vdynMF[216],\r\n                     rtP.MagicTireConstInput_vdynMF[217],\r\n                     rtP.MagicTireConstInput_vdynMF[218],\r\n                     rtP.MagicTireConstInput_vdynMF[219],\r\n                     rtP.MagicTireConstInput_vdynMF[220],\r\n                     rtP.MagicTireConstInput_vdynMF[221],\r\n                     rtP.MagicTireConstInput_vdynMF[222],\r\n                     rtP.MagicTireConstInput_vdynMF[223],\r\n                     rtP.MagicTireConstInput_vdynMF[224],\r\n                     rtP.MagicTireConstInput_vdynMF[225],\r\n                     rtP.MagicTireConstInput_vdynMF[226],\r\n                     rtP.MagicTireConstInput_vdynMF[227],\r\n                     rtP.MagicTireConstInput_vdynMF[228],\r\n                     rtP.MagicTireConstInput_vdynMF[229],\r\n                     rtP.MagicTireConstInput_vdynMF[230],\r\n                     rtP.MagicTireConstInput_vdynMF[231],\r\n                     rtP.MagicTireConstInput_vdynMF[232],\r\n                     rtP.MagicTireConstInput_vdynMF[233],\r\n                     rtP.MagicTireConstInput_vdynMF[234],\r\n                     rtP.MagicTireConstInput_vdynMF[235],\r\n                     rtP.MagicTireConstInput_vdynMF[236],\r\n                     rtP.MagicTireConstInput_vdynMF[237],\r\n                     rtP.MagicTireConstInput_vdynMF[238],\r\n                     rtP.MagicTireConstInput_vdynMF[239],\r\n                     rtP.MagicTireConstInput_vdynMF[240],\r\n                     rtP.MagicTireConstInput_vdynMF[242],\r\n                     rtP.MagicTireConstInput_vdynMF[242],\r\n                     rtP.MagicTireConstInput_vdynMF[243],\r\n                     rtP.MagicTireConstInput_vdynMF[244],\r\n                     rtP.MagicTireConstInput_vdynMF[245],\r\n                     rtP.MagicTireConstInput_vdynMF[246],\r\n                     rtP.MagicTireConstInput_vdynMF[247],\r\n                     rtP.MagicTireConstInput_vdynMF[248],\r\n                     rtP.MagicTireConstInput_vdynMF[249],\r\n                     rtP.MagicTireConstInput_vdynMF[250],\r\n                     rtP.MagicTireConstInput_vdynMF[251],\r\n                     rtP.MagicTireConstInput_vdynMF[252],\r\n                     rtP.MagicTireConstInput_vdynMF[253],\r\n                     rtP.MagicTireConstInput_vdynMF[254],\r\n                     rtP.MagicTireConstInput_vdynMF[255],\r\n                     rtP.MagicTireConstInput_vdynMF[256],\r\n                     rtP.MagicTireConstInput_vdynMF[257],\r\n                     rtP.MagicTireConstInput_vdynMF[258],\r\n                     rtP.MagicTireConstInput_vdynMF[259],\r\n                     rtP.MagicTireConstInput_vdynMF[260],\r\n                     rtP.MagicTireConstInput_vdynMF[261],\r\n                     rtP.MagicTireConstInput_vdynMF[262],\r\n                     rtP.MagicTireConstInput_vdynMF[263],\r\n                     rtP.MagicTireConstInput_vdynMF[264],\r\n                     rtP.MagicTireConstInput_vdynMF[265],\r\n                     rtP.MagicTireConstInput_vdynMF[266],\r\n                     rtP.MagicTireConstInput_vdynMF[267],\r\n                     rtP.MagicTireConstInput_vdynMF[268],\r\n                     rtP.MagicTireConstInput_vdynMF[269],\r\n                     rtP.MagicTireConstInput_vdynMF[270],\r\n                     rtP.MagicTireConstInput_vdynMF[271],\r\n                     rtP.MagicTireConstInput_vdynMF[272],\r\n                     rtP.MagicTireConstInput_vdynMF[273],\r\n                     rtP.MagicTireConstInput_vdynMF[274],\r\n                     rtP.MagicTireConstInput_vdynMF[275],\r\n                     rtP.MagicTireConstInput_vdynMF[276],\r\n                     rtP.MagicTireConstInput_vdynMF[277],\r\n                     rtP.MagicTireConstInput_vdynMF[278],\r\n                     rtP.CombinedSlipWheelCPI_WIDTH,\r\n                     rtP.MagicTireConstInput_vdynMF[86],\r\n                     rtP.MagicTireConstInput_vdynMF[87],\r\n                     rtP.MagicTireConstInput_vdynMF[88],\r\n                     rtP.MagicTireConstInput_vdynMF[89],\r\n                     rtP.MagicTireConstInput_vdynMF[171],\r\n                     rtP.MagicTireConstInput_vdynMF[172],\r\n                     rtP.MagicTireConstInput_vdynMF[173],\r\n                     rtP.MagicTireConstInput_vdynMF[64],\r\n                     rtP.MagicTireConstInput_vdynMF[65],\r\n                     rtP.MagicTireConstInput_vdynMF[79],\r\n                     rtP.MagicTireConstInput_vdynMF[80],\r\n                     rtP.MagicTireConstInput_vdynMF[81],\r\n                     rtP.MagicTireConstInput_vdynMF[82],\r\n                     rtP.MagicTireConstInput_vdynMF[83],\r\n                     rtP.MagicTireConstInput_vdynMF[84], rtB.Integrator,\r\n                     rtB.Integrator_f, rtB.Sum1, rtP.vertType_Value,\r\n                     rtP.MagicTireConstInput_vdynMF[56],\r\n                     rtP.MagicTireConstInput_vdynMF[57],\r\n                     rtP.MagicTireConstInput_vdynMF[58],\r\n                     rtP.MagicTireConstInput_vdynMF[59],\r\n                     rtP.MagicTireConstInput_vdynMF[60],\r\n                     rtP.MagicTireConstInput_vdynMF[61],\r\n                     rtP.MagicTireConstInput_vdynMF[62], &kappa_x, &mu_y,\r\n                     &FzTire, &rtB.Mx, &lam_muy_prime, &rtB.Mz, &Re, &Kappa,\r\n                     &Alpha, &rtB.sig_x, &rtB.sig_y, &rtB.a, &rtB.b, &RL,\r\n                     &rtB.Tw);\r\n  }\r\n\r\n  rtB.Fx = kappa_x;\r\n  rtB.Fy = mu_y;\r\n  rtB.FzTire = FzTire;\r\n  rtB.My = lam_muy_prime;\r\n  rtB.Re = Re;\r\n  rtB.Kappa = Kappa;\r\n  rtB.Alpha = Alpha;\r\n  rtB.RL = RL;\r\n  rtB.RadialDeflct = RadialDeflct;\r\n\r\n  /* Gain: '<S2>/Flip Tire2' */\r\n  rtB.FlipTire2 = rtP.FlipTire2_Gain * rtB.Mx;\r\n\r\n  /* Integrator: '<S7>/Integrator' */\r\n  rtB.Integrator_e = rtX.Integrator_CSTATE_h;\r\n\r\n  /* Gain: '<S2>/Flip Tire3' */\r\n  rtB.FlipTire3 = rtP.FlipTire3_Gain * rtB.Mz;\r\n  if (tmp) {\r\n  }\r\n\r\n  /* Product: '<S3>/Product' */\r\n  rtB.Product = rtB.Fx * rtB.RL;\r\n\r\n  /* Sum: '<S3>/Add' */\r\n  rtB.Add = rtB.Product - rtB.My;\r\n\r\n  /* Product: '<S4>/Product2' incorporates:\r\n   *  Constant: '<Root>/Constant'\r\n   *  Product: '<S5>/Product2'\r\n   *  Product: '<S7>/Product2'\r\n   *  Product: '<S8>/Product2'\r\n   */\r\n  RadialDeflct = rtP.Constant_Value * rtB.Re;\r\n\r\n  /* Product: '<S4>/Product2' */\r\n  rtB.Product2 = RadialDeflct;\r\n\r\n  /* Sum: '<S4>/Add1' incorporates:\r\n   *  Constant: '<Root>/Constant1'\r\n   *  Sum: '<S7>/Add1'\r\n   *  Sum: '<S8>/Add1'\r\n   */\r\n  FzTire = rtP.Constant1_Value - rtB.Product2;\r\n\r\n  /* Sum: '<S4>/Add1' */\r\n  rtB.Add1 = FzTire;\r\n\r\n  /* Abs: '<S4>/Abs' incorporates:\r\n   *  Abs: '<S7>/Abs'\r\n   *  Abs: '<S8>/Abs'\r\n   */\r\n  Re = fabs(rtB.Add1);\r\n\r\n  /* Abs: '<S4>/Abs' */\r\n  rtB.Abs = Re;\r\n\r\n  /* Sum: '<S4>/Add' */\r\n  rtB.Add_a = rtB.Fx - rtB.Integrator;\r\n\r\n  /* Saturate: '<S4>/Saturation1' */\r\n  Kappa = rtB.sig_x;\r\n  Alpha = rtP.Saturation1_LowerSat;\r\n  RL = rtP.Saturation1_UpperSat;\r\n  if (Kappa > RL) {\r\n    /* Saturate: '<S4>/Saturation1' */\r\n    rtB.Saturation1 = RL;\r\n  } else if (Kappa < Alpha) {\r\n    /* Saturate: '<S4>/Saturation1' */\r\n    rtB.Saturation1 = Alpha;\r\n  } else {\r\n    /* Saturate: '<S4>/Saturation1' */\r\n    rtB.Saturation1 = Kappa;\r\n  }\r\n\r\n  /* End of Saturate: '<S4>/Saturation1' */\r\n\r\n  /* Product: '<S4>/Product3' */\r\n  rtB.Product3 = rtB.Abs / rtB.Saturation1;\r\n\r\n  /* Saturate: '<S4>/Saturation' */\r\n  Kappa = rtB.Product3;\r\n  Alpha = rtP.Saturation_LowerSat;\r\n  RL = rtP.Saturation_UpperSat;\r\n  if (Kappa > RL) {\r\n    /* Saturate: '<S4>/Saturation' */\r\n    rtB.Saturation = RL;\r\n  } else if (Kappa < Alpha) {\r\n    /* Saturate: '<S4>/Saturation' */\r\n    rtB.Saturation = Alpha;\r\n  } else {\r\n    /* Saturate: '<S4>/Saturation' */\r\n    rtB.Saturation = Kappa;\r\n  }\r\n\r\n  /* End of Saturate: '<S4>/Saturation' */\r\n\r\n  /* Product: '<S4>/Product1' */\r\n  rtB.Product1 = rtB.Saturation * rtB.Add_a;\r\n\r\n  /* Product: '<S5>/Product2' */\r\n  rtB.Product2_p = RadialDeflct;\r\n\r\n  /* Sum: '<S5>/Add1' */\r\n  rtB.Add1_e = rtB.FlipTire - rtB.Product2_p;\r\n\r\n  /* Abs: '<S5>/Abs' */\r\n  rtB.Abs_c = fabs(rtB.Add1_e);\r\n\r\n  /* Sum: '<S5>/Add' */\r\n  rtB.Add_i = rtB.Fy - rtB.Integrator_f;\r\n\r\n  /* Saturate: '<S5>/Saturation1' */\r\n  Kappa = rtB.sig_y;\r\n  Alpha = rtP.Saturation1_LowerSat_l;\r\n  RL = rtP.Saturation1_UpperSat_d;\r\n  if (Kappa > RL) {\r\n    /* Saturate: '<S5>/Saturation1' */\r\n    rtB.Saturation1_l = RL;\r\n  } else if (Kappa < Alpha) {\r\n    /* Saturate: '<S5>/Saturation1' */\r\n    rtB.Saturation1_l = Alpha;\r\n  } else {\r\n    /* Saturate: '<S5>/Saturation1' */\r\n    rtB.Saturation1_l = Kappa;\r\n  }\r\n\r\n  /* End of Saturate: '<S5>/Saturation1' */\r\n\r\n  /* Product: '<S5>/Product3' */\r\n  rtB.Product3_e = rtB.Abs_c / rtB.Saturation1_l;\r\n\r\n  /* Saturate: '<S5>/Saturation' */\r\n  Kappa = rtB.Product3_e;\r\n  Alpha = rtP.Saturation_LowerSat_f;\r\n  RL = rtP.Saturation_UpperSat_f;\r\n  if (Kappa > RL) {\r\n    /* Saturate: '<S5>/Saturation' */\r\n    rtB.Saturation_f = RL;\r\n  } else if (Kappa < Alpha) {\r\n    /* Saturate: '<S5>/Saturation' */\r\n    rtB.Saturation_f = Alpha;\r\n  } else {\r\n    /* Saturate: '<S5>/Saturation' */\r\n    rtB.Saturation_f = Kappa;\r\n  }\r\n\r\n  /* End of Saturate: '<S5>/Saturation' */\r\n\r\n  /* Product: '<S5>/Product1' */\r\n  rtB.Product1_l = rtB.Saturation_f * rtB.Add_i;\r\n\r\n  /* Product: '<S7>/Product2' */\r\n  rtB.Product2_pg = RadialDeflct;\r\n\r\n  /* Sum: '<S7>/Add1' */\r\n  rtB.Add1_k = FzTire;\r\n\r\n  /* Abs: '<S7>/Abs' */\r\n  rtB.Abs_f = Re;\r\n\r\n  /* Sum: '<S7>/Add' */\r\n  rtB.Add_f = rtB.My - rtB.Integrator_e;\r\n\r\n  /* Saturate: '<S7>/Saturation1' */\r\n  Kappa = rtB.sig_x;\r\n  Alpha = rtP.Saturation1_LowerSat_c;\r\n  RL = rtP.Saturation1_UpperSat_n;\r\n  if (Kappa > RL) {\r\n    /* Saturate: '<S7>/Saturation1' */\r\n    rtB.Saturation1_lc = RL;\r\n  } else if (Kappa < Alpha) {\r\n    /* Saturate: '<S7>/Saturation1' */\r\n    rtB.Saturation1_lc = Alpha;\r\n  } else {\r\n    /* Saturate: '<S7>/Saturation1' */\r\n    rtB.Saturation1_lc = Kappa;\r\n  }\r\n\r\n  /* End of Saturate: '<S7>/Saturation1' */\r\n\r\n  /* Product: '<S7>/Product3' */\r\n  rtB.Product3_c = rtB.Abs_f / rtB.Saturation1_lc;\r\n\r\n  /* Saturate: '<S7>/Saturation' */\r\n  Kappa = rtB.Product3_c;\r\n  Alpha = rtP.Saturation_LowerSat_d;\r\n  RL = rtP.Saturation_UpperSat_k;\r\n  if (Kappa > RL) {\r\n    /* Saturate: '<S7>/Saturation' */\r\n    rtB.Saturation_d = RL;\r\n  } else if (Kappa < Alpha) {\r\n    /* Saturate: '<S7>/Saturation' */\r\n    rtB.Saturation_d = Alpha;\r\n  } else {\r\n    /* Saturate: '<S7>/Saturation' */\r\n    rtB.Saturation_d = Kappa;\r\n  }\r\n\r\n  /* End of Saturate: '<S7>/Saturation' */\r\n\r\n  /* Product: '<S7>/Product1' */\r\n  rtB.Product1_f = rtB.Saturation_d * rtB.Add_f;\r\n\r\n  /* Product: '<S8>/Product2' */\r\n  rtB.Product2_n = RadialDeflct;\r\n\r\n  /* Sum: '<S8>/Add1' */\r\n  rtB.Add1_ke = FzTire;\r\n\r\n  /* Abs: '<S8>/Abs' */\r\n  rtB.Abs_k = Re;\r\n\r\n  /* Integrator: '<S8>/Integrator' */\r\n  rtB.Integrator_k = rtX.Integrator_CSTATE_e;\r\n\r\n  /* Sum: '<S8>/Add' */\r\n  rtB.Add_k = rtB.Add - rtB.Integrator_k;\r\n\r\n  /* Saturate: '<S8>/Saturation1' */\r\n  Kappa = rtB.sig_x;\r\n  Alpha = rtP.Saturation1_LowerSat_h;\r\n  RL = rtP.Saturation1_UpperSat_b;\r\n  if (Kappa > RL) {\r\n    /* Saturate: '<S8>/Saturation1' */\r\n    rtB.Saturation1_i = RL;\r\n  } else if (Kappa < Alpha) {\r\n    /* Saturate: '<S8>/Saturation1' */\r\n    rtB.Saturation1_i = Alpha;\r\n  } else {\r\n    /* Saturate: '<S8>/Saturation1' */\r\n    rtB.Saturation1_i = Kappa;\r\n  }\r\n\r\n  /* End of Saturate: '<S8>/Saturation1' */\r\n\r\n  /* Product: '<S8>/Product3' */\r\n  rtB.Product3_p = rtB.Abs_k / rtB.Saturation1_i;\r\n\r\n  /* Saturate: '<S8>/Saturation' */\r\n  Kappa = rtB.Product3_p;\r\n  Alpha = rtP.Saturation_LowerSat_h;\r\n  RL = rtP.Saturation_UpperSat_fp;\r\n  if (Kappa > RL) {\r\n    /* Saturate: '<S8>/Saturation' */\r\n    rtB.Saturation_fn = RL;\r\n  } else if (Kappa < Alpha) {\r\n    /* Saturate: '<S8>/Saturation' */\r\n    rtB.Saturation_fn = Alpha;\r\n  } else {\r\n    /* Saturate: '<S8>/Saturation' */\r\n    rtB.Saturation_fn = Kappa;\r\n  }\r\n\r\n  /* End of Saturate: '<S8>/Saturation' */\r\n\r\n  /* Product: '<S8>/Product1' */\r\n  rtB.Product1_a = rtB.Saturation_fn * rtB.Add_k;\r\n  UNUSED_PARAMETER(tid);\r\n}\r\n\r\n/* Update for root system: '<Root>' */\r\nvoid MdlUpdate(int_T tid)\r\n{\r\n  UNUSED_PARAMETER(tid);\r\n}\r\n\r\n/* Derivatives for root system: '<Root>' */\r\nvoid MdlDerivatives(void)\r\n{\r\n  XDot *_rtXdot;\r\n  _rtXdot = ((XDot *) ssGetdX(rtS));\r\n\r\n  /* Derivatives for Integrator: '<S4>/Integrator' */\r\n  _rtXdot->Integrator_CSTATE = rtB.Product1;\r\n\r\n  /* Derivatives for Integrator: '<S5>/Integrator' */\r\n  _rtXdot->Integrator_CSTATE_a = rtB.Product1_l;\r\n\r\n  /* Derivatives for Integrator: '<S7>/Integrator' */\r\n  _rtXdot->Integrator_CSTATE_h = rtB.Product1_f;\r\n\r\n  /* Derivatives for Integrator: '<S8>/Integrator' */\r\n  _rtXdot->Integrator_CSTATE_e = rtB.Product1_a;\r\n}\r\n\r\n/* Projection for root system: '<Root>' */\r\nvoid MdlProjection(void)\r\n{\r\n}\r\n\r\n/* Termination for root system: '<Root>' */\r\nvoid MdlTerminate(void)\r\n{\r\n}\r\n\r\n/* Function to initialize sizes */\r\nvoid MdlInitializeSizes(void)\r\n{\r\n  ssSetNumContStates(rtS, 4);          /* Number of continuous states */\r\n  ssSetNumPeriodicContStates(rtS, 0); /* Number of periodic continuous states */\r\n  ssSetNumY(rtS, 0);                   /* Number of model outputs */\r\n  ssSetNumU(rtS, 0);                   /* Number of model inputs */\r\n  ssSetDirectFeedThrough(rtS, 0);      /* The model is not direct feedthrough */\r\n  ssSetNumSampleTimes(rtS, 2);         /* Number of sample times */\r\n  ssSetNumBlocks(rtS, 59);             /* Number of blocks */\r\n  ssSetNumBlockIO(rtS, 63);            /* Number of block outputs */\r\n  ssSetNumBlockParams(rtS, 512);       /* Sum of parameter \"widths\" */\r\n}\r\n\r\n/* Function to initialize sample times. */\r\nvoid MdlInitializeSampleTimes(void)\r\n{\r\n  /* task periods */\r\n  ssSetSampleTime(rtS, 0, 0.0);\r\n  ssSetSampleTime(rtS, 1, 0.02);\r\n\r\n  /* task offsets */\r\n  ssSetOffsetTime(rtS, 0, 0.0);\r\n  ssSetOffsetTime(rtS, 1, 0.0);\r\n}\r\n\r\n/* Function to register the model */\r\n/* Turns off all optimizations on Windows because of issues with VC 2015 compiler.\r\n   This function is not performance-critical, hence this is not a problem.\r\n */\r\n#if defined(_MSC_VER)\r\n\r\n#pragma optimize( \"\", off )\r\n\r\n#endif\r\n\r\nSimStruct * main(void)\r\n{\r\n  static struct _ssMdlInfo mdlInfo;\r\n  static struct _ssBlkInfo2 blkInfo2;\r\n  static struct _ssBlkInfoSLSize blkInfoSLSize;\r\n  (void) memset((char_T *)rtS, 0,\r\n                sizeof(SimStruct));\r\n  (void) memset((char_T *)&mdlInfo, 0,\r\n                sizeof(struct _ssMdlInfo));\r\n  (void) memset((char_T *)&blkInfo2, 0,\r\n                sizeof(struct _ssBlkInfo2));\r\n  (void) memset((char_T *)&blkInfoSLSize, 0,\r\n                sizeof(struct _ssBlkInfoSLSize));\r\n  ssSetBlkInfo2Ptr(rtS, &blkInfo2);\r\n  ssSetBlkInfoSLSizePtr(rtS, &blkInfoSLSize);\r\n  ssSetMdlInfoPtr(rtS, &mdlInfo);\r\n\r\n  /* timing info */\r\n  {\r\n    static time_T mdlPeriod[NSAMPLE_TIMES];\r\n    static time_T mdlOffset[NSAMPLE_TIMES];\r\n    static time_T mdlTaskTimes[NSAMPLE_TIMES];\r\n    static int_T mdlTsMap[NSAMPLE_TIMES];\r\n    static int_T mdlSampleHits[NSAMPLE_TIMES];\r\n\r\n    {\r\n      int_T i;\r\n      for (i = 0; i < NSAMPLE_TIMES; i++) {\r\n        mdlPeriod[i] = 0.0;\r\n        mdlOffset[i] = 0.0;\r\n        mdlTaskTimes[i] = 0.0;\r\n        mdlTsMap[i] = i;\r\n        mdlSampleHits[i] = 1;\r\n      }\r\n    }\r\n\r\n    ssSetSampleTimePtr(rtS, &mdlPeriod[0]);\r\n    ssSetOffsetTimePtr(rtS, &mdlOffset[0]);\r\n    ssSetSampleTimeTaskIDPtr(rtS, &mdlTsMap[0]);\r\n    ssSetTPtr(rtS, &mdlTaskTimes[0]);\r\n    ssSetSampleHitPtr(rtS, &mdlSampleHits[0]);\r\n  }\r\n\r\n  ssSetSolverMode(rtS, SOLVER_MODE_SINGLETASKING);\r\n\r\n  /*\r\n   * initialize model vectors and cache them in SimStruct\r\n   */\r\n\r\n  /* block I/O */\r\n  {\r\n    ssSetBlockIO(rtS, ((void *) &rtB));\r\n    (void) memset(((void *) &rtB), 0,\r\n                  sizeof(B));\r\n  }\r\n\r\n  /* states (continuous)*/\r\n  {\r\n    real_T *x = (real_T *) &rtX;\r\n    ssSetContStates(rtS, x);\r\n    (void) memset((void *)x, 0,\r\n                  sizeof(X));\r\n  }\r\n\r\n  /* states (dwork) */\r\n  {\r\n    void *dwork = (void *) &rtDW;\r\n    ssSetRootDWork(rtS, dwork);\r\n    (void) memset(dwork, 0,\r\n                  sizeof(DW));\r\n  }\r\n\r\n  /* data type transition information */\r\n  {\r\n    static DataTypeTransInfo dtInfo;\r\n    (void) memset((char_T *) &dtInfo, 0,\r\n                  sizeof(dtInfo));\r\n    ssSetModelMappingInfo(rtS, &dtInfo);\r\n    dtInfo.numDataTypes = 23;\r\n    dtInfo.dataTypeSizes = &rtDataTypeSizes[0];\r\n    dtInfo.dataTypeNames = &rtDataTypeNames[0];\r\n\r\n    /* Block I/O transition table */\r\n    dtInfo.BTransTable = &rtBTransTable;\r\n\r\n    /* Parameters transition table */\r\n    dtInfo.PTransTable = &rtPTransTable;\r\n  }\r\n\r\n  /* Model specific registration */\r\n  ssSetRootSS(rtS, rtS);\r\n  ssSetVersion(rtS, SIMSTRUCT_VERSION_LEVEL2);\r\n  ssSetModelName(rtS, \"main\");\r\n  ssSetPath(rtS, \"main\");\r\n  ssSetTStart(rtS, 0.0);\r\n  ssSetTFinal(rtS, 1.0);\r\n  ssSetStepSize(rtS, 0.02);\r\n  ssSetFixedStepSize(rtS, 0.02);\r\n\r\n  /* Setup for data logging */\r\n  {\r\n    static RTWLogInfo rt_DataLoggingInfo;\r\n    rt_DataLoggingInfo.loggingInterval = (NULL);\r\n    ssSetRTWLogInfo(rtS, &rt_DataLoggingInfo);\r\n  }\r\n\r\n  /* Setup for data logging */\r\n  {\r\n    rtliSetLogXSignalInfo(ssGetRTWLogInfo(rtS), (NULL));\r\n    rtliSetLogXSignalPtrs(ssGetRTWLogInfo(rtS), (NULL));\r\n    rtliSetLogT(ssGetRTWLogInfo(rtS), \"tout\");\r\n    rtliSetLogX(ssGetRTWLogInfo(rtS), \"\");\r\n    rtliSetLogXFinal(ssGetRTWLogInfo(rtS), \"\");\r\n    rtliSetLogVarNameModifier(ssGetRTWLogInfo(rtS), \"rt_\");\r\n    rtliSetLogFormat(ssGetRTWLogInfo(rtS), 4);\r\n    rtliSetLogMaxRows(ssGetRTWLogInfo(rtS), 0);\r\n    rtliSetLogDecimation(ssGetRTWLogInfo(rtS), 1);\r\n    rtliSetLogY(ssGetRTWLogInfo(rtS), \"\");\r\n    rtliSetLogYSignalInfo(ssGetRTWLogInfo(rtS), (NULL));\r\n    rtliSetLogYSignalPtrs(ssGetRTWLogInfo(rtS), (NULL));\r\n  }\r\n\r\n  {\r\n    static struct _ssStatesInfo2 statesInfo2;\r\n    ssSetStatesInfo2(rtS, &statesInfo2);\r\n  }\r\n\r\n  {\r\n    static ssPeriodicStatesInfo periodicStatesInfo;\r\n    ssSetPeriodicStatesInfo(rtS, &periodicStatesInfo);\r\n  }\r\n\r\n  {\r\n    static ssJacobianPerturbationBounds jacobianPerturbationBounds;\r\n    ssSetJacobianPerturbationBounds(rtS, &jacobianPerturbationBounds);\r\n  }\r\n\r\n  ssSetChecksumVal(rtS, 0, 2763915399U);\r\n  ssSetChecksumVal(rtS, 1, 212292232U);\r\n  ssSetChecksumVal(rtS, 2, 4176857063U);\r\n  ssSetChecksumVal(rtS, 3, 4011425084U);\r\n  return rtS;\r\n}\r\n\r\n/* When you use the on parameter, it resets the optimizations to those that you\r\n   specified with the /O compiler option. */\r\n#if defined(_MSC_VER)\r\n\r\n#pragma optimize( \"\", on )\r\n\r\n#endif\r\n"},{"name":"main.h","type":"header","group":"model","path":"C:\\Users\\liam0\\OneDrive\\Desktop\\main_rsim_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * main.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"main\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Thu Oct 10 10:35:59 2024\r\n *\r\n * Target selection: rsim.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef main_h_\r\n#define main_h_\r\n#ifndef main_COMMON_INCLUDES_\r\n#define main_COMMON_INCLUDES_\r\n#include <stdlib.h>\r\n#include \"rtwtypes.h\"\r\n#include \"simstruc.h\"\r\n#include \"fixedpoint.h\"\r\n#include \"rsim.h\"\r\n#include \"rt_logging.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"math.h\"\r\n#include \"dt_info.h\"\r\n#endif                                 /* main_COMMON_INCLUDES_ */\r\n\r\n#include \"main_types.h\"\r\n#include \"rtGetInf.h\"\r\n#include \"rtGetNaN.h\"\r\n#include \"rt_defines.h\"\r\n#include <stddef.h>\r\n#include <string.h>\r\n#define MODEL_NAME                     main\r\n#define NSAMPLE_TIMES                  (2)                       /* Number of sample times */\r\n#define NINPUTS                        (0)                       /* Number of model inputs */\r\n#define NOUTPUTS                       (0)                       /* Number of model outputs */\r\n#define NBLOCKIO                       (63)                      /* Number of data output port signals */\r\n#define NUM_ZC_EVENTS                  (0)                       /* Number of zero-crossing events */\r\n#ifndef NCSTATES\r\n#define NCSTATES                       (4)                       /* Number of continuous states */\r\n#elif NCSTATES != 4\r\n# error Invalid specification of NCSTATES defined in compiler command\r\n#endif\r\n\r\n#ifndef rtmGetDataMapInfo\r\n#define rtmGetDataMapInfo(rtm)         (NULL)\r\n#endif\r\n\r\n#ifndef rtmSetDataMapInfo\r\n#define rtmSetDataMapInfo(rtm, val)\r\n#endif\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  real_T Integrator;                   /* '<S4>/Integrator' */\r\n  real_T Integrator_f;                 /* '<S5>/Integrator' */\r\n  real_T FlipTire1;                    /* '<S2>/Flip Tire1' */\r\n  real_T FlipTire;                     /* '<S1>/Flip Tire' */\r\n  real_T FlipTire1_n;                  /* '<S1>/Flip Tire1' */\r\n  real_T Gain;                         /* '<S3>/Gain' */\r\n  real_T Sum2;                         /* '<S3>/Sum2' */\r\n  real_T Sum1;                         /* '<S3>/Sum1' */\r\n  real_T FlipTire2;                    /* '<S2>/Flip Tire2' */\r\n  real_T Integrator_e;                 /* '<S7>/Integrator' */\r\n  real_T FlipTire3;                    /* '<S2>/Flip Tire3' */\r\n  real_T Product;                      /* '<S3>/Product' */\r\n  real_T Add;                          /* '<S3>/Add' */\r\n  real_T Product2;                     /* '<S4>/Product2' */\r\n  real_T Add1;                         /* '<S4>/Add1' */\r\n  real_T Abs;                          /* '<S4>/Abs' */\r\n  real_T Add_a;                        /* '<S4>/Add' */\r\n  real_T Saturation1;                  /* '<S4>/Saturation1' */\r\n  real_T Product3;                     /* '<S4>/Product3' */\r\n  real_T Saturation;                   /* '<S4>/Saturation' */\r\n  real_T Product1;                     /* '<S4>/Product1' */\r\n  real_T Product2_p;                   /* '<S5>/Product2' */\r\n  real_T Add1_e;                       /* '<S5>/Add1' */\r\n  real_T Abs_c;                        /* '<S5>/Abs' */\r\n  real_T Add_i;                        /* '<S5>/Add' */\r\n  real_T Saturation1_l;                /* '<S5>/Saturation1' */\r\n  real_T Product3_e;                   /* '<S5>/Product3' */\r\n  real_T Saturation_f;                 /* '<S5>/Saturation' */\r\n  real_T Product1_l;                   /* '<S5>/Product1' */\r\n  real_T Product2_pg;                  /* '<S7>/Product2' */\r\n  real_T Add1_k;                       /* '<S7>/Add1' */\r\n  real_T Abs_f;                        /* '<S7>/Abs' */\r\n  real_T Add_f;                        /* '<S7>/Add' */\r\n  real_T Saturation1_lc;               /* '<S7>/Saturation1' */\r\n  real_T Product3_c;                   /* '<S7>/Product3' */\r\n  real_T Saturation_d;                 /* '<S7>/Saturation' */\r\n  real_T Product1_f;                   /* '<S7>/Product1' */\r\n  real_T Product2_n;                   /* '<S8>/Product2' */\r\n  real_T Add1_ke;                      /* '<S8>/Add1' */\r\n  real_T Abs_k;                        /* '<S8>/Abs' */\r\n  real_T Integrator_k;                 /* '<S8>/Integrator' */\r\n  real_T Add_k;                        /* '<S8>/Add' */\r\n  real_T Saturation1_i;                /* '<S8>/Saturation1' */\r\n  real_T Product3_p;                   /* '<S8>/Product3' */\r\n  real_T Saturation_fn;                /* '<S8>/Saturation' */\r\n  real_T Product1_a;                   /* '<S8>/Product1' */\r\n  real_T TmpSignalConversionAtSFunctionI[27];/* '<S3>/Magic Tire Const Input' */\r\n  real_T Fx;                           /* '<S3>/Magic Tire Const Input' */\r\n  real_T Fy;                           /* '<S3>/Magic Tire Const Input' */\r\n  real_T FzTire;                       /* '<S3>/Magic Tire Const Input' */\r\n  real_T Mx;                           /* '<S3>/Magic Tire Const Input' */\r\n  real_T My;                           /* '<S3>/Magic Tire Const Input' */\r\n  real_T Mz;                           /* '<S3>/Magic Tire Const Input' */\r\n  real_T Re;                           /* '<S3>/Magic Tire Const Input' */\r\n  real_T Kappa;                        /* '<S3>/Magic Tire Const Input' */\r\n  real_T Alpha;                        /* '<S3>/Magic Tire Const Input' */\r\n  real_T sig_x;                        /* '<S3>/Magic Tire Const Input' */\r\n  real_T sig_y;                        /* '<S3>/Magic Tire Const Input' */\r\n  real_T a;                            /* '<S3>/Magic Tire Const Input' */\r\n  real_T b;                            /* '<S3>/Magic Tire Const Input' */\r\n  real_T RL;                           /* '<S3>/Magic Tire Const Input' */\r\n  real_T RadialDeflct;                 /* '<S3>/Magic Tire Const Input' */\r\n  real_T Tw;                           /* '<S3>/Magic Tire Const Input' */\r\n} B;\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  struct {\r\n    void *LoggedData[6];\r\n  } Scope_PWORK;                       /* '<Root>/Scope' */\r\n} DW;\r\n\r\n/* Continuous states (default storage) */\r\ntypedef struct {\r\n  real_T Integrator_CSTATE;            /* '<S4>/Integrator' */\r\n  real_T Integrator_CSTATE_a;          /* '<S5>/Integrator' */\r\n  real_T Integrator_CSTATE_h;          /* '<S7>/Integrator' */\r\n  real_T Integrator_CSTATE_e;          /* '<S8>/Integrator' */\r\n} X;\r\n\r\n/* State derivatives (default storage) */\r\ntypedef struct {\r\n  real_T Integrator_CSTATE;            /* '<S4>/Integrator' */\r\n  real_T Integrator_CSTATE_a;          /* '<S5>/Integrator' */\r\n  real_T Integrator_CSTATE_h;          /* '<S7>/Integrator' */\r\n  real_T Integrator_CSTATE_e;          /* '<S8>/Integrator' */\r\n} XDot;\r\n\r\n/* State disabled  */\r\ntypedef struct {\r\n  boolean_T Integrator_CSTATE;         /* '<S4>/Integrator' */\r\n  boolean_T Integrator_CSTATE_a;       /* '<S5>/Integrator' */\r\n  boolean_T Integrator_CSTATE_h;       /* '<S7>/Integrator' */\r\n  boolean_T Integrator_CSTATE_e;       /* '<S8>/Integrator' */\r\n} XDis;\r\n\r\n/* Parameters (default storage) */\r\nstruct P_ {\r\n  real_T CombinedSlipWheelCPI_ALPMAX;\r\n                                  /* Mask Parameter: CombinedSlipWheelCPI_ALPMAX\r\n                                   * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                   */\r\n  real_T CombinedSlipWheelCPI_ALPMIN;\r\n                                  /* Mask Parameter: CombinedSlipWheelCPI_ALPMIN\r\n                                   * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                   */\r\n  real_T CombinedSlipWheelCPI_ASPECT_RAT;\r\n                              /* Mask Parameter: CombinedSlipWheelCPI_ASPECT_RAT\r\n                               * Referenced by: '<S3>/Magic Tire Const Input'\r\n                               */\r\n  real_T CombinedSlipWheelCPI_BOTTOM_OFF;\r\n                              /* Mask Parameter: CombinedSlipWheelCPI_BOTTOM_OFF\r\n                               * Referenced by: '<S3>/Magic Tire Const Input'\r\n                               */\r\n  real_T CombinedSlipWheelCPI_BOTTOM_STI;\r\n                              /* Mask Parameter: CombinedSlipWheelCPI_BOTTOM_STI\r\n                               * Referenced by: '<S3>/Magic Tire Const Input'\r\n                               */\r\n  real_T CombinedSlipWheelCPI_BREFF;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_BREFF\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_CAMMAX;\r\n                                  /* Mask Parameter: CombinedSlipWheelCPI_CAMMAX\r\n                                   * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                   */\r\n  real_T CombinedSlipWheelCPI_CAMMIN;\r\n                                  /* Mask Parameter: CombinedSlipWheelCPI_CAMMIN\r\n                                   * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                   */\r\n  real_T CombinedSlipWheelCPI_DREFF;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_DREFF\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_FNOMIN;\r\n                                  /* Mask Parameter: CombinedSlipWheelCPI_FNOMIN\r\n                                   * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                   */\r\n  real_T CombinedSlipWheelCPI_FREFF;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_FREFF\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_FZMAX;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_FZMAX\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_FZMIN;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_FZMIN\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_KPUMAX;\r\n                                  /* Mask Parameter: CombinedSlipWheelCPI_KPUMAX\r\n                                   * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                   */\r\n  real_T CombinedSlipWheelCPI_KPUMIN;\r\n                                  /* Mask Parameter: CombinedSlipWheelCPI_KPUMIN\r\n                                   * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                   */\r\n  real_T CombinedSlipWheelCPI_LATERAL_ST;\r\n                              /* Mask Parameter: CombinedSlipWheelCPI_LATERAL_ST\r\n                               * Referenced by: '<S3>/Magic Tire Const Input'\r\n                               */\r\n  real_T CombinedSlipWheelCPI_LONGITUDIN;\r\n                              /* Mask Parameter: CombinedSlipWheelCPI_LONGITUDIN\r\n                               * Referenced by: '<S3>/Magic Tire Const Input'\r\n                               */\r\n  real_T CombinedSlipWheelCPI_LONGVL;\r\n                                  /* Mask Parameter: CombinedSlipWheelCPI_LONGVL\r\n                                   * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                   */\r\n  real_T CombinedSlipWheelCPI_NOMPRES;\r\n                                 /* Mask Parameter: CombinedSlipWheelCPI_NOMPRES\r\n                                  * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                  */\r\n  real_T CombinedSlipWheelCPI_PCFX1;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_PCFX1\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_PCFX2;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_PCFX2\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_PCFX3;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_PCFX3\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_PCFY1;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_PCFY1\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_PCFY2;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_PCFY2\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_PCFY3;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_PCFY3\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_PCX1; /* Mask Parameter: CombinedSlipWheelCPI_PCX1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PCY1; /* Mask Parameter: CombinedSlipWheelCPI_PCY1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PDX1; /* Mask Parameter: CombinedSlipWheelCPI_PDX1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PDX2; /* Mask Parameter: CombinedSlipWheelCPI_PDX2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PDX3; /* Mask Parameter: CombinedSlipWheelCPI_PDX3\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PDXP1;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_PDXP1\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_PDXP2;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_PDXP2\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_PDXP3;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_PDXP3\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_PDY1; /* Mask Parameter: CombinedSlipWheelCPI_PDY1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PDY2; /* Mask Parameter: CombinedSlipWheelCPI_PDY2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PDY3; /* Mask Parameter: CombinedSlipWheelCPI_PDY3\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PDYP1;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_PDYP1\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_PDYP2;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_PDYP2\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_PDYP3;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_PDYP3\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_PDYP4;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_PDYP4\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_PECP1;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_PECP1\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_PECP2;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_PECP2\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_PEX1; /* Mask Parameter: CombinedSlipWheelCPI_PEX1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PEX2; /* Mask Parameter: CombinedSlipWheelCPI_PEX2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PEX3; /* Mask Parameter: CombinedSlipWheelCPI_PEX3\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PEX4; /* Mask Parameter: CombinedSlipWheelCPI_PEX4\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PEY1; /* Mask Parameter: CombinedSlipWheelCPI_PEY1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PEY2; /* Mask Parameter: CombinedSlipWheelCPI_PEY2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PEY3; /* Mask Parameter: CombinedSlipWheelCPI_PEY3\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PEY4; /* Mask Parameter: CombinedSlipWheelCPI_PEY4\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PEY5; /* Mask Parameter: CombinedSlipWheelCPI_PEY5\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PFZ1; /* Mask Parameter: CombinedSlipWheelCPI_PFZ1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PHX1; /* Mask Parameter: CombinedSlipWheelCPI_PHX1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PHX2; /* Mask Parameter: CombinedSlipWheelCPI_PHX2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PHY1; /* Mask Parameter: CombinedSlipWheelCPI_PHY1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PHY2; /* Mask Parameter: CombinedSlipWheelCPI_PHY2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PHYP1;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_PHYP1\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_PHYP2;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_PHYP2\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_PHYP3;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_PHYP3\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_PHYP4;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_PHYP4\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_PKX1; /* Mask Parameter: CombinedSlipWheelCPI_PKX1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PKX2; /* Mask Parameter: CombinedSlipWheelCPI_PKX2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PKX3; /* Mask Parameter: CombinedSlipWheelCPI_PKX3\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PKY1; /* Mask Parameter: CombinedSlipWheelCPI_PKY1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PKY2; /* Mask Parameter: CombinedSlipWheelCPI_PKY2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PKY3; /* Mask Parameter: CombinedSlipWheelCPI_PKY3\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PKY4; /* Mask Parameter: CombinedSlipWheelCPI_PKY4\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PKY5; /* Mask Parameter: CombinedSlipWheelCPI_PKY5\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PKY6; /* Mask Parameter: CombinedSlipWheelCPI_PKY6\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PKY7; /* Mask Parameter: CombinedSlipWheelCPI_PKY7\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PKYP1;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_PKYP1\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_PPMX1;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_PPMX1\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_PPX1; /* Mask Parameter: CombinedSlipWheelCPI_PPX1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PPX2; /* Mask Parameter: CombinedSlipWheelCPI_PPX2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PPX3; /* Mask Parameter: CombinedSlipWheelCPI_PPX3\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PPX4; /* Mask Parameter: CombinedSlipWheelCPI_PPX4\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PPY1; /* Mask Parameter: CombinedSlipWheelCPI_PPY1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PPY2; /* Mask Parameter: CombinedSlipWheelCPI_PPY2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PPY3; /* Mask Parameter: CombinedSlipWheelCPI_PPY3\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PPY4; /* Mask Parameter: CombinedSlipWheelCPI_PPY4\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PPY5; /* Mask Parameter: CombinedSlipWheelCPI_PPY5\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PPZ1; /* Mask Parameter: CombinedSlipWheelCPI_PPZ1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PPZ2; /* Mask Parameter: CombinedSlipWheelCPI_PPZ2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PRESMAX;\r\n                                 /* Mask Parameter: CombinedSlipWheelCPI_PRESMAX\r\n                                  * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                  */\r\n  real_T CombinedSlipWheelCPI_PRESMIN;\r\n                                 /* Mask Parameter: CombinedSlipWheelCPI_PRESMIN\r\n                                  * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                  */\r\n  real_T CombinedSlipWheelCPI_PVX1; /* Mask Parameter: CombinedSlipWheelCPI_PVX1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PVX2; /* Mask Parameter: CombinedSlipWheelCPI_PVX2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PVY1; /* Mask Parameter: CombinedSlipWheelCPI_PVY1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PVY2; /* Mask Parameter: CombinedSlipWheelCPI_PVY2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PVY3; /* Mask Parameter: CombinedSlipWheelCPI_PVY3\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_PVY4; /* Mask Parameter: CombinedSlipWheelCPI_PVY4\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QBRP1;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_QBRP1\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_QBZ1; /* Mask Parameter: CombinedSlipWheelCPI_QBZ1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QBZ10;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_QBZ10\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_QBZ2; /* Mask Parameter: CombinedSlipWheelCPI_QBZ2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QBZ3; /* Mask Parameter: CombinedSlipWheelCPI_QBZ3\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QBZ4; /* Mask Parameter: CombinedSlipWheelCPI_QBZ4\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QBZ5; /* Mask Parameter: CombinedSlipWheelCPI_QBZ5\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QBZ6; /* Mask Parameter: CombinedSlipWheelCPI_QBZ6\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QBZ9; /* Mask Parameter: CombinedSlipWheelCPI_QBZ9\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QCRP1;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_QCRP1\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_QCRP2;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_QCRP2\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_QCZ1; /* Mask Parameter: CombinedSlipWheelCPI_QCZ1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QDRP1;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_QDRP1\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_QDRP2;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_QDRP2\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_QDTP1;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_QDTP1\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_QDZ1; /* Mask Parameter: CombinedSlipWheelCPI_QDZ1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QDZ10;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_QDZ10\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_QDZ11;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_QDZ11\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_QDZ2; /* Mask Parameter: CombinedSlipWheelCPI_QDZ2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QDZ3; /* Mask Parameter: CombinedSlipWheelCPI_QDZ3\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QDZ4; /* Mask Parameter: CombinedSlipWheelCPI_QDZ4\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QDZ6; /* Mask Parameter: CombinedSlipWheelCPI_QDZ6\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QDZ7; /* Mask Parameter: CombinedSlipWheelCPI_QDZ7\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QDZ8; /* Mask Parameter: CombinedSlipWheelCPI_QDZ8\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QDZ9; /* Mask Parameter: CombinedSlipWheelCPI_QDZ9\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QEZ1; /* Mask Parameter: CombinedSlipWheelCPI_QEZ1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QEZ2; /* Mask Parameter: CombinedSlipWheelCPI_QEZ2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QEZ3; /* Mask Parameter: CombinedSlipWheelCPI_QEZ3\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QEZ4; /* Mask Parameter: CombinedSlipWheelCPI_QEZ4\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QEZ5; /* Mask Parameter: CombinedSlipWheelCPI_QEZ5\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QHZ1; /* Mask Parameter: CombinedSlipWheelCPI_QHZ1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QHZ2; /* Mask Parameter: CombinedSlipWheelCPI_QHZ2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QHZ3; /* Mask Parameter: CombinedSlipWheelCPI_QHZ3\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QHZ4; /* Mask Parameter: CombinedSlipWheelCPI_QHZ4\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QSX1; /* Mask Parameter: CombinedSlipWheelCPI_QSX1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QSX10;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_QSX10\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_QSX11;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_QSX11\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_QSX12;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_QSX12\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_QSX13;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_QSX13\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_QSX14;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_QSX14\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_QSX2; /* Mask Parameter: CombinedSlipWheelCPI_QSX2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QSX3; /* Mask Parameter: CombinedSlipWheelCPI_QSX3\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QSX4; /* Mask Parameter: CombinedSlipWheelCPI_QSX4\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QSX5; /* Mask Parameter: CombinedSlipWheelCPI_QSX5\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QSX6; /* Mask Parameter: CombinedSlipWheelCPI_QSX6\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QSX7; /* Mask Parameter: CombinedSlipWheelCPI_QSX7\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QSX8; /* Mask Parameter: CombinedSlipWheelCPI_QSX8\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QSX9; /* Mask Parameter: CombinedSlipWheelCPI_QSX9\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QSY1; /* Mask Parameter: CombinedSlipWheelCPI_QSY1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QSY2; /* Mask Parameter: CombinedSlipWheelCPI_QSY2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QSY3; /* Mask Parameter: CombinedSlipWheelCPI_QSY3\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QSY4; /* Mask Parameter: CombinedSlipWheelCPI_QSY4\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QSY5; /* Mask Parameter: CombinedSlipWheelCPI_QSY5\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QSY6; /* Mask Parameter: CombinedSlipWheelCPI_QSY6\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QSY7; /* Mask Parameter: CombinedSlipWheelCPI_QSY7\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_QSY8; /* Mask Parameter: CombinedSlipWheelCPI_QSY8\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_Q_CAM1;\r\n                                  /* Mask Parameter: CombinedSlipWheelCPI_Q_CAM1\r\n                                   * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                   */\r\n  real_T CombinedSlipWheelCPI_Q_CAM2;\r\n                                  /* Mask Parameter: CombinedSlipWheelCPI_Q_CAM2\r\n                                   * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                   */\r\n  real_T CombinedSlipWheelCPI_Q_CAM3;\r\n                                  /* Mask Parameter: CombinedSlipWheelCPI_Q_CAM3\r\n                                   * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                   */\r\n  real_T CombinedSlipWheelCPI_Q_FCX;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_Q_FCX\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_Q_FCY;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_Q_FCY\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_Q_FCY2;\r\n                                  /* Mask Parameter: CombinedSlipWheelCPI_Q_FCY2\r\n                                   * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                   */\r\n  real_T CombinedSlipWheelCPI_Q_FYS1;\r\n                                  /* Mask Parameter: CombinedSlipWheelCPI_Q_FYS1\r\n                                   * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                   */\r\n  real_T CombinedSlipWheelCPI_Q_FYS2;\r\n                                  /* Mask Parameter: CombinedSlipWheelCPI_Q_FYS2\r\n                                   * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                   */\r\n  real_T CombinedSlipWheelCPI_Q_FYS3;\r\n                                  /* Mask Parameter: CombinedSlipWheelCPI_Q_FYS3\r\n                                   * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                   */\r\n  real_T CombinedSlipWheelCPI_Q_FZ1;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_Q_FZ1\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_Q_FZ2;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_Q_FZ2\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_Q_FZ3;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_Q_FZ3\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_Q_RA1;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_Q_RA1\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_Q_RA2;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_Q_RA2\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_Q_RB1;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_Q_RB1\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_Q_RB2;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_Q_RB2\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_Q_RE0;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_Q_RE0\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_Q_V1; /* Mask Parameter: CombinedSlipWheelCPI_Q_V1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_Q_V2; /* Mask Parameter: CombinedSlipWheelCPI_Q_V2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_RBX1; /* Mask Parameter: CombinedSlipWheelCPI_RBX1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_RBX2; /* Mask Parameter: CombinedSlipWheelCPI_RBX2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_RBX3; /* Mask Parameter: CombinedSlipWheelCPI_RBX3\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_RBY1; /* Mask Parameter: CombinedSlipWheelCPI_RBY1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_RBY2; /* Mask Parameter: CombinedSlipWheelCPI_RBY2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_RBY3; /* Mask Parameter: CombinedSlipWheelCPI_RBY3\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_RBY4; /* Mask Parameter: CombinedSlipWheelCPI_RBY4\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_RCX1; /* Mask Parameter: CombinedSlipWheelCPI_RCX1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_RCY1; /* Mask Parameter: CombinedSlipWheelCPI_RCY1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_REX1; /* Mask Parameter: CombinedSlipWheelCPI_REX1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_REX2; /* Mask Parameter: CombinedSlipWheelCPI_REX2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_REY1; /* Mask Parameter: CombinedSlipWheelCPI_REY1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_REY2; /* Mask Parameter: CombinedSlipWheelCPI_REY2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_RHX1; /* Mask Parameter: CombinedSlipWheelCPI_RHX1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_RHY1; /* Mask Parameter: CombinedSlipWheelCPI_RHY1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_RHY2; /* Mask Parameter: CombinedSlipWheelCPI_RHY2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_RIM_RADIUS;\r\n                              /* Mask Parameter: CombinedSlipWheelCPI_RIM_RADIUS\r\n                               * Referenced by: '<S3>/Magic Tire Const Input'\r\n                               */\r\n  real_T CombinedSlipWheelCPI_RVY1; /* Mask Parameter: CombinedSlipWheelCPI_RVY1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_RVY2; /* Mask Parameter: CombinedSlipWheelCPI_RVY2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_RVY3; /* Mask Parameter: CombinedSlipWheelCPI_RVY3\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_RVY4; /* Mask Parameter: CombinedSlipWheelCPI_RVY4\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_RVY5; /* Mask Parameter: CombinedSlipWheelCPI_RVY5\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_RVY6; /* Mask Parameter: CombinedSlipWheelCPI_RVY6\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_SSZ1; /* Mask Parameter: CombinedSlipWheelCPI_SSZ1\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_SSZ2; /* Mask Parameter: CombinedSlipWheelCPI_SSZ2\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_SSZ3; /* Mask Parameter: CombinedSlipWheelCPI_SSZ3\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_SSZ4; /* Mask Parameter: CombinedSlipWheelCPI_SSZ4\r\n                                     * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                     */\r\n  real_T CombinedSlipWheelCPI_UNLOADED_R;\r\n                              /* Mask Parameter: CombinedSlipWheelCPI_UNLOADED_R\r\n                               * Referenced by: '<S3>/Magic Tire Const Input'\r\n                               */\r\n  real_T CombinedSlipWheelCPI_VERTICAL_S;\r\n                              /* Mask Parameter: CombinedSlipWheelCPI_VERTICAL_S\r\n                               * Referenced by: '<S3>/Magic Tire Const Input'\r\n                               */\r\n  real_T CombinedSlipWheelCPI_VXLOW;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_VXLOW\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_WIDTH;\r\n                                   /* Mask Parameter: CombinedSlipWheelCPI_WIDTH\r\n                                    * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                    */\r\n  real_T CombinedSlipWheelCPI_turnslip;\r\n                                /* Mask Parameter: CombinedSlipWheelCPI_turnslip\r\n                                 * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                 */\r\n  real_T MagicTireConstInput_vdynMF[279];/* Expression: vdynMF\r\n                                          * Referenced by: '<S3>/Magic Tire Const Input'\r\n                                          */\r\n  real_T Integrator_IC;                /* Expression: 0\r\n                                        * Referenced by: '<S4>/Integrator'\r\n                                        */\r\n  real_T Integrator_IC_e;              /* Expression: 0\r\n                                        * Referenced by: '<S5>/Integrator'\r\n                                        */\r\n  real_T FlipTire1_Gain;               /* Expression: FlipTire\r\n                                        * Referenced by: '<S2>/Flip Tire1'\r\n                                        */\r\n  real_T Constant_Value;               /* Expression: 1\r\n                                        * Referenced by: '<Root>/Constant'\r\n                                        */\r\n  real_T Constant1_Value;              /* Expression: 1\r\n                                        * Referenced by: '<Root>/Constant1'\r\n                                        */\r\n  real_T Constant2_Value;              /* Expression: 1\r\n                                        * Referenced by: '<Root>/Constant2'\r\n                                        */\r\n  real_T FlipTire_Gain;                /* Expression: FlipTire\r\n                                        * Referenced by: '<S1>/Flip Tire'\r\n                                        */\r\n  real_T Constant4_Value;              /* Expression: 1\r\n                                        * Referenced by: '<Root>/Constant4'\r\n                                        */\r\n  real_T Constant3_Value;              /* Expression: 1\r\n                                        * Referenced by: '<Root>/Constant3'\r\n                                        */\r\n  real_T FlipTire1_Gain_g;             /* Expression: FlipTire\r\n                                        * Referenced by: '<S1>/Flip Tire1'\r\n                                        */\r\n  real_T Constant7_Value;              /* Expression: 1\r\n                                        * Referenced by: '<Root>/Constant7'\r\n                                        */\r\n  real_T RadialDeflctConstant_Value;   /* Expression: 0\r\n                                        * Referenced by: '<S1>/RadialDeflctConstant'\r\n                                        */\r\n  real_T Gain_Gain;                    /* Expression: 0\r\n                                        * Referenced by: '<S3>/Gain'\r\n                                        */\r\n  real_T Constant5_Value;              /* Expression: 1\r\n                                        * Referenced by: '<Root>/Constant5'\r\n                                        */\r\n  real_T vertType_Value;               /* Expression: 1\r\n                                        * Referenced by: '<S1>/vertType'\r\n                                        */\r\n  real_T FlipTire2_Gain;               /* Expression: FlipTire\r\n                                        * Referenced by: '<S2>/Flip Tire2'\r\n                                        */\r\n  real_T Integrator_IC_j;              /* Expression: 0\r\n                                        * Referenced by: '<S7>/Integrator'\r\n                                        */\r\n  real_T FlipTire3_Gain;               /* Expression: FlipTire\r\n                                        * Referenced by: '<S2>/Flip Tire3'\r\n                                        */\r\n  real_T Saturation1_UpperSat;         /* Expression: inf\r\n                                        * Referenced by: '<S4>/Saturation1'\r\n                                        */\r\n  real_T Saturation1_LowerSat;         /* Expression: 1e-2\r\n                                        * Referenced by: '<S4>/Saturation1'\r\n                                        */\r\n  real_T Saturation_UpperSat;          /* Expression: inf\r\n                                        * Referenced by: '<S4>/Saturation'\r\n                                        */\r\n  real_T Saturation_LowerSat;          /* Expression: FxRelFreqLwrLim\r\n                                        * Referenced by: '<S4>/Saturation'\r\n                                        */\r\n  real_T Saturation1_UpperSat_d;       /* Expression: inf\r\n                                        * Referenced by: '<S5>/Saturation1'\r\n                                        */\r\n  real_T Saturation1_LowerSat_l;       /* Expression: 1e-2\r\n                                        * Referenced by: '<S5>/Saturation1'\r\n                                        */\r\n  real_T Saturation_UpperSat_f;        /* Expression: inf\r\n                                        * Referenced by: '<S5>/Saturation'\r\n                                        */\r\n  real_T Saturation_LowerSat_f;        /* Expression: FyRelFreqLwrLim\r\n                                        * Referenced by: '<S5>/Saturation'\r\n                                        */\r\n  real_T Saturation1_UpperSat_n;       /* Expression: inf\r\n                                        * Referenced by: '<S7>/Saturation1'\r\n                                        */\r\n  real_T Saturation1_LowerSat_c;       /* Expression: 1e-2\r\n                                        * Referenced by: '<S7>/Saturation1'\r\n                                        */\r\n  real_T Saturation_UpperSat_k;        /* Expression: inf\r\n                                        * Referenced by: '<S7>/Saturation'\r\n                                        */\r\n  real_T Saturation_LowerSat_d;        /* Expression: MyRelFreqLwrLim\r\n                                        * Referenced by: '<S7>/Saturation'\r\n                                        */\r\n  real_T Integrator_IC_i;              /* Expression: 0\r\n                                        * Referenced by: '<S8>/Integrator'\r\n                                        */\r\n  real_T Saturation1_UpperSat_b;       /* Expression: inf\r\n                                        * Referenced by: '<S8>/Saturation1'\r\n                                        */\r\n  real_T Saturation1_LowerSat_h;       /* Expression: 1e-2\r\n                                        * Referenced by: '<S8>/Saturation1'\r\n                                        */\r\n  real_T Saturation_UpperSat_fp;       /* Expression: inf\r\n                                        * Referenced by: '<S8>/Saturation'\r\n                                        */\r\n  real_T Saturation_LowerSat_h;        /* Expression: MyRelFreqLwrLim\r\n                                        * Referenced by: '<S8>/Saturation'\r\n                                        */\r\n};\r\n\r\n/* External data declarations for dependent source files */\r\nextern const char_T *RT_MEMORY_ALLOCATION_ERROR;\r\nextern B rtB;                          /* block i/o */\r\nextern X rtX;                          /* states (continuous) */\r\nextern DW rtDW;                        /* states (dwork) */\r\nextern P rtP;                          /* parameters */\r\n\r\n/* Simulation Structure */\r\nextern SimStruct *const rtS;\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<S2>/Flip Tire4' : Unused code path elimination\r\n * Block '<S2>/Flip Tire5' : Unused code path elimination\r\n * Block '<S3>/Selector' : Unused code path elimination\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'main'\r\n * '<S1>'   : 'main/Combined Slip Wheel CPI'\r\n * '<S2>'   : 'main/Combined Slip Wheel CPI/Bus Routing'\r\n * '<S3>'   : 'main/Combined Slip Wheel CPI/Magic Tire Const Input'\r\n * '<S4>'   : 'main/Combined Slip Wheel CPI/Magic Tire Const Input/Fx Relaxation'\r\n * '<S5>'   : 'main/Combined Slip Wheel CPI/Magic Tire Const Input/Fy Relaxation'\r\n * '<S6>'   : 'main/Combined Slip Wheel CPI/Magic Tire Const Input/Magic Tire Const Input'\r\n * '<S7>'   : 'main/Combined Slip Wheel CPI/Magic Tire Const Input/My Relaxation'\r\n * '<S8>'   : 'main/Combined Slip Wheel CPI/Magic Tire Const Input/WhlTrq Relaxation'\r\n */\r\n\r\n/* user code (bottom of header file) */\r\nextern const int_T gblNumToFiles;\r\nextern const int_T gblNumFrFiles;\r\nextern const int_T gblNumFrWksBlocks;\r\nextern rtInportTUtable *gblInportTUtables;\r\nextern const char *gblInportFileName;\r\nextern const int_T gblNumRootInportBlks;\r\nextern const int_T gblNumModelInputs;\r\nextern const int_T gblInportDataTypeIdx[];\r\nextern const int_T gblInportDims[];\r\nextern const int_T gblInportComplex[];\r\nextern const int_T gblInportInterpoFlag[];\r\nextern const int_T gblInportContinuous[];\r\n\r\n#endif                                 /* main_h_ */\r\n"},{"name":"main_private.h","type":"header","group":"model","path":"C:\\Users\\liam0\\OneDrive\\Desktop\\main_rsim_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * main_private.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"main\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Thu Oct 10 10:35:59 2024\r\n *\r\n * Target selection: rsim.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef main_private_h_\r\n#define main_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"builtin_typeid_types.h\"\r\n#include \"multiword_types.h\"\r\n#include \"main_types.h\"\r\n#if !defined(rt_VALIDATE_MEMORY)\r\n#define rt_VALIDATE_MEMORY(S, ptr)     if(!(ptr)) {\\\r\n ssSetErrorStatus(rtS, RT_MEMORY_ALLOCATION_ERROR);\\\r\n }\r\n#endif\r\n\r\n#if !defined(rt_FREE)\r\n#if !defined(_WIN32)\r\n#define rt_FREE(ptr)                   if((ptr) != (NULL)) {\\\r\n free((ptr));\\\r\n (ptr) = (NULL);\\\r\n }\r\n#else\r\n\r\n/* Visual and other windows compilers declare free without const */\r\n#define rt_FREE(ptr)                   if((ptr) != (NULL)) {\\\r\n free((void *)(ptr));\\\r\n (ptr) = (NULL);\\\r\n }\r\n#endif\r\n#endif\r\n\r\nextern real_T rt_powd_snf(real_T u0, real_T u1);\r\nextern real_T rt_atan2d_snf(real_T u0, real_T u1);\r\n\r\n#if defined(MULTITASKING)\r\n#  error Model (main) was built in \\\r\nSingleTasking solver mode, however the MULTITASKING define is \\\r\npresent. If you have multitasking (e.g. -DMT or -DMULTITASKING) \\\r\ndefined on the Code Generation page of Simulation parameter dialog, please \\\r\nremove it and on the Solver page, select solver mode \\\r\nMultiTasking. If the Simulation parameter dialog is configured \\\r\ncorrectly, please verify that your template makefile is \\\r\nconfigured correctly.\r\n#endif\r\n#endif                                 /* main_private_h_ */\r\n"},{"name":"main_types.h","type":"header","group":"model","path":"C:\\Users\\liam0\\OneDrive\\Desktop\\main_rsim_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * main_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"main\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Thu Oct 10 10:35:59 2024\r\n *\r\n * Target selection: rsim.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef main_types_h_\r\n#define main_types_h_\r\n#ifndef SS_UINT64\r\n#define SS_UINT64                      17\r\n#endif\r\n\r\n#ifndef SS_INT64\r\n#define SS_INT64                       18\r\n#endif\r\n\r\n/* Parameters (default storage) */\r\ntypedef struct P_ P;\r\n\r\n#endif                                 /* main_types_h_ */\r\n"},{"name":"main_data.c","type":"source","group":"data","path":"C:\\Users\\liam0\\OneDrive\\Desktop\\main_rsim_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * main_data.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"main\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Thu Oct 10 10:35:59 2024\r\n *\r\n * Target selection: rsim.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"main.h\"\r\n\r\n/* Block parameters (default storage) */\r\nP rtP = {\r\n  /* Mask Parameter: CombinedSlipWheelCPI_ALPMAX\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.523599,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_ALPMIN\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -0.523599,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_ASPECT_RAT\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.388,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_BOTTOM_OFF\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.01,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_BOTTOM_STI\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  2.93478E+6,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_BREFF\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  1.67769,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_CAMMAX\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.087266,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_CAMMIN\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -0.087266,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_DREFF\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.105132,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_FNOMIN\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  3112.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_FREFF\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0763774,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_FZMAX\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  8000.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_FZMIN\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  100.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_KPUMAX\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  1.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_KPUMIN\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -1.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_LATERAL_ST\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_LONGITUDIN\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_LONGVL\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  66.9666,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_NOMPRES\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  200573.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PCFX1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PCFX2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PCFX3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PCFY1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PCFY2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PCFY3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PCX1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  1.66628,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PCY1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  1.5496,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PDX1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  1.72645,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PDX2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -0.278479,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PDX3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  6.54553,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PDXP1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PDXP2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PDXP3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PDY1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  1.70839,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PDY2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -0.354062,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PDY3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  3.35762,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PDYP1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PDYP2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PDYP3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PDYP4\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PECP1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PECP2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PEX1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -5.04761E-6,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PEX2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.463966,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PEX3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -0.0359398,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PEX4\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.38592,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PEY1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -1.98642,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PEY2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -1.62092,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PEY3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.408939,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PEY4\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -4.08114,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PEY5\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  5.64917,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PFZ1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.896152,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PHX1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.00060979,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PHX2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -0.000659181,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PHY1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.00234094,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PHY2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.00326645,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PHYP1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PHYP2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PHYP3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PHYP4\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PKX1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  64.6315,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PKX2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -0.95099,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PKX3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.015721,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PKY1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -53.0946,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PKY2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  2.23333,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PKY3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.872111,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PKY4\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  2.10492,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PKY5\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.95099,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PKY6\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -2.40799,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PKY7\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -2.70746,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PKYP1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PPMX1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -0.192994,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PPX1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PPX2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PPX3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PPX4\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PPY1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.716732,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PPY2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  1.64013,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PPY3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -0.0572745,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PPY4\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -0.543181,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PPY5\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -0.996956,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PPZ1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  1.09916,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PPZ2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.41332,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PRESMAX\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  214409.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PRESMIN\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  172715.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PVX1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -0.0560991,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PVX2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0646569,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PVY1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -0.0625501,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PVY2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0628882,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PVY3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.50157,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_PVY4\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -1.80795,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QBRP1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QBZ1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  9.58435,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QBZ10\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0106191,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QBZ2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -0.320338,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QBZ3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.117051,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QBZ4\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  1.88053,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QBZ5\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  1.52129,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QBZ6\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QBZ9\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QCRP1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QCRP2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QCZ1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  1.24211,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QDRP1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QDRP2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QDTP1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QDZ1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.109243,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QDZ10\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  5.75951,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QDZ11\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -1.59703,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QDZ2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.00324279,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QDZ3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -0.956087,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QDZ4\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -18.9248,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QDZ6\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -0.00999806,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QDZ7\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -0.0136136,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QDZ8\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -1.5519,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QDZ9\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.392793,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QEZ1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -6.82198,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QEZ2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.891157,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QEZ3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  1.23965,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QEZ4\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -0.621374,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QEZ5\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -3.45744,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QHZ1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -0.0088485,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QHZ2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.00259685,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QHZ3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0518341,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QHZ4\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0782043,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QSX1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -0.00469662,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QSX10\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -2.94964,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QSX11\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  13.9701,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QSX12\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QSX13\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QSX14\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QSX2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -5.13093,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QSX3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.117227,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QSX4\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.764013,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QSX5\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -0.569854,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QSX6\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -3.0208,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QSX7\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -4.74982,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QSX8\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -5.9049,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QSX9\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0425242,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QSY1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0291029,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QSY2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QSY3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0106797,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QSY4\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.00150037,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QSY5\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QSY6\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QSY7\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.293107,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_QSY8\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -1.27727,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_Q_CAM1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_Q_CAM2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_Q_CAM3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_Q_FCX\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.147144,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_Q_FCY\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.171698,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_Q_FCY2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_Q_FYS1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_Q_FYS2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_Q_FYS3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_Q_FZ1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  28.1283,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_Q_FZ2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  2.78052,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_Q_FZ3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_Q_RA1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.602,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_Q_RA2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  1.024,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_Q_RB1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  1.1137,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_Q_RB2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -0.09748,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_Q_RE0\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.994334,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_Q_V1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.00542853,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_Q_V2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0867414,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_RBX1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  23.0974,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_RBX2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -22.9129,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_RBX3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -0.5445,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_RBY1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  29.6888,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_RBY2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  17.9759,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_RBY3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -0.00317577,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_RBY4\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.229929,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_RCX1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  1.05471,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_RCY1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.993821,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_REX1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  3.97084E-8,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_REX2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  5.73425E-9,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_REY1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -0.00271301,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_REY2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0831273,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_RHX1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.00655663,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_RHY1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.00988171,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_RHY2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.00695088,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_RIM_RADIUS\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.1905,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_RVY1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.042693,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_RVY2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0364021,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_RVY3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.284909,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_RVY4\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  20.1816,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_RVY5\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -2.79814,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_RVY6\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -20.8171,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_SSZ1\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -0.0916292,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_SSZ2\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.0115969,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_SSZ3\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  1.69749,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_SSZ4\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  -1.7076,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_UNLOADED_R\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.3004,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_VERTICAL_S\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  293478.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_VXLOW\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  1.0,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_WIDTH\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  0.283464,\r\n\r\n  /* Mask Parameter: CombinedSlipWheelCPI_turnslip\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: vdynMF\r\n   * Referenced by: '<S3>/Magic Tire Const Input'\r\n   */\r\n  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S4>/Integrator'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S5>/Integrator'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: FlipTire\r\n   * Referenced by: '<S2>/Flip Tire1'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<Root>/Constant'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<Root>/Constant1'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<Root>/Constant2'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: FlipTire\r\n   * Referenced by: '<S1>/Flip Tire'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<Root>/Constant4'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<Root>/Constant3'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: FlipTire\r\n   * Referenced by: '<S1>/Flip Tire1'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<Root>/Constant7'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S1>/RadialDeflctConstant'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S3>/Gain'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<Root>/Constant5'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<S1>/vertType'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: FlipTire\r\n   * Referenced by: '<S2>/Flip Tire2'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S7>/Integrator'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: FlipTire\r\n   * Referenced by: '<S2>/Flip Tire3'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: inf\r\n   * Referenced by: '<S4>/Saturation1'\r\n   */\r\n  INFINITY,\r\n\r\n  /* Expression: 1e-2\r\n   * Referenced by: '<S4>/Saturation1'\r\n   */\r\n  0.01,\r\n\r\n  /* Expression: inf\r\n   * Referenced by: '<S4>/Saturation'\r\n   */\r\n  INFINITY,\r\n\r\n  /* Expression: FxRelFreqLwrLim\r\n   * Referenced by: '<S4>/Saturation'\r\n   */\r\n  314.15926535897933,\r\n\r\n  /* Expression: inf\r\n   * Referenced by: '<S5>/Saturation1'\r\n   */\r\n  INFINITY,\r\n\r\n  /* Expression: 1e-2\r\n   * Referenced by: '<S5>/Saturation1'\r\n   */\r\n  0.01,\r\n\r\n  /* Expression: inf\r\n   * Referenced by: '<S5>/Saturation'\r\n   */\r\n  INFINITY,\r\n\r\n  /* Expression: FyRelFreqLwrLim\r\n   * Referenced by: '<S5>/Saturation'\r\n   */\r\n  628.31853071795865,\r\n\r\n  /* Expression: inf\r\n   * Referenced by: '<S7>/Saturation1'\r\n   */\r\n  INFINITY,\r\n\r\n  /* Expression: 1e-2\r\n   * Referenced by: '<S7>/Saturation1'\r\n   */\r\n  0.01,\r\n\r\n  /* Expression: inf\r\n   * Referenced by: '<S7>/Saturation'\r\n   */\r\n  INFINITY,\r\n\r\n  /* Expression: MyRelFreqLwrLim\r\n   * Referenced by: '<S7>/Saturation'\r\n   */\r\n  628.31853071795865,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S8>/Integrator'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: inf\r\n   * Referenced by: '<S8>/Saturation1'\r\n   */\r\n  INFINITY,\r\n\r\n  /* Expression: 1e-2\r\n   * Referenced by: '<S8>/Saturation1'\r\n   */\r\n  0.01,\r\n\r\n  /* Expression: inf\r\n   * Referenced by: '<S8>/Saturation'\r\n   */\r\n  INFINITY,\r\n\r\n  /* Expression: MyRelFreqLwrLim\r\n   * Referenced by: '<S8>/Saturation'\r\n   */\r\n  628.31853071795865\r\n};\r\n"},{"name":"builtin_typeid_types.h","type":"header","group":"utility","path":"C:\\Users\\liam0\\OneDrive\\Desktop\\main_rsim_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * builtin_typeid_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"main\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Thu Oct 10 10:35:59 2024\r\n *\r\n * Target selection: rsim.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef BUILTIN_TYPEID_TYPES_H\r\n#define BUILTIN_TYPEID_TYPES_H\r\n#ifndef BUILTIN_TYPEID_TYPES\r\n#define BUILTIN_TYPEID_TYPES\r\n\r\n/* Enumeration of built-in data types */\r\ntypedef enum {\r\n  SS_DOUBLE = 0,\r\n  SS_SINGLE = 1,\r\n  SS_INT8 = 2,\r\n  SS_UINT8 = 3,\r\n  SS_INT16 = 4,\r\n  SS_UINT16 = 5,\r\n  SS_INT32 = 6,\r\n  SS_UINT32 = 7,\r\n  SS_BOOLEAN = 8\r\n} BuiltInDTypeId;\r\n\r\n#define SS_NUM_BUILT_IN_DTYPE          ((int)SS_BOOLEAN+1)\r\n\r\n/* Enumeration for MAT-file logging code */\r\ntypedef int DTypeId;\r\n\r\n/* Enumeration of pre-defined data types */\r\ntypedef enum {\r\n  SS_FCN_CALL = 9,\r\n  SS_INTEGER = 10,\r\n  SS_POINTER = 11,\r\n  SS_INTERNAL_DTYPE2 = 12,\r\n  SS_TIMER_UINT32_PAIR = 13,\r\n  SS_CONNECTION_TYPE = 14\r\n} PreDefinedDTypeId;\r\n\r\n#endif                                 /* BUILTIN_TYPEID_TYPES */\r\n#endif                                 /* BUILTIN_TYPEID_TYPES_H */\r\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"C:\\Users\\liam0\\OneDrive\\Desktop\\main_rsim_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * multiword_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"main\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Thu Oct 10 10:35:59 2024\r\n *\r\n * Target selection: rsim.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef MULTIWORD_TYPES_H\r\n#define MULTIWORD_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/*\r\n * Definitions supporting external data access\r\n */\r\ntypedef int64_T chunk_T;\r\ntypedef uint64_T uchunk_T;\r\n\r\n/*\r\n * MultiWord supporting definitions\r\n */\r\ntypedef long long longlong_T;\r\n\r\n/*\r\n * MultiWord types\r\n */\r\ntypedef struct {\r\n  uint64_T chunks[2];\r\n} int128m_T;\r\n\r\ntypedef struct {\r\n  int128m_T re;\r\n  int128m_T im;\r\n} cint128m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[2];\r\n} uint128m_T;\r\n\r\ntypedef struct {\r\n  uint128m_T re;\r\n  uint128m_T im;\r\n} cuint128m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[3];\r\n} int192m_T;\r\n\r\ntypedef struct {\r\n  int192m_T re;\r\n  int192m_T im;\r\n} cint192m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[3];\r\n} uint192m_T;\r\n\r\ntypedef struct {\r\n  uint192m_T re;\r\n  uint192m_T im;\r\n} cuint192m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[4];\r\n} int256m_T;\r\n\r\ntypedef struct {\r\n  int256m_T re;\r\n  int256m_T im;\r\n} cint256m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[4];\r\n} uint256m_T;\r\n\r\ntypedef struct {\r\n  uint256m_T re;\r\n  uint256m_T im;\r\n} cuint256m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[5];\r\n} int320m_T;\r\n\r\ntypedef struct {\r\n  int320m_T re;\r\n  int320m_T im;\r\n} cint320m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[5];\r\n} uint320m_T;\r\n\r\ntypedef struct {\r\n  uint320m_T re;\r\n  uint320m_T im;\r\n} cuint320m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[6];\r\n} int384m_T;\r\n\r\ntypedef struct {\r\n  int384m_T re;\r\n  int384m_T im;\r\n} cint384m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[6];\r\n} uint384m_T;\r\n\r\ntypedef struct {\r\n  uint384m_T re;\r\n  uint384m_T im;\r\n} cuint384m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[7];\r\n} int448m_T;\r\n\r\ntypedef struct {\r\n  int448m_T re;\r\n  int448m_T im;\r\n} cint448m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[7];\r\n} uint448m_T;\r\n\r\ntypedef struct {\r\n  uint448m_T re;\r\n  uint448m_T im;\r\n} cuint448m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[8];\r\n} int512m_T;\r\n\r\ntypedef struct {\r\n  int512m_T re;\r\n  int512m_T im;\r\n} cint512m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[8];\r\n} uint512m_T;\r\n\r\ntypedef struct {\r\n  uint512m_T re;\r\n  uint512m_T im;\r\n} cuint512m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[9];\r\n} int576m_T;\r\n\r\ntypedef struct {\r\n  int576m_T re;\r\n  int576m_T im;\r\n} cint576m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[9];\r\n} uint576m_T;\r\n\r\ntypedef struct {\r\n  uint576m_T re;\r\n  uint576m_T im;\r\n} cuint576m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[10];\r\n} int640m_T;\r\n\r\ntypedef struct {\r\n  int640m_T re;\r\n  int640m_T im;\r\n} cint640m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[10];\r\n} uint640m_T;\r\n\r\ntypedef struct {\r\n  uint640m_T re;\r\n  uint640m_T im;\r\n} cuint640m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[11];\r\n} int704m_T;\r\n\r\ntypedef struct {\r\n  int704m_T re;\r\n  int704m_T im;\r\n} cint704m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[11];\r\n} uint704m_T;\r\n\r\ntypedef struct {\r\n  uint704m_T re;\r\n  uint704m_T im;\r\n} cuint704m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[12];\r\n} int768m_T;\r\n\r\ntypedef struct {\r\n  int768m_T re;\r\n  int768m_T im;\r\n} cint768m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[12];\r\n} uint768m_T;\r\n\r\ntypedef struct {\r\n  uint768m_T re;\r\n  uint768m_T im;\r\n} cuint768m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[13];\r\n} int832m_T;\r\n\r\ntypedef struct {\r\n  int832m_T re;\r\n  int832m_T im;\r\n} cint832m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[13];\r\n} uint832m_T;\r\n\r\ntypedef struct {\r\n  uint832m_T re;\r\n  uint832m_T im;\r\n} cuint832m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[14];\r\n} int896m_T;\r\n\r\ntypedef struct {\r\n  int896m_T re;\r\n  int896m_T im;\r\n} cint896m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[14];\r\n} uint896m_T;\r\n\r\ntypedef struct {\r\n  uint896m_T re;\r\n  uint896m_T im;\r\n} cuint896m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[15];\r\n} int960m_T;\r\n\r\ntypedef struct {\r\n  int960m_T re;\r\n  int960m_T im;\r\n} cint960m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[15];\r\n} uint960m_T;\r\n\r\ntypedef struct {\r\n  uint960m_T re;\r\n  uint960m_T im;\r\n} cuint960m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[16];\r\n} int1024m_T;\r\n\r\ntypedef struct {\r\n  int1024m_T re;\r\n  int1024m_T im;\r\n} cint1024m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[16];\r\n} uint1024m_T;\r\n\r\ntypedef struct {\r\n  uint1024m_T re;\r\n  uint1024m_T im;\r\n} cuint1024m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[17];\r\n} int1088m_T;\r\n\r\ntypedef struct {\r\n  int1088m_T re;\r\n  int1088m_T im;\r\n} cint1088m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[17];\r\n} uint1088m_T;\r\n\r\ntypedef struct {\r\n  uint1088m_T re;\r\n  uint1088m_T im;\r\n} cuint1088m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[18];\r\n} int1152m_T;\r\n\r\ntypedef struct {\r\n  int1152m_T re;\r\n  int1152m_T im;\r\n} cint1152m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[18];\r\n} uint1152m_T;\r\n\r\ntypedef struct {\r\n  uint1152m_T re;\r\n  uint1152m_T im;\r\n} cuint1152m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[19];\r\n} int1216m_T;\r\n\r\ntypedef struct {\r\n  int1216m_T re;\r\n  int1216m_T im;\r\n} cint1216m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[19];\r\n} uint1216m_T;\r\n\r\ntypedef struct {\r\n  uint1216m_T re;\r\n  uint1216m_T im;\r\n} cuint1216m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[20];\r\n} int1280m_T;\r\n\r\ntypedef struct {\r\n  int1280m_T re;\r\n  int1280m_T im;\r\n} cint1280m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[20];\r\n} uint1280m_T;\r\n\r\ntypedef struct {\r\n  uint1280m_T re;\r\n  uint1280m_T im;\r\n} cuint1280m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[21];\r\n} int1344m_T;\r\n\r\ntypedef struct {\r\n  int1344m_T re;\r\n  int1344m_T im;\r\n} cint1344m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[21];\r\n} uint1344m_T;\r\n\r\ntypedef struct {\r\n  uint1344m_T re;\r\n  uint1344m_T im;\r\n} cuint1344m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[22];\r\n} int1408m_T;\r\n\r\ntypedef struct {\r\n  int1408m_T re;\r\n  int1408m_T im;\r\n} cint1408m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[22];\r\n} uint1408m_T;\r\n\r\ntypedef struct {\r\n  uint1408m_T re;\r\n  uint1408m_T im;\r\n} cuint1408m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[23];\r\n} int1472m_T;\r\n\r\ntypedef struct {\r\n  int1472m_T re;\r\n  int1472m_T im;\r\n} cint1472m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[23];\r\n} uint1472m_T;\r\n\r\ntypedef struct {\r\n  uint1472m_T re;\r\n  uint1472m_T im;\r\n} cuint1472m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[24];\r\n} int1536m_T;\r\n\r\ntypedef struct {\r\n  int1536m_T re;\r\n  int1536m_T im;\r\n} cint1536m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[24];\r\n} uint1536m_T;\r\n\r\ntypedef struct {\r\n  uint1536m_T re;\r\n  uint1536m_T im;\r\n} cuint1536m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[25];\r\n} int1600m_T;\r\n\r\ntypedef struct {\r\n  int1600m_T re;\r\n  int1600m_T im;\r\n} cint1600m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[25];\r\n} uint1600m_T;\r\n\r\ntypedef struct {\r\n  uint1600m_T re;\r\n  uint1600m_T im;\r\n} cuint1600m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[26];\r\n} int1664m_T;\r\n\r\ntypedef struct {\r\n  int1664m_T re;\r\n  int1664m_T im;\r\n} cint1664m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[26];\r\n} uint1664m_T;\r\n\r\ntypedef struct {\r\n  uint1664m_T re;\r\n  uint1664m_T im;\r\n} cuint1664m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[27];\r\n} int1728m_T;\r\n\r\ntypedef struct {\r\n  int1728m_T re;\r\n  int1728m_T im;\r\n} cint1728m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[27];\r\n} uint1728m_T;\r\n\r\ntypedef struct {\r\n  uint1728m_T re;\r\n  uint1728m_T im;\r\n} cuint1728m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[28];\r\n} int1792m_T;\r\n\r\ntypedef struct {\r\n  int1792m_T re;\r\n  int1792m_T im;\r\n} cint1792m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[28];\r\n} uint1792m_T;\r\n\r\ntypedef struct {\r\n  uint1792m_T re;\r\n  uint1792m_T im;\r\n} cuint1792m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[29];\r\n} int1856m_T;\r\n\r\ntypedef struct {\r\n  int1856m_T re;\r\n  int1856m_T im;\r\n} cint1856m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[29];\r\n} uint1856m_T;\r\n\r\ntypedef struct {\r\n  uint1856m_T re;\r\n  uint1856m_T im;\r\n} cuint1856m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[30];\r\n} int1920m_T;\r\n\r\ntypedef struct {\r\n  int1920m_T re;\r\n  int1920m_T im;\r\n} cint1920m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[30];\r\n} uint1920m_T;\r\n\r\ntypedef struct {\r\n  uint1920m_T re;\r\n  uint1920m_T im;\r\n} cuint1920m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[31];\r\n} int1984m_T;\r\n\r\ntypedef struct {\r\n  int1984m_T re;\r\n  int1984m_T im;\r\n} cint1984m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[31];\r\n} uint1984m_T;\r\n\r\ntypedef struct {\r\n  uint1984m_T re;\r\n  uint1984m_T im;\r\n} cuint1984m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[32];\r\n} int2048m_T;\r\n\r\ntypedef struct {\r\n  int2048m_T re;\r\n  int2048m_T im;\r\n} cint2048m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[32];\r\n} uint2048m_T;\r\n\r\ntypedef struct {\r\n  uint2048m_T re;\r\n  uint2048m_T im;\r\n} cuint2048m_T;\r\n\r\n#endif                                 /* MULTIWORD_TYPES_H */\r\n"},{"name":"rtGetInf.c","type":"source","group":"utility","path":"C:\\Users\\liam0\\OneDrive\\Desktop\\main_rsim_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetInf.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"main\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Thu Oct 10 10:35:59 2024\r\n *\r\n * Target selection: rsim.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetInf.h\"\r\n\r\n/* Return rtInf needed by the generated code. */\r\nreal_T rtGetInf(void)\r\n{\r\n  return rtInf;\r\n}\r\n\r\n/* Get rtInfF needed by the generated code. */\r\nreal32_T rtGetInfF(void)\r\n{\r\n  return rtInfF;\r\n}\r\n\r\n/* Return rtMinusInf needed by the generated code. */\r\nreal_T rtGetMinusInf(void)\r\n{\r\n  return rtMinusInf;\r\n}\r\n\r\n/* Return rtMinusInfF needed by the generated code. */\r\nreal32_T rtGetMinusInfF(void)\r\n{\r\n  return rtMinusInfF;\r\n}\r\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"C:\\Users\\liam0\\OneDrive\\Desktop\\main_rsim_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetInf.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"main\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Thu Oct 10 10:35:59 2024\r\n *\r\n * Target selection: rsim.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef rtGetInf_h_\r\n#define rtGetInf_h_\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetInf(void);\r\nextern real32_T rtGetInfF(void);\r\nextern real_T rtGetMinusInf(void);\r\nextern real32_T rtGetMinusInfF(void);\r\n\r\n#endif                                 /* rtGetInf_h_ */\r\n"},{"name":"rtGetNaN.c","type":"source","group":"utility","path":"C:\\Users\\liam0\\OneDrive\\Desktop\\main_rsim_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetNaN.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"main\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Thu Oct 10 10:35:59 2024\r\n *\r\n * Target selection: rsim.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetNaN.h\"\r\n\r\n/* Return rtNaN needed by the generated code. */\r\nreal_T rtGetNaN(void)\r\n{\r\n  return rtNaN;\r\n}\r\n\r\n/* Return rtNaNF needed by the generated code. */\r\nreal32_T rtGetNaNF(void)\r\n{\r\n  return rtNaNF;\r\n}\r\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"C:\\Users\\liam0\\OneDrive\\Desktop\\main_rsim_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetNaN.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"main\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Thu Oct 10 10:35:59 2024\r\n *\r\n * Target selection: rsim.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef rtGetNaN_h_\r\n#define rtGetNaN_h_\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetNaN(void);\r\nextern real32_T rtGetNaNF(void);\r\n\r\n#endif                                 /* rtGetNaN_h_ */\r\n"},{"name":"rt_defines.h","type":"header","group":"utility","path":"C:\\Users\\liam0\\OneDrive\\Desktop\\main_rsim_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rt_defines.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"main\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Thu Oct 10 10:35:59 2024\r\n *\r\n * Target selection: rsim.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef rt_defines_h_\r\n#define rt_defines_h_\r\n\r\n/*===========*\r\n * Constants *\r\n *===========*/\r\n#define RT_PI                          3.14159265358979323846\r\n#define RT_PIF                         3.1415927F\r\n#define RT_LN_10                       2.30258509299404568402\r\n#define RT_LN_10F                      2.3025851F\r\n#define RT_LOG10E                      0.43429448190325182765\r\n#define RT_LOG10EF                     0.43429449F\r\n#define RT_E                           2.7182818284590452354\r\n#define RT_EF                          2.7182817F\r\n\r\n/*\r\n * UNUSED_PARAMETER(x)\r\n *   Used to specify that a function parameter (argument) is required but not\r\n *   accessed by the function body.\r\n */\r\n#ifndef UNUSED_PARAMETER\r\n#if defined(__LCC__)\r\n#define UNUSED_PARAMETER(x)                                      /* do nothing */\r\n#else\r\n\r\n/*\r\n * This is the semi-ANSI standard way of indicating that an\r\n * unused function parameter is required.\r\n */\r\n#define UNUSED_PARAMETER(x)            (void) (x)\r\n#endif\r\n#endif\r\n#endif                                 /* rt_defines_h_ */\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"C:\\Users\\liam0\\OneDrive\\Desktop\\main_rsim_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rt_nonfinite.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"main\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Thu Oct 10 10:35:59 2024\r\n *\r\n * Target selection: rsim.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"math.h\"\r\n\r\nreal_T rtNaN = -(real_T)NAN;\r\nreal_T rtInf = (real_T)INFINITY;\r\nreal_T rtMinusInf = -(real_T)INFINITY;\r\nreal32_T rtNaNF = -(real32_T)NAN;\r\nreal32_T rtInfF = (real32_T)INFINITY;\r\nreal32_T rtMinusInfF = -(real32_T)INFINITY;\r\n\r\n/* Test if value is infinite */\r\nboolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)isinf(value);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nboolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)isinf(value);\r\n}\r\n\r\n/* Test if value is not a number */\r\nboolean_T rtIsNaN(real_T value)\r\n{\r\n  return (boolean_T)(isnan(value) != 0);\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nboolean_T rtIsNaNF(real32_T value)\r\n{\r\n  return (boolean_T)(isnan(value) != 0);\r\n}\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"C:\\Users\\liam0\\OneDrive\\Desktop\\main_rsim_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rt_nonfinite.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"main\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Thu Oct 10 10:35:59 2024\r\n *\r\n * Target selection: rsim.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef rt_nonfinite_h_\r\n#define rt_nonfinite_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtInf;\r\nextern real_T rtMinusInf;\r\nextern real_T rtNaN;\r\nextern real32_T rtInfF;\r\nextern real32_T rtMinusInfF;\r\nextern real32_T rtNaNF;\r\nextern boolean_T rtIsInf(real_T value);\r\nextern boolean_T rtIsInfF(real32_T value);\r\nextern boolean_T rtIsNaN(real_T value);\r\nextern boolean_T rtIsNaNF(real32_T value);\r\n\r\n#endif                                 /* rt_nonfinite_h_ */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\liam0\\OneDrive\\Desktop\\main_rsim_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtwtypes.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"main\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Thu Oct 10 10:35:59 2024\r\n *\r\n * Target selection: rsim.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n#include \"tmwtypes.h\"\r\n#ifndef POINTER_T\r\n#define POINTER_T\r\n\r\ntypedef void * pointer_T;\r\n\r\n#endif\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n#ifndef INT64_T\r\n#define INT64_T\r\n\r\ntypedef long long int64_T;\r\n\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#endif\r\n\r\n#ifndef UINT64_T\r\n#define UINT64_T\r\n\r\ntypedef unsigned long long uint64_T;\r\n\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n#endif\r\n\r\n/*===========================================================================*\r\n * Additional complex number type definitions                                           *\r\n *===========================================================================*/\r\n#ifndef CINT64_T\r\n#define CINT64_T\r\n\r\ntypedef struct {\r\n  int64_T re;\r\n  int64_T im;\r\n} cint64_T;\r\n\r\n#endif\r\n\r\n#ifndef CUINT64_T\r\n#define CUINT64_T\r\n\r\ntypedef struct {\r\n  uint64_T re;\r\n  uint64_T im;\r\n} cuint64_T;\r\n\r\n#endif\r\n#endif                                 /* RTWTYPES_H */\r\n"},{"name":"main_dt.h","type":"header","group":"interface","path":"C:\\Users\\liam0\\OneDrive\\Desktop\\main_rsim_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * main_dt.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"main\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Thu Oct 10 10:35:59 2024\r\n *\r\n * Target selection: rsim.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n/* data type size table */\r\nstatic uint_T rtDataTypeSizes[] = {\r\n  sizeof(real_T),\r\n  sizeof(real32_T),\r\n  sizeof(int8_T),\r\n  sizeof(uint8_T),\r\n  sizeof(int16_T),\r\n  sizeof(uint16_T),\r\n  sizeof(int32_T),\r\n  sizeof(uint32_T),\r\n  sizeof(boolean_T),\r\n  sizeof(fcn_call_T),\r\n  sizeof(int_T),\r\n  sizeof(pointer_T),\r\n  sizeof(action_T),\r\n  2*sizeof(uint32_T),\r\n  sizeof(int32_T),\r\n  sizeof(int64_T),\r\n  sizeof(uint64_T),\r\n  sizeof(uint64_T),\r\n  sizeof(int64_T),\r\n  sizeof(uint_T),\r\n  sizeof(char_T),\r\n  sizeof(uchar_T),\r\n  sizeof(time_T)\r\n};\r\n\r\n/* data type name table */\r\nstatic const char_T * rtDataTypeNames[] = {\r\n  \"real_T\",\r\n  \"real32_T\",\r\n  \"int8_T\",\r\n  \"uint8_T\",\r\n  \"int16_T\",\r\n  \"uint16_T\",\r\n  \"int32_T\",\r\n  \"uint32_T\",\r\n  \"boolean_T\",\r\n  \"fcn_call_T\",\r\n  \"int_T\",\r\n  \"pointer_T\",\r\n  \"action_T\",\r\n  \"timer_uint32_pair_T\",\r\n  \"physical_connection\",\r\n  \"int64_T\",\r\n  \"uint64_T\",\r\n  \"uint64_T\",\r\n  \"int64_T\",\r\n  \"uint_T\",\r\n  \"char_T\",\r\n  \"uchar_T\",\r\n  \"time_T\"\r\n};\r\n\r\n/* data type transitions for block I/O structure */\r\nstatic DataTypeTransition rtBTransitions[] = {\r\n  { (char_T *)(&rtB.Integrator), 0, 0, 89 }\r\n  ,\r\n\r\n  { (char_T *)(&rtDW.Scope_PWORK.LoggedData[0]), 11, 0, 6 }\r\n};\r\n\r\n/* data type transition table for block I/O structure */\r\nstatic DataTypeTransitionTable rtBTransTable = {\r\n  2U,\r\n  rtBTransitions\r\n};\r\n\r\n/* data type transitions for Parameters structure */\r\nstatic DataTypeTransition rtPTransitions[] = {\r\n  { (char_T *)(&rtP.CombinedSlipWheelCPI_ALPMAX), 0, 0, 512 }\r\n};\r\n\r\n/* data type transition table for Parameters structure */\r\nstatic DataTypeTransitionTable rtPTransTable = {\r\n  1U,\r\n  rtPTransitions\r\n};\r\n\r\n/* [EOF] main_dt.h */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\liam0\\OneDrive\\Desktop\\main_rsim_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n *  rtmodel.h:\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"main\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Thu Oct 10 10:35:59 2024\r\n *\r\n * Target selection: rsim.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef rtmodel_h_\r\n#define rtmodel_h_\r\n#include \"main.h\"\r\n#define GRTINTERFACE                   1\r\n#endif                                 /* rtmodel_h_ */\r\n"},{"name":"ode3.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024b\\rtw\\c\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2009 The MathWorks, Inc.\n *\n * File: ode3.c        \n *\n */\n\n#include <math.h>\n#include <string.h>\n#include \"tmwtypes.h\"\n#ifdef USE_RTMODEL\n# include \"simstruc_types.h\"\n#else\n# include \"simstruc.h\"\n#endif\n#include \"odesup.h\"\n\nstatic const real_T rt_ODE3_A[3] = {\n    1.0/2.0, 3.0/4.0, 1.0\n};\n\nstatic const real_T rt_ODE3_B[3][3] = {\n    { 1.0/2.0,     0.0,     0.0 },\n    {     0.0, 3.0/4.0,     0.0 },\n    { 2.0/9.0, 1.0/3.0, 4.0/9.0 }\n};\n\n\ntypedef struct IntgData_tag {\n    real_T *y;\n    real_T *f[3];\n} IntgData;\n\n\n#ifndef RT_MALLOC\n  /* statically declare data */\n  static real_T   rt_ODE3_Y[NCSTATES];\n  static real_T   rt_ODE3_F[3][NCSTATES];\n  static IntgData rt_ODE3_IntgData = {rt_ODE3_Y,\n                                      {rt_ODE3_F[0],rt_ODE3_F[1],rt_ODE3_F[2]}};\n\nvoid rt_ODECreateIntegrationData(RTWSolverInfo *si)\n  {\n      rtsiSetSolverData(si,(void *)&rt_ODE3_IntgData);\n      rtsiSetSolverName(si,\"ode3\");\n  }\n#else\n  /* dynamically allocated data */\n\n  void rt_ODECreateIntegrationData(RTWSolverInfo *si)\n  {\n      IntgData *id = (IntgData *) malloc(sizeof(IntgData));\n      if(id == NULL) {\n          rtsiSetErrorStatus(si, RT_MEMORY_ALLOCATION_ERROR);\n          return;\n      }\n      \n      id->y = (real_T *) malloc(4*rtsiGetNumContStates(si) * sizeof(real_T));\n      if(id->y == NULL) {\n          rtsiSetErrorStatus(si, RT_MEMORY_ALLOCATION_ERROR);\n          return;\n      }\n      id->f[0] = id->y + rtsiGetNumContStates(si);\n      id->f[1] = id->f[0] + rtsiGetNumContStates(si);\n      id->f[2] = id->f[1] + rtsiGetNumContStates(si);\n      \n      rtsiSetSolverData(si, (void *)id);\n      rtsiSetSolverName(si,\"ode3\");\n  }\n\n  void rt_ODEDestroyIntegrationData(RTWSolverInfo *si)\n  {\n      IntgData *id = rtsiGetSolverData(si);\n      \n      if (id != NULL) {\n          if (id->y != NULL) {\n              free(id->y);\n          }\n          free(id);\n          rtsiSetSolverData(si, NULL);\n      }\n  }\n#endif\n\nvoid rt_ODEUpdateContinuousStates(RTWSolverInfo *si)\n{\n    time_T    t          = rtsiGetT(si);\n    time_T    tnew       = rtsiGetSolverStopTime(si);\n    time_T    h          = rtsiGetStepSize(si);\n    real_T    *x         = rtsiGetContStates(si);\n    IntgData  *id        = rtsiGetSolverData(si);\n    real_T    *y         = id->y;\n    real_T    *f0        = id->f[0];\n    real_T    *f1        = id->f[1];\n    real_T    *f2        = id->f[2];\n    real_T    hB[3];\n    int_T     i;\n\n#ifdef NCSTATES\n    int_T     nXc        = NCSTATES;\n#else\n    int_T     nXc        = rtsiGetNumContStates(si);\n#endif\n\n    rtsiSetSimTimeStep(si,MINOR_TIME_STEP);\n\n    /* Save the state values at time t in y, we'll use x as ynew. */\n    (void)memcpy(y, x, nXc*sizeof(real_T));\n\n    /* Assumes that rtsiSetT and ModelOutputs are up-to-date */\n    /* f0 = f(t,y) */\n    rtsiSetdX(si, f0);\n    DERIVATIVES(si);\n\n    /* f(:,2) = feval(odefile, t + hA(1), y + f*hB(:,1), args(:)(*)); */\n    hB[0] = h * rt_ODE3_B[0][0];\n    for (i = 0; i < nXc; i++) {\n\tx[i] = y[i] + (f0[i]*hB[0]);\n    }\n    rtsiSetT(si, t + h*rt_ODE3_A[0]);\n    rtsiSetdX(si, f1);\n    OUTPUTS(si,0);\n    DERIVATIVES(si);\n\n    /* f(:,3) = feval(odefile, t + hA(2), y + f*hB(:,2), args(:)(*)); */\n    for (i = 0; i <= 1; i++) hB[i] = h * rt_ODE3_B[1][i];\n    for (i = 0; i < nXc; i++) {\n\tx[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1]);\n    }\n    rtsiSetT(si, t + h*rt_ODE3_A[1]);\n    rtsiSetdX(si, f2);\n    OUTPUTS(si,0);\n    DERIVATIVES(si);\n\n    /* tnew = t + hA(3);\n       ynew = y + f*hB(:,3); */\n    for (i = 0; i <= 2; i++) hB[i] = h * rt_ODE3_B[2][i];\n    for (i = 0; i < nXc; i++) {\n\tx[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1] + f2[i]*hB[2]);\n    }\n    rtsiSetT(si, tnew);\n\n    PROJECTION(si);\n    REDUCTION(si);\n\n    rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);\n}\n\n\n/* [EOF] ode3.c */\n"},{"name":"rt_logging.c","type":"source","group":"other","path":"C:\\Program Files\\MATLAB\\R2024b\\rtw\\c\\src","tag":"","groupDisplay":"Other files","code":"/* \n *\n * Copyright 1994-2022 The MathWorks, Inc.\n *\n * File: rt_logging.c\n *\n * Abstract:\n *\tReal-Time Workshop data logging routines using circular buffers of\n *      fixed size.  The buffers are allocated at start, filled in at each\n *      major time step and finally written to a MAT-file at the end of the\n *      simulation.\n *\n *      This file handles redefining the following standard MathWorks types\n *      (see tmwtypes.h):\n *         [u]int8_T     to be int32_T (logged as Matlab [u]int32)\n *         [u]int16_T    to be int32_T (logged as Matlab [u]int32)\n *         real_T        to be real32_T (logged as Matlab single)\n *\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n\n\n#if !defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)\n\n#include <stddef.h>                     /* size_t */\n#include \"rt_logging.h\"\n#ifndef IS_RAPID_ACCEL\n#include \"rt_mxclassid.h\"\n#endif\n#include \"rtw_matlogging.h\"\n\n#include \"rtwtypes.h\"\n\n#ifndef TMW_NAME_LENGTH_MAX\n#define TMW_NAME_LENGTH_MAX 64\n#endif\n#define mxMAXNAM  TMW_NAME_LENGTH_MAX\t/* maximum name length */\n#define matUNKNOWN                  0\n#define\tmatINT8                     1\n#define\tmatUINT8                    2\n#define\tmatINT16                    3\n#define\tmatUINT16                   4\n#define\tmatINT32                    5\n#define\tmatUINT32                   6\n#define\tmatFLOAT                    7\n#define\tmatDOUBLE                   9\n#define matINT64                   12\n#define matUINT64                  13\n#define\tmatMATRIX                  14\n\n#define matLOGICAL_BIT          0x200\n#define matCOMPLEX_BIT          0x800\n\n#define matKEY                 0x4D49\n#define matVERSION             0x0100\n#define matVERSION_INFO_OFFSET   124L\n\n#define matINT64_ALIGN(e)      ( ( ((unsigned)(e))+7 ) & (~7) )\n#define matTAG_SIZE            (sizeof(int32_T) << 1)\n\n#ifndef DEFAULT_BUFFER_SIZE\n#define DEFAULT_BUFFER_SIZE      1024  /* used if maxRows=0 and Tfinal=0.0    */\n#endif\n\n#define FREE(m) if (m != NULL) free(m)\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\n/*==========*\n * typedefs *\n *==========*/\n\ntypedef struct LogInfo_Tag {\n    LogVar       *t;                   /* Time log variable                   */\n    void         *x;                   /* State log variable                  */\n    int_T        ny;                   /* Length of \"y\" log variables         */\n    void         **y;                  /* Output log vars                     */\n    void         *xFinal;              /* Final state log variable            */\n\n    LogVar       *logVarsList;         /* Linked list of all LogVars          */\n    StructLogVar *structLogVarsList;   /* Linked list of all StructLogVars    */\n\n    boolean_T   haveLogVars;           /* Are logging one or more vars?       */\n} LogInfo;\n\ntypedef struct MatItem_tag {\n  int32_T    type;\n  uint32_T    nbytes;\n  const void *data;\n} MatItem;\n\ntypedef enum {\n    DATA_ITEM,\n    MATRIX_ITEM,\n    STRUCT_LOG_VAR_ITEM,\n    SIGNALS_STRUCT_ITEM\n} ItemDataKind;\n\n/*===========*\n * Constants *\n *===========*/\n\nstatic const char_T rtMemAllocError[] = \"Memory allocation error\";\n\n#define ZEROS32 \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n\n#if mxMAXNAM==32\n\n#define ZERO_PAD\n\n#elif mxMAXNAM==64\n\n#define ZERO_PAD ZEROS32\n\n#elif mxMAXNAM==128\n\n#define ZERO_PAD   ZEROS32  ZEROS32  ZEROS32\n\n#else\n\n#error \"Cannot Handle mxMAXNAM other than 32,64, and 128\"\n\n#endif\n/* field names: for variable-size signal logging */\nstatic const char_T rtStructLogVarFieldNames[] =\n                  \"time\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"signals\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nstatic const char_T rtLocalLoggingSignalsStructFieldNames[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"valueDimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"title\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"plotStyle\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nstatic const char_T rtGlobalLoggingSignalsStructFieldNames[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"valueDimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"stateName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"inReferencedModel\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n                  \n\n#define TIME_FIELD_NAME      (rtStructLogVarFieldNames[0*mxMAXNAM])\n#define SIGNALS_FIELD_NAME   (rtStructLogVarFieldNames[1*mxMAXNAM])\n#define BLOCKNAME_FIELD_NAME (rtStructLogVarFieldNames[2*mxMAXNAM])\n\n#define VALUES_FIELD_NAME    (rtLocalLoggingSignalsStructFieldNames[0*mxMAXNAM])\n#define VALUEDIMENSIONS_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[1*mxMAXNAM])\n#define DIMENSION_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[2*mxMAXNAM])\n#define LABEL_FIELD_NAME     (rtLocalLoggingSignalsStructFieldNames[3*mxMAXNAM])\n#define TITLE_FIELD_NAME     (rtLocalLoggingSignalsStructFieldNames[4*mxMAXNAM])\n#define PLOTSTYLE_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[5*mxMAXNAM])\n\n#define STATENAME_FIELD_NAME (rtGlobalLoggingSignalsStructFieldNames[5*mxMAXNAM])\n#define CROSS_MDL_REF_FIELD_NAME (rtGlobalLoggingSignalsStructFieldNames[6*mxMAXNAM])\n\n/* field names: for fixed-size signal logging */\nstatic const char_T rtLocalLoggingSignalsStructFieldNames_noValDims[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"title\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"plotStyle\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\nstatic const char_T rtGlobalLoggingSignalsStructFieldNames_noValDims[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"stateName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"inReferencedModel\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nextern real_T rtInf; /* declared by rt_nonfinite.c */\nextern real_T rtNaN;\nextern real32_T rtNaNF;\n\n/*================*\n * Local routines *\n *================*/\n\n/* Function: rt_GetSizeofDataType ==============================================\n * Abstract:\n *      Get the element size in bytes given the data type id.\n */\nstatic size_t rt_GetSizeofDataType(BuiltInDTypeId dTypeID)\n{\n    size_t elSz = 0; /* unknown */\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n        elSz = sizeof(real_T);\n        break;\n      case SS_SINGLE:\n        elSz = sizeof(real32_T);\n        break;\n      case SS_INT8:\n        elSz = sizeof(int8_T);\n        break;\n      case SS_UINT8:\n        elSz = sizeof(uint8_T);\n        break;\n      case SS_INT16:\n        elSz = sizeof(int16_T);\n        break;\n      case SS_UINT16:\n        elSz = sizeof(uint16_T);\n        break;\n      case SS_INT32:\n        elSz = sizeof(int32_T);\n        break;\n      case SS_UINT32:\n        elSz = sizeof(uint32_T);\n        break;\n      case SS_BOOLEAN:\n        elSz = sizeof(boolean_T);\n        break;\n    }\n    return(elSz);\n\n} /* end rt_GetSizeofDataType */\n\n\n/* Function: rt_GetSizeofComplexType ===========================================\n * Abstract:\n *      Get the element size in bytes given the data type id.\n */\nstatic size_t rt_GetSizeofComplexType(BuiltInDTypeId dTypeID)\n{\n    size_t elSz = 2*rt_GetSizeofDataType(dTypeID);\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n      #ifdef CREAL_T\n        elSz = sizeof(creal_T);\n      #endif\n        break;\n      case SS_SINGLE:\n      #ifdef CREAL_T\n        elSz = sizeof(creal32_T);\n      #endif\n        break;\n      case SS_INT8:\n      #ifdef CINT8_T\n        elSz = sizeof(cint8_T);\n      #endif\n        break;\n      case SS_UINT8:\n      #ifdef CUINT8_T\n        elSz = sizeof(cuint8_T);\n      #endif\n        break;\n      case SS_INT16:\n      #ifdef CINT16_T\n        elSz = sizeof(cint16_T);\n      #endif\n        break;\n      case SS_UINT16:\n      #ifdef CUINT16_T\n        elSz = sizeof(cuint16_T);\n      #endif\n        break;\n      case SS_INT32:\n      #ifdef CINT32_T\n        elSz = sizeof(cint32_T);\n      #endif\n        break;\n      case SS_UINT32:\n      #ifdef CUINT32_T\n        elSz = sizeof(cuint32_T);\n      #endif\n        break;\n      case SS_BOOLEAN:\n        elSz = sizeof(boolean_T);\n        break;\n    }\n\n    return(elSz);\n\n} /* end rt_GetSizeofComplexType */\n\n\n/* Function: rt_GetDataTypeConvertInfo =========================================\n * Abstract:\n *      Directly copy if pointer to structure is non-NULL, otherwise set to\n *      default.\n */\nstatic RTWLogDataTypeConvert rt_GetDataTypeConvertInfo(\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo,\n    BuiltInDTypeId dTypeID\n    )\n{\n    RTWLogDataTypeConvert dataTypeConvertInfoCopy;\n\n    if (pDataTypeConvertInfo == NULL) {\n        dataTypeConvertInfoCopy.conversionNeeded = 0;\n        dataTypeConvertInfoCopy.dataTypeIdLoggingTo = dTypeID;\n        dataTypeConvertInfoCopy.dataTypeIdOriginal  = (DTypeId)dTypeID;\n        dataTypeConvertInfoCopy.bitsPerChunk = 0;\n        dataTypeConvertInfoCopy.numOfChunk = 0;\n        dataTypeConvertInfoCopy.isSigned = 0;\n        dataTypeConvertInfoCopy.fracSlope = 1.0;\n        dataTypeConvertInfoCopy.fixedExp = 0;\n        dataTypeConvertInfoCopy.bias = 0.0;\n    } else {\n        dataTypeConvertInfoCopy = *pDataTypeConvertInfo;\n    }\n\n    return dataTypeConvertInfoCopy;\n\n} /* end rt_GetDataTypeConvertInfo */\n\n\n/* Function: rt_GetDblValueFromOverSizedData ===================================\n * Abstract:\n */\nstatic double rt_GetDblValueFromOverSizedData(\n    const void *pVoid, \n    int bitsPerChunk, \n    int numOfChunk,\n    unsigned int isSigned, \n    double fracSlope, \n    int fixedExp, \n    double bias)\n{\n    double retValue = 0;\n\n    double *dblValue = (double *) calloc(numOfChunk, sizeof(double));\n\n    int i;    \n    double isSignedNeg;\n\n    if(isSigned) {\n        const chunk_T *pData = (const chunk_T *) (pVoid);\n        for (i = 0; i <numOfChunk; i++) {\n            dblValue[i] = (double)(pData[i]);\n        }\n    } else  {\n        const uchunk_T *pData = (const uchunk_T *) (pVoid);\n        for (i = 0; i <numOfChunk; i++) {\n            dblValue[i] = (double)(pData[i]);\n        }\n    }\n\n    /* \n       Assuming multi chunks b_n ... b_2 b_1 b_0, and the length of each chunk is N.\n       Suppose b_i is the i-th chunk's value.\n       Then for unsigned data or data with one chunk: we have\n       retValue = b_n * 2^(n*N) + ... + b_1 * 2^N + b_0 * 2^0;\n       But for signed data, we have\n       retValue = b_n * 2^(n*N) + ... + b_1 * 2^N + b_0 * 2^0+ (b_0<0) * 2^N + \n       ... (b_(n-1) <0) * 2^(n*N) \n       = (b_n + (b_(n-1)<0)) * 2^(n*N) +... + (b_1 + (b_0<0)) * 2^N + b_0 * 2^0;\n       Together:\n       retValue = \n       (b_n + isSigned * (b_(n-1)<0)) * 2^(n*N) +... + (b_1 + isSigned * (b_0<0)) * 2^N + b_0 * 2^0;\n    */\n\n    retValue = dblValue[numOfChunk - 1];\n    \n    for(i = numOfChunk - 1; i > 0; i--) {\n        isSignedNeg = dblValue[i - 1] < 0 ? (double)isSigned : 0;\n        retValue = retValue + isSignedNeg;\n\n        retValue = ldexp(retValue, bitsPerChunk)+ dblValue[i-1];\n    }\n    retValue = ldexp( fracSlope * retValue, fixedExp ) + bias;\n\n    FREE(dblValue);\n    return (retValue);\n\n} /* end rt_GetDblValueFromOverSizedData */\n\n\n/* Function: rt_GetNonBoolMxIdFromDTypeId ======================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nstatic mxClassID rt_GetNonBoolMxIdFromDTypeId(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n        mxID = (sizeof(real_T)==4? mxSINGLE_CLASS: mxDOUBLE_CLASS);\n        break;\n      case SS_SINGLE:\n        mxID = mxSINGLE_CLASS;\n        break;\n      case SS_INT8:\n        switch (sizeof(int8_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps int8_T into 32-bits\" */\n            mxID = mxINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps int8_T into 16-bits\" */\n            mxID = mxINT16_CLASS;\n            break;\n          case 1:\n            mxID = mxINT8_CLASS;\n            break;\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown data type ID\" */\n            mxID = mxUNKNOWN_CLASS;\n            break;\n        }\n        break;\n      case SS_UINT8:\n        switch (sizeof(uint8_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps uint8_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps uint8_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          case 1:\n            mxID = mxUINT8_CLASS;\n            break;\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown data type ID\" */\n            mxID = mxUNKNOWN_CLASS;\n            break;\n        }\n        break;\n      case SS_INT16:\n        mxID = (sizeof(int16_T)==4? mxINT32_CLASS: mxINT16_CLASS);\n        break;\n      case SS_UINT16:\n        mxID = (sizeof(uint16_T)==4? mxUINT32_CLASS: mxUINT16_CLASS);\n        break;\n      case SS_INT32:\n        mxID = mxINT32_CLASS;\n        break;\n      case SS_UINT32:\n        mxID = mxUINT32_CLASS;\n        break;\n        /*case SS_BOOLEAN:\n          mxID = (sizeof(boolean_T)==4? mxUINT32_CLASS: mxLOGICAL_CLASS);\n          break;*/\n      default:\n        mxID = mxUNKNOWN_CLASS;\n        break;\n    }\n\n    return(mxID);\n\n} /* end rt_GetNonBoolMxIdFromDTypeId */\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_GetMxIdFromDTypeIdForRSim ======================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nmxClassID rt_GetMxIdFromDTypeIdForRSim(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    if (dTypeID == SS_BOOLEAN) {\n        switch (sizeof(boolean_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          default:\n            mxID = mxLOGICAL_CLASS;\n            break;\n        }\n    } else {\n        mxID = rt_GetNonBoolMxIdFromDTypeId(dTypeID);\n    }\n\n    return(mxID);\n\n} /* end rt_GetMxIdFromDTypeIdForRSim */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_GetMxIdFromDTypeId =============================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nmxClassID rt_GetMxIdFromDTypeId(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    if (dTypeID == SS_BOOLEAN) {\n        switch (sizeof(boolean_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          default:\n            mxID = mxUINT8_CLASS;\n            break;\n        }\n    } else {\n        mxID = rt_GetNonBoolMxIdFromDTypeId(dTypeID);\n    }\n    return(mxID);\n\n} /* end rt_GetMxIdFromDTypeId */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n/* Function: rt_GetMatIdFromMxId ===============================================\n * Abstract:\n *      Get the MatId given the mxClassID.\n */\nstatic int_T rt_GetMatIdFromMxId(mxClassID mxID)\n{\n    int_T matID;\n\n    switch (mxID) {\n      case mxCELL_CLASS:\n      case mxSTRUCT_CLASS:\n      case mxOBJECT_CLASS:\n        matID = -1;\n        break;\n      case mxCHAR_CLASS:\n        matID = matUINT16;\n        break;\n      case mxDOUBLE_CLASS:\n        matID = matDOUBLE;\n        break;\n      case mxSINGLE_CLASS:\n        matID = matFLOAT;\n        break;\n      case mxINT8_CLASS:\n        matID = matINT8;\n        break;\n      case mxUINT8_CLASS:\n        matID = matUINT8;\n        break;\n      case mxINT16_CLASS:\n        matID = matINT16;\n        break;\n      case mxUINT16_CLASS:\n        matID = matUINT16;\n        break;\n      case mxINT32_CLASS:\n        matID = matINT32;\n        break;\n      case mxUINT32_CLASS:\n        matID = matUINT32;\n        break;\n      case mxINT64_CLASS:\n        matID = matINT64;\n        break;\n      case mxUINT64_CLASS:\n        matID = matUINT64;\n        break;\n      default:\n        matID = matUNKNOWN;\n        break;\n    }\n    return(matID);\n\n} /* end rt_GetMatIdFromMxId */\n\n\n/* Forward declaration */\nstatic int_T rt_WriteItemToMatFile(FILE         *fp,\n                                   MatItem      *pItem,\n                                   ItemDataKind dataKind);\n\n\n/* Function: rt_ProcessMatItem =================================================\n * Abstract:\n *      This routine along with rt_WriteItemToMatFile() write out a specified\n *      mat-item the .mat file. Note that if the input argument\n *          cmd == 0, then this function just calculates the size of the item.\n *          cmd <> 0, this function writes the mat-item to the file.\n *      Return values is\n *           -1 : coding/logic error\n *            0 : upon success\n *          > 0 : upon write failure (1)\n */\nstatic int_T rt_ProcessMatItem(FILE         *fp,\n                               MatItem      *pItem,\n                               ItemDataKind itemKind,\n                               int_T        cmd)\n{\n    mxClassID    mxID          = mxUNKNOWN_CLASS;\n    uint32_T     arrayFlags[2] = {0, 0};\n    int32_T      *dims         = NULL;\n    int32_T      _dims[3]      = {0, 0, 0};\n    int32_T      nDims         = 2;\n    int32_T      nBytesInItem  = 0;\n    const char_T *itemName;\n    MatItem      item;\n    int_T        retStat       = 0;\n\n    switch (itemKind) {\n      case DATA_ITEM: {\n          (void)fprintf(stderr,\"Unexpected itemKind = DATA_ITEM in \"\n                               \"rt_ProcessMatItem @A\\n\");\n          retStat = -1;\n          goto EXIT_POINT;\n      }\n      case MATRIX_ITEM: {\n          const MatrixData *var = (const MatrixData *) pItem->data;\n\n          mxID           = var->mxID;\n          arrayFlags[0]  = mxID;\n          arrayFlags[0] |= var->logical;\n          arrayFlags[0] |= var->complex;\n          if (var->nDims < 2) {\n              dims         = _dims;\n              dims[0]      = var->nRows;\n              dims[1]      = var->nCols;\n              nDims        = 2;\n          } else {\n              int32_T k;\n              dims = (int32_T*)malloc(sizeof(int32_T)*(var->nDims+1));\n              for (k = 0; k < var->nDims; k++) {\n                  dims[k] = var->dims[k];\n              }\n              dims[var->nDims] = var->nRows;\n              nDims = var->nDims + 1;\n          }\n          itemName = var->name;\n          break;\n      }\n      case STRUCT_LOG_VAR_ITEM: {\n          const StructLogVar *var = (const StructLogVar *) pItem->data;\n\n          mxID          = mxSTRUCT_CLASS;\n          arrayFlags[0] = mxID;\n          dims          = _dims;\n          dims[0]       = 1;\n          dims[1]       = 1;\n          itemName      = var->name;\n          break;\n      }\n      case SIGNALS_STRUCT_ITEM: {\n          const SignalsStruct *var = (const SignalsStruct *) pItem->data;\n\n          mxID          = mxSTRUCT_CLASS;\n          arrayFlags[0] = mxID;\n          dims          = _dims;\n          dims[0]       = 1;\n          dims[1]       = var->numSignals;\n          itemName      = &SIGNALS_FIELD_NAME;\n          break;\n      }\n      default:\n        (void)fprintf(stderr,\"Unexpected itemKind=%d in rt_ProcessMatItem @B\\n\",\n                      itemKind);\n        retStat = -1;\n        goto EXIT_POINT;\n    }\n\n    /* array flags */\n    item.nbytes = 2*sizeof(uint32_T);\n    if (cmd) {\n        item.type = matUINT32;\n        item.data = arrayFlags;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;\n        }\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        nBytesInItem += matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n    /* dimensions */\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    item.nbytes = nDims*sizeof(int32_T);\n    if (cmd) {\n        item.type = matINT32;\n        item.data = dims;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;            \n        }\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        nBytesInItem += matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n    /* name */\n    item.nbytes = (int32_T)strlen(itemName);\n    if (cmd) {\n        item.type = matINT8;\n        item.data = (const char_T*) itemName;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;\n        }\n    } else {\n        nBytesInItem += (item.nbytes <= 4) ? /*LINTED E_CAST_INT_TO_SMALL_INT*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n\n    if (itemKind == MATRIX_ITEM) {\n        const MatrixData *var   = (const MatrixData*) pItem->data;\n        int_T            matID  = rt_GetMatIdFromMxId(mxID);\n        size_t           elSize = var->elSize;\n\n        /* data */\n        item.nbytes = (int32_T)(var->nRows * var->nCols * elSize);\n        if (cmd) {\n            item.type = matID;\n            item.data = var->re;\n            if (rt_WriteItemToMatFile(fp, &item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n        } else {\n            nBytesInItem += (item.nbytes <= 4) ? /*LINTED*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n        }\n        /* imaginary part */\n        if (var->complex) {\n            item.nbytes = (int32_T)(var->nRows * var->nCols * elSize);\n            if (cmd) {\n                item.type = matID;\n                item.data = var->im;\n                if (rt_WriteItemToMatFile(fp, &item, DATA_ITEM)) {\n                    retStat = 1;\n                    goto EXIT_POINT;\n                }\n            } else {\n                nBytesInItem += (item.nbytes <= 4) ? /*LINTED*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n            }\n        }\n    } else {  /* some type of structure item */\n        const char_T *fieldNames;\n        int_T        sizeofFieldNames;\n\n        /* field names */\n        switch (itemKind) {\n          case STRUCT_LOG_VAR_ITEM: {\n              const StructLogVar *var = (const StructLogVar *) pItem->data;\n              fieldNames        = rtStructLogVarFieldNames;\n              sizeofFieldNames  = var->numActiveFields * mxMAXNAM;\n              break;\n          }\n          case SIGNALS_STRUCT_ITEM: {\n              const SignalsStruct *var = (const SignalsStruct *) pItem->data;\n              fieldNames        = var->fieldNames;\n              sizeofFieldNames  = var->numActiveFields * mxMAXNAM;\n              break;\n          }\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown itemKind\" */\n            (void)fprintf(stderr, \"Unexpected itemKind=%d in \"\n                          \"rt_ProcessMatItem @C\\n\", itemKind);\n            retStat = -1;\n            goto EXIT_POINT;\n        }\n\n        /* write field names */\n        if (cmd) {\n            int32_T tmpInt = mxMAXNAM;\n\n            item.nbytes = sizeof(int32_T);\n            item.type   = matINT32;\n            item.data   = &tmpInt;\n            if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n\n            item.nbytes = sizeofFieldNames;\n            item.type   = matINT8;\n            item.data   = (const char_T*) fieldNames;\n            if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n        } else {\n            /*LINTED E_CAST_INT_TO_SMALL_INT*/\n            nBytesInItem += matINT64_ALIGN( matTAG_SIZE + matTAG_SIZE +\n                                            sizeofFieldNames );\n        }\n\n        /* process each field of the structure */\n        switch (itemKind) {\n          case STRUCT_LOG_VAR_ITEM: {\n              const StructLogVar *var = pItem->data;\n\n              /* time */\n              {\n                  const void *data = var->time;\n\n                  if (var->logTime) { /* time is a LogVar, get the MatrixData */\n                      data = &(((const LogVar*) (var->time))->data);\n                  }\n\n                  item.type = matMATRIX;\n                  item.data = data;\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp,&item,MATRIX_ITEM)){\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM,0)){\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n              }\n\n              /* signals */\n              item.type = matMATRIX;\n              item.data = &(var->signals);\n              if (cmd) {\n                  if (rt_WriteItemToMatFile(fp,&item,SIGNALS_STRUCT_ITEM)) {\n                      retStat = 1;\n                      goto EXIT_POINT;\n                  }\n              } else {\n                  if (rt_ProcessMatItem(fp, &item, SIGNALS_STRUCT_ITEM,0)) {\n                      retStat = 1;\n                      goto EXIT_POINT;\n                  }\n                  nBytesInItem += item.nbytes + matTAG_SIZE;\n              }\n\n              /* block name */\n              if (var->blockName != NULL) {\n                  item.type = matMATRIX;\n                  item.data = var->blockName;\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n              }\n              break;\n          }\n          case SIGNALS_STRUCT_ITEM: {\n              const SignalsStruct *var        = pItem->data;\n              const LogVar        *values     = var->values;\n              const MatrixData    *dimensions = var->dimensions;\n              const MatrixData    *labels     = var->labels;\n              const MatrixData    *plotStyles = var->plotStyles;\n              const MatrixData    *titles     = var->titles;\n              const MatrixData    *blockNames = var->blockNames;\n              const MatrixData    *stateNames = var->stateNames;\n              const MatrixData    *crossMdlRef = var->crossMdlRef;\n              const boolean_T logValueDimensions = var->logValueDimensions;\n              int_T               i;\n\n              for (i = 0; i < var->numSignals; i++) {\n                  /* values */\n                  item.type = matMATRIX;\n                  item.data = &(values->data);\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n\n                  if(logValueDimensions)\n                  {\n                      /* valueDimensions */\n                      /* Since the functions rt_WriteItemToMatFile and \n                         rt_ProcessMatItem deal with MatrixData, \n                         convert valDims to tempData, and fill up the\n                         necessary fields.\n                      */\n                      MatrixData  tempData;\n                      (void)memcpy(tempData.name, &VALUEDIMENSIONS_FIELD_NAME, mxMAXNAM);\n                      tempData.nRows = values->valDims->nRows;\n                      tempData.nCols = values->valDims->nCols;\n                      tempData.nDims = 1;\n                      tempData._dims[0] = values->valDims->nCols;\n                      tempData.re = values->valDims->dimsData;\n                      tempData.im = NULL;\n                      tempData.dTypeID = SS_DOUBLE;\n                      tempData.elSize =  sizeof(real_T);\n                      tempData.mxID = mxDOUBLE_CLASS;\n                      tempData.logical = 0;\n                      tempData.complex = 0;\n                      tempData.frameData = 0;\n                      tempData.frameSize = 1;\n\n                      item.type = matMATRIX;                    \n                      item.data = &tempData; /*values->valDims;*/\n\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  values = values->next;\n\n                  /* dimensions */\n                  if (dimensions != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(dimensions[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp,&item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n\n                  /* label */\n                  item.type = matMATRIX;\n                  item.data = &(labels[i]);\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n                  /* title */\n                  if (titles != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(titles[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* plot style */\n                  if (plotStyles != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(plotStyles[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp,&item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* block name */\n                  if (blockNames != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(blockNames[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* state name */\n                  if (stateNames != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(stateNames[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* crossMdlRef */\n                  if (crossMdlRef != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(crossMdlRef[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n              } /* for i=1:numSignals */\n              break;\n          }\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown itemKind\" */\n            (void)fprintf(stderr, \"Unexpected itemKind=%d in \"\n                          \"rt_ProcessMatItem @D\\n\", itemKind);\n            retStat = -1;\n            goto EXIT_POINT;\n        }\n    } /* end struct item */\n\n    if (!cmd) {\n        pItem->nbytes = nBytesInItem;\n    }\n\n  EXIT_POINT:\n    if (dims != _dims) {\n        FREE(dims);\n    }\n    return(retStat);\n\n} /* end rt_ProcessMatItem */\n\n\n/* Function: rt_WriteItemToMatFile =============================================\n * Abstract:\n *      Entry function for writing out a mat item to the mat file.\n *\n *      Return values is\n *          == 0 : upon success\n *          <> 0 : upon failure\n */\nstatic int_T rt_WriteItemToMatFile(FILE         *fp,\n                                   MatItem      *pItem,\n                                   ItemDataKind itemKind)\n{\n    /* Determine the item size */\n    if (pItem->type == matMATRIX) {\n        if (rt_ProcessMatItem(fp, pItem, itemKind, 0)) return(1);\n    }\n\n    /* Write the item tag and data */\n    if (pItem->nbytes > 4) {\n        int32_T nAlignBytes;\n\n        if (fwrite(pItem, 1, matTAG_SIZE, fp) != matTAG_SIZE) return(1);\n\n        if (pItem->type == matMATRIX) {\n            if (rt_ProcessMatItem(fp, pItem, itemKind, 1)) return(1);\n        } else {\n            if ( fwrite(pItem->data, 1, pItem->nbytes, fp) !=\n                                                    ((size_t) pItem->nbytes) ) {\n                return(1);\n            }\n        }\n\n        /* Add offset for 8-byte alignment */\n        nAlignBytes = matINT64_ALIGN(pItem->nbytes) - pItem->nbytes;\n        if (nAlignBytes > 0) {\n            int pad[2] = {0, 0};\n            if ( fwrite(pad,1,nAlignBytes,fp) != ((size_t) nAlignBytes) ) {\n                return(1);\n            }\n        }\n    } else {\n        MatItem item = {0, 0, NULL};\n        item.type = ((uint32_T)(pItem->type))|(((uint32_T)(pItem->nbytes))<<16);\n        (void)memcpy(&item.nbytes, pItem->data, pItem->nbytes);\n        if (fwrite(&item, 1, matTAG_SIZE, fp) != matTAG_SIZE) return(1);\n    }\n\n    return(0);\n\n} /* end rt_WriteItemToMatFile */\n\n\n/* Function: rt_WriteMat5FileHeader ============================================\n * Abstract:\n *      Function to write the mat file header.\n *      Return values is\n *          == 0 : upon success\n *          <> 0 : upon failure\n */\nstatic int_T rt_WriteMat5FileHeader(FILE *fp)\n{\n    int_T        nbytes;\n    int_T        nspaces;\n    int_T        i, n;\n    unsigned short ver[2];\n    char_T       spaces[16];\n    const char_T *matversion = \"MATLAB 5.0 MAT-file\";\n\n    (void)memset(spaces, ' ', sizeof(spaces));\n\n    n = (int_T)strlen(matversion);\n    nbytes = (int_T)fwrite(matversion, 1, n, fp);\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    nspaces = matVERSION_INFO_OFFSET - nbytes;\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    n = nspaces % sizeof(spaces);\n    nbytes += (int_T)fwrite(spaces, 1, n, fp);\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    n = nspaces / sizeof(spaces);\n    for (i = 0; i < n; ++i) {\n        nbytes += (int_T)fwrite(spaces, 1, sizeof(spaces), fp);\n    }\n    if (nbytes == matVERSION_INFO_OFFSET) {\n        ver[0] = matVERSION;\n        ver[1] = matKEY;\n        nbytes += (int_T)fwrite(ver, 1, sizeof(ver), fp);\n    }\n    return(nbytes != matVERSION_INFO_OFFSET + sizeof(ver));\n\n} /* end rt_WriteMat5FileHeader */\n\n\n/* Function: rt_FixupLogVar ====================================================\n * Abstract:\n *\tMake the logged variable suitable for MATLAB.\n */\nstatic const char_T *rt_FixupLogVar(LogVar *var,int verbose)\n{\n    int_T  nCols   = var->data.nCols;\n    int_T  maxRows = var->data.nRows;\n    int_T  nDims   = var->data.nDims;\n    size_t elSize  = var->data.elSize;\n    int_T  nRows   = (var->wrapped ?  maxRows : var->rowIdx);\n\n    var->nDataPoints = var->rowIdx + var->wrapped * maxRows;\n\n    if (var->wrapped > 1 || (var->wrapped == 1 && var->rowIdx != 0)) {\n        /*\n         * Warn the user the circular buffer has wrapped, implying that\n         * some data has been lost.\n         */\n        if( verbose) {\n            (void)fprintf(stdout,\n                          \"*** Log variable %s has wrapped %d times\\n\"\n                          \"    using a circular buffer of size %d\\n\",\n                          var->data.name, var->wrapped, var->data.nRows);\n        }\n        if (var->usingDefaultBufSize) {\n            /*\n             * If wrapping occurred using the default buffer size,\n             * let the user know what size buffer to use in the\n             * future to avoid wrapping.  If the default buffer\n             * size was not used, the user has no control to specify\n             * the correct value.  Wrapping may occur when not using\n             * the default buffer if we allocated too small a buffer\n             * size for this logvar.  One common case is a toWorkspace\n             * block inside of an iterative subsystem - we can not take\n             * the number of iterations into account (they may be\n             * variable) when allocating the buffer.  In this case,\n             * just warn the buffer wrapped and don't tell user they\n             * can override the buffer size.\n             */\n            if( verbose ) {\n                (void)fprintf(stdout,\n                              \"*** To avoid wrapping, explicitly specify a\\n\"\n                              \"    buffer size of %d in your Simulink model\\n\"\n                              \"    by adding OPTS=\\\"-DDEFAULT_BUFFER_SIZE=%d\\\"\\n\"\n                              \"    as an argument to the ConfigSet MakeCommand\\n\"\n                              \"    parameter\\n\",\n                              var->nDataPoints, var->nDataPoints);\n            }\n        }\n    }\n\n    if (nDims < 2 && nCols > 1) {  /* Transpose? */\n        /* Don't need to transpose valueDimensions */\n        int_T  nEl    = nRows*nCols;\n        char   *src   = var->data.re;\n        char   *pmT;\n        int_T  k;\n\n        /**********************************\n         * If memory cannot be allocated, *\n         * write to a temporary buffer    *\n         **********************************/\n        if ((pmT = malloc(nEl*elSize)) == NULL) {\n            FILE  *fptr;\n            char  fName[mxMAXNAM+13];\n\n            (void)sprintf(fName, \"%s%s\", var->data.name, \"_rtw_tmw.tmw\");\n            if ((fptr=fopen(fName,\"w+b\")) == NULL) {\n                (void)fprintf(stderr,\"*** Error opening %s\",fName);\n                return(\"unable to open data file\\n\");\n            }\n\n            /****************************\n             * Write the data to a file *\n             ****************************/\n            for (k=0; k<nEl; k++) {\n                int_T kT   = nCols*(k%nRows) + (k/nRows);\n                char  *dst = src + kT*elSize;\n                (void)fwrite(dst, elSize, 1, fptr);\n            }\n            if (var->data.complex) {\n                char *pmiT = var->data.re;\n                src  = var->data.im;\n                for (k=0; k<nEl; k++) {\n                    int_T kT   = nRows*(k%nCols) + (k/nCols);\n                    char  *dst = pmiT + kT*elSize;\n                    (void)memcpy(dst, src, elSize);\n                    src += elSize;\n                }\n                var->data.re = var->data.im;\n                var->data.im = pmiT;\n            }\n\n            /*******************************\n             * Read the data from the file *\n             *******************************/\n            (void)rewind(fptr);\n            (void)fread(var->data.re, elSize, nEl, fptr);\n            (void)fclose(fptr);\n            (void)remove(fName);\n        } else {\n            for (k=0; k<nEl; k++) {\n                int_T kT   = nRows*(k%nCols) + (k/nCols);\n                char  *dst = pmT + kT*elSize;\n                (void)memcpy(dst, src, elSize);\n                src += elSize;\n            }\n            if (var->data.complex) {\n                char *pmiT = var->data.re;\n                src  = var->data.im;\n                for (k=0; k<nEl; k++) {\n                    int_T kT   = nRows*(k%nCols) + (k/nCols);\n                    char  *dst = pmiT + kT*elSize;\n                    (void)memcpy(dst, src, elSize);\n                    src += elSize;\n                }\n                var->data.re = var->data.im;\n                var->data.im = pmiT;\n            }\n            FREE(var->data.re);\n            var->data.re = pmT;\n        }\n    } /* Transpose? */\n\n    if (var->wrapped > 0 && var->rowIdx != 0 ) {  /* Rotate? */\n        char_T *buffer    = var->data.re;\n        int_T  done       = 0; /* done: 0 (1) rotate real (imag) part. */\n\n        do {\n            char_T *col       = buffer;\n            int_T  rowOffset  = (int_T)((nDims == 1) ? (elSize) : (elSize * nCols));\n            int_T  colOffset  = (int_T)((nDims == 1)?  (nRows*elSize) : elSize);\n            int_T  zeroIdx    = var->rowIdx;\n            int_T  j;\n\n            for (j = 0 ; j < nCols; ++j, col += colOffset) {\n                int_T   swapCount;\n                int_T   srcIdx;\n                int_T   dstIdx;\n                int_T   tmpIdx;\n                MatReal tmp;\n\n                for (tmpIdx=0, swapCount=0; swapCount < nRows; tmpIdx++) {\n                    (void)memcpy(&tmp, col + tmpIdx*rowOffset, elSize);\n\n                    dstIdx=tmpIdx; \n                    srcIdx = ((dstIdx + zeroIdx) % nRows);\n                    while (srcIdx != tmpIdx) {\n                        (void)memcpy(col + dstIdx*rowOffset,\n                                     col + srcIdx*rowOffset,\n                                     elSize);\n                        ++swapCount;\n                        dstIdx = srcIdx;\n                        srcIdx = ((dstIdx + zeroIdx) % nRows);\n                        \n                    }\n                    (void)memcpy(col + dstIdx*rowOffset, &tmp, elSize);\n                    ++swapCount;\n                }\n            }\n            done ++;\n            /* need to rotate the imaginary part */\n        } while ((done == 1) && ((buffer = var->data.im) != NULL));\n\n        var->rowIdx = 0;\n    } /* Rotate? */\n\n    /*\n     * We might have allocated more number of rows than the number of data\n     * points that have been logged, in which case set nRows to nDataPoints\n     * so that only these values get saved.\n     */\n    if (var->nDataPoints < var->data.nRows) {\n        var->data.nRows = var->nDataPoints;\n        if(var->valDims != NULL){\n            size_t elSizeValDims = sizeof(real_T);\n            int_T  k;\n            real_T *dimsData = var->valDims->dimsData + nRows;\n            /* \n               Keep nRows of values and that of valueDimensions consistent \n               for variable-size signals.\n            */\n            var->valDims->nRows = var->data.nRows;\n            /*\n               Also need to move data when shrinking the array size,\n               because valueDimensions data is stored in array format. \n               e.g. maxRows = 4; nRows = 2; nDims = 3;\n               Before fixing up the logVar, the locations of data are as below:\n               (x, y, z -- useful data / o -- junk)\n               a[0] = x    a[4] = y    a[8] = z\n               a[1] = x    a[5] = y    a[9] = z\n               a[2] = o    a[6] = o    a[10]= o\n               a[3] = o    a[7] = o    a[11]= o\n               After fixing up the logVar, we want the data to be stored as:\n               a[0] = x    a[4] = z    a[8] = o\n               a[1] = x    a[5] = z    a[9] = o\n               a[2] = y    a[6] = o    a[10]= o\n               a[3] = y    a[7] = o    a[11]= o\n            */\n            for(k = 1; k < nDims; k++){\n                (void) memmove(dimsData, \n                              var->valDims->dimsData + k*maxRows,\n                              elSizeValDims * nRows);\n                dimsData += nRows;\n            }\n        }\n    }\n    return(NULL);\n\n} /* end rt_FixupLogVar */\n\n\n/* Function: rt_LoadModifiedLogVarName =========================================\n * Abstract:\n *      The name of the logged variable is obtained from the input argument\n *      varName and the nameModifier which is obtained from the simstruct. If\n *      the nameModifier begins with an '_', then nameModifier is post-pended to\n *      varName to obtain the name of the logged variable. If the first\n *      character does not begin with an '_', then the nameModifier is\n *      pre-pended to varName.\n *\n * Examples:\n *     a)  varName = \"tout\" & nameModifier = \"_rt\"  => logVarName = \"tout_rt\"\n *     b)  varName = \"tout\" & nameModifier = \"rt_\"  => logVarName = \"rt_tout\"\n *     c)  varName = \"tout\" & nameModifier = \"none\" => logVarName = \"tout\"\n */\nstatic void rt_LoadModifiedLogVarName(const RTWLogInfo *li,         /* in  */\n                                      const char       *varName,    /* in  */\n                                      char             *logVarName) /* out */\n{\n    int_T        nameLen;\n    const char_T *nameModifier = rtliGetLogVarNameModifier(li);\n\n    if (nameModifier != NULL && strcmp(nameModifier,\"none\")==0) {\n        nameModifier = NULL;\n    }\n\n    logVarName[mxMAXNAM-1] = '\\0';\n    if (nameModifier == NULL) {\n        (void)strncpy(logVarName, varName, mxMAXNAM-1);\n    } else if (nameModifier[0] == '_') {\n        (void)strncpy(logVarName, varName, mxMAXNAM-1);\n        nameLen = (int_T)strlen(logVarName);\n        (void)strncat(logVarName, nameModifier, (size_t)mxMAXNAM-1-nameLen);\n    } else {\n        (void)strncpy(logVarName, nameModifier, mxMAXNAM-1);\n        nameLen = (int_T)strlen(logVarName);\n        (void)strncat(logVarName, varName, (size_t)mxMAXNAM-1-nameLen);\n    }\n\n} /* end rt_LoadModifiedLogVarName */\n\n\n/* Function: rt_GetActualDTypeID ===============================================\n * Abstract:\n *\tGiven a built-in data type id, return the actual data type id.\n *\tThe only time these are different is when real_T has been mapped\n *\tto a single.\n */\n#if defined(_MSC_VER)\n #pragma warning(push)\n #pragma warning(disable: 4127)\n#endif\nstatic BuiltInDTypeId rt_GetActualDTypeID(BuiltInDTypeId dTypeID)\n{\n    /*LINTED E_FALSE_LOGICAL_EXPR*/\n    if (dTypeID == SS_DOUBLE && sizeof(real_T) != 8) {     /* polyspace DEFECT:DEAD_CODE \n                                                              [Not a defect:Unset] \n                                                              \"Needed for when real_T has been \n                                                              mapped to a single\" */\n        return(SS_SINGLE);\n    } else {\n        return(dTypeID);\n    }\n\n} /* end rt_GetActualDTypeID */\n#if defined(_MSC_VER)\n #pragma warning(pop)\n#endif\n\n\n/* Function: rt_DestroyLogVar ==================================================\n * Abstract:\n *      Destroy the log var linked list.\n */\nstatic void rt_DestroyLogVar(LogVar *head)\n{\n    while(head) {\n        LogVar *var = head;\n        head = var->next;\n        FREE(var->data.re);\n        FREE(var->data.im);\n        if (var->data.dims != var->data._dims) {\n            FREE(var->data.dims);\n        }\n        /* free valDims if necessary */\n        if(var->valDims != NULL) {\n            FREE(var->valDims->dimsData);\n            FREE(var->valDims);\n        }\n        /* free coords, strides and currStrides if necessary */\n        FREE(var->coords);\n        FREE(var->strides);\n        FREE(var->currStrides);\n\n        FREE(var);\n    }\n\n} /* end rt_DestroyLogVar */\n\n\n/* Function: rt_DestroyStructLogVar ============================================\n * Abstract:\n *      Destroy the struct log var linked list.\n */\nstatic void rt_DestroyStructLogVar(StructLogVar *head)\n{\n    while(head) {\n        StructLogVar *var = head;\n\n        head = var->next;\n\n        if (var->logTime) { /* time is LogVar */\n            rt_DestroyLogVar(var->time);\n        } else {        /* time is MatrixData */\n            FREE(var->time);\n        }\n        rt_DestroyLogVar(var->signals.values);\n        FREE(var->signals.labels);\n        FREE(var->signals.plotStyles);\n        FREE(var->signals.dimensions);\n        FREE(var->signals.titles);\n        FREE(var->signals.blockNames);\n        FREE(var->signals.stateNames);\n        FREE(var->signals.crossMdlRef);\n        FREE(var->blockName);\n        FREE(var);\n    }\n\n} /* end rt_DestroyStructLogVar */\n\n\n/* Function: rt_InitSignalsStruct ==============================================\n * Abstract:\n *      Initialize the signals structure in the struct log variable.\n *\n * Returns:\n *\t== NULL  => success.\n *\t~= NULL  => failure, the return value is a pointer to the error\n *                           message, which is also set in the simstruct.\n */\nstatic const char_T *rt_InitSignalsStruct(RTWLogInfo             *li,\n                                          const real_T           startTime,\n                                          const real_T           finalTime,\n                                          const real_T           inStepSize,\n                                          const char_T           **errStatus,\n                                          StructLogVar           *var,\n                                          int_T                  maxRows,\n                                          int_T                  decimation,\n                                          real_T                 sampleTime,\n                                          const RTWLogSignalInfo *sigInfo)\n{\n    int_T                i, sigIdx;\n    SignalsStruct        *sig          = &(var->signals);\n    int_T                nSignals      = sigInfo->numSignals;\n    const int_T          *numCols      = sigInfo->numCols;\n    const int_T          *numDims      = sigInfo->numDims;\n    const int_T          *dims         = sigInfo->dims;\n    const BuiltInDTypeId *dTypes       = sigInfo->dataTypes;\n    const int_T          *cSgnls       = sigInfo->complexSignals;\n    const int_T          *fData        = sigInfo->frameData;\n    const char_T         **labels      = sigInfo->labels.cptr;\n    const int_T          *plotStyles   = sigInfo->plotStyles;\n    const char_T         *titles       = sigInfo->titles;\n    const int_T          *titleLen     = sigInfo->titleLengths;\n    const char_T         **blockNames  = sigInfo->blockNames.cptr;\n    const char_T         **stateNames  = sigInfo->stateNames.cptr;\n    const boolean_T      *crossMdlRef  = sigInfo->crossMdlRef;\n    void                 **currSigDims = sigInfo->currSigDims;\n    int_T                *currSigDimsSize = sigInfo->currSigDimsSize;\n    LogVar               *prevValues   = NULL;\n    int_T                dimsOffset    = 0;\n    boolean_T            *isVarDims    = sigInfo->isVarDims;\n    /* if any signal is variable-size, the field 'valueDimensions' is needed */\n    boolean_T            logValueDimensions = false;\n    const RTWLogDataTypeConvert *pDTConvInfo = sigInfo->dataTypeConvert;\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    sig->numActiveFields = 1;\n    sig->numSignals      = nSignals;\n\n    sig->isVarDims = isVarDims;\n    /* check whether we need valueDimensions field*/\n    for (i=0; i<nSignals; i++){\n        if(isVarDims[i]){\n            logValueDimensions = true;\n            break;\n        }\n    }\n\n    /* values */\n    dimsOffset = 0;\n    for (i = 0; i < nSignals; i++) {\n        BuiltInDTypeId dt = (dTypes) ? dTypes[i] : SS_DOUBLE;\n        int_T          cs = (cSgnls) ? cSgnls[i] : 0;\n        int_T          fd = (fData)  ? fData[i]  : 0;\n        int_T          nd = (numDims) ? numDims[i] : 1;\n\n        const RTWLogDataTypeConvert *pDTConvInfoCur =\n                       (pDTConvInfo)  ? (pDTConvInfo+i)  : 0;\n\n        LogVar *values = NULL;\n        LogValDimsStat logValDimsStat;\n\n        if(!logValueDimensions){\n            logValDimsStat = NO_LOGVALDIMS;\n        }\n        else{\n            logValDimsStat = isVarDims[i] ? LOGVALDIMS_VARDIMS :  \n                                            LOGVALDIMS_EMPTYMX;\n        }\n\n        values = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                            inStepSize, errStatus,\n                                            &VALUES_FIELD_NAME,\n                                            dt, \n                                            pDTConvInfoCur,\n                                            0, cs, fd,\n                                            numCols[i],nd,\n                                            dims + dimsOffset,\n                                            logValDimsStat,\n                                            currSigDims + dimsOffset,\n                                            currSigDimsSize + dimsOffset,\n                                            maxRows,decimation,sampleTime, 0);\n\n        if (values == NULL) goto ERROR_EXIT;\n\n        if (sig->values == NULL) {\n            sig->values = values;\n        } else {\n            if (prevValues == NULL) goto ERROR_EXIT;\n            prevValues->next = values;\n        }\n        prevValues = values;\n        dimsOffset += nd;\n    }\n\n    if(logValueDimensions){\n        ++sig->numActiveFields;\n        sig->logValueDimensions = true;\n    }\n    else{\n        sig->logValueDimensions = false;\n    }\n\n    /* Dimensions */\n    {\n        real_T         *data;\n        size_t\t       nbytes;\n        int_T          dataLen    = 0;\n        BuiltInDTypeId dTypeId    = rt_GetActualDTypeID(SS_DOUBLE);\n        size_t         dataOffset = nSignals*sizeof(MatrixData);\n        uint_T         overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n        for (i=0; i< nSignals; i++) {\n            int_T nd = (numDims) ? numDims[i] : 1;\n            dataLen += nd;\n        }\n        nbytes = dataOffset + dataLen*sizeof(real_T);\n\n        if ( (sig->dimensions = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (real_T*) (((char_T*) (sig->dimensions)) + dataOffset);\n\n        for (i = 0; i < dataLen; i++) {\n          data[i] = dims[i]; /* cannot memcpy double <- int */\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->dimensions[i]);\n            int_T nd = (numDims) ? numDims[i] : 1;\n\n            (void)memcpy(mtxData->name, &DIMENSION_FIELD_NAME, mxMAXNAM);\n\n            mtxData->nRows   = 1;\n            mtxData->nCols   = nd;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = dTypeId;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(dTypeId);\n            mtxData->elSize  = rt_GetSizeofDataType(dTypeId);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += nd;\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* labels */\n    if (labels != NULL) {\n        unsigned short   *data;\n        size_t  nbytes;\n        int_T   dataLen    = 0;\n        size_t  dataOffset = nSignals * sizeof(MatrixData);\n        uint_T  overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (labels[i] != NULL){\n                dataLen = dataLen + (int_T)strlen(labels[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->labels = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->labels)) + dataOffset);\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T labelLen = (labels[sigIdx]==NULL) ? 0 : (int_T)strlen(labels[sigIdx]);\n            for (i = 0; i < labelLen; i++) {\n                data[dataIdx++] = (uint8_T)labels[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->labels[i]);\n            int_T labelLen = (int_T)strlen(labels[i]);\n\n            (void)memcpy(mtxData->name, &LABEL_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (labelLen) ? 1 : 0;\n            mtxData->nCols   = labelLen;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += labelLen;\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* plot styles */\n    if (plotStyles != NULL) {\n        real_T         *data;\n        size_t\t       nbytes;\n        int_T          dataLen    = 0;\n        BuiltInDTypeId dTypeId    = rt_GetActualDTypeID(SS_DOUBLE);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        size_t         dataOffset = nSignals*sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T         overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n        for (i=0; i< nSignals; i++) {\n            dataLen += numCols[i];\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(real_T);\n\n        if ( (sig->plotStyles = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        /*LINTED E_BAD_PTR_CAST_ALIGN*/\n        data = (real_T*) (((char_T*) (sig->plotStyles)) + dataOffset);\n\n        for (i = 0; i < dataLen; i++) {\n            data[i] = plotStyles[i];\n        }\n\n        dimsOffset = 0;\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->plotStyles[i]);\n            \n            (void)memcpy(mtxData->name, &PLOTSTYLE_FIELD_NAME, mxMAXNAM);\n\n            mtxData->nRows   = (numCols[i]) ? 1 : 0;\n            mtxData->nCols   = numCols[i];\n\n            mtxData->nDims   = numDims[i];\n            \n            if(mtxData->nDims > 2) {\n                if ((mtxData->dims = calloc(mtxData->nDims, sizeof(int_T))) == NULL) goto ERROR_EXIT;\n            } else {\n                mtxData->dims    = mtxData->_dims;\n            }\n            \n            mtxData->dims[0] = *(dims + dimsOffset);\n            if(mtxData->nDims >= 2) {\n                int32_T j;\n                for (j=1; j<mtxData->nDims; j++) {\n                    mtxData->dims[j] = *(dims + dimsOffset + j);\n                }\n            }\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = dTypeId;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(dTypeId);\n            mtxData->elSize  = rt_GetSizeofDataType(dTypeId);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data       += numCols[i];\n            dimsOffset += numDims[i];\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* titles */\n    if (titles != NULL) {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen    = (int_T)strlen(titles);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        size_t  dataOffset = nSignals * sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T  overhang   = (uint_T)(dataOffset % sizeof(short));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->titles = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        /*LINTED E_BAD_PTR_CAST_ALIGN*/\n        data = (unsigned short*) (((char_T*) (sig->titles)) + dataOffset);\n        for (i = 0; i < dataLen; i++) {\n            data[i] = titles[i];\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->titles[i]);\n\n            (void)memcpy(mtxData->name, &TITLE_FIELD_NAME, mxMAXNAM);\n            if (titleLen) {\n                mtxData->nRows   = (titleLen[i]) ? 1 : 0;\n                mtxData->nCols   = titleLen[i];\n            } else {\n                mtxData->nRows   = (dataLen) ? 1 : 0;\n                mtxData->nCols   = dataLen;\n            }\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += ((titleLen) ? titleLen[i] : dataLen);\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* block names */\n    if (blockNames != NULL)     {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen = 0;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T  dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (blockNames[i] != NULL) {\n                dataLen = dataLen + (int_T)strlen(blockNames[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->blockNames = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->blockNames)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T nameLen = (blockNames[sigIdx]==NULL) ? 0 : \n                (int_T)strlen(blockNames[sigIdx]);\n            for (i = 0; i < nameLen; i++) {\n                data[dataIdx++] = (uint8_T)blockNames[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->blockNames[i]);\n            int_T blockNameLen = (int_T)strlen(blockNames[i]);\n\n            (void)memcpy(mtxData->name, &BLOCKNAME_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (blockNameLen) ? 1 : 0;\n            mtxData->nCols   = blockNameLen;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += blockNameLen;\n        }\n        ++sig->numActiveFields;\n        if(logValueDimensions){\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    } else {\n        if(logValueDimensions){\n            sig->fieldNames = rtLocalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtLocalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    }\n\n    /* state names */\n    if (stateNames != NULL) {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen = 0;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T  dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (stateNames[i] != NULL) {\n                dataLen = dataLen + (int_T)strlen(stateNames[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->stateNames = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->stateNames)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T nameLen = (stateNames[sigIdx]==NULL) ? 0 : \n                (int_T)strlen(stateNames[sigIdx]);\n            for (i = 0; i < nameLen; i++) {\n                data[dataIdx++] = (uint8_T)stateNames[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->stateNames[i]);\n            int_T stateNameLen = (int_T)strlen(stateNames[i]);\n\n            (void)memcpy(mtxData->name, &STATENAME_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (stateNameLen) ? 1 : 0;\n            mtxData->nCols   = stateNameLen;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += stateNameLen;\n        }\n        ++sig->numActiveFields;\n\n        if(logValueDimensions){\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    }\n\n    /* CrossMdlRef */\n    if (crossMdlRef != NULL) {\n        real_T  *data;\n        size_t nbytes;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n\n        nbytes = dataOffset + nSignals*sizeof(real_T);\n\n        if ( (sig->crossMdlRef = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (real_T*) (((char_T*) (sig->crossMdlRef)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            data[sigIdx] = crossMdlRef[sigIdx];\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->crossMdlRef[i]);\n\n            (void)memcpy(mtxData->name, &CROSS_MDL_REF_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = 1;\n            mtxData->nCols   = 1;\n            mtxData->nDims   = 1; /* => matlab scalar */\n\n            mtxData->re      = &data[i];\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_DOUBLE;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(SS_DOUBLE);\n            mtxData->elSize  = sizeof(real_T);\n            mtxData->logical = matLOGICAL_BIT;\n            mtxData->complex = 0U;\n            mtxData->frameData = 0;\n            mtxData->frameSize = 1;\n        }\n        ++sig->numActiveFields;\n    }\n    \n    return(NULL); /* NORMAL_EXIT */\n\n  ERROR_EXIT:\n\n    (void)fprintf(stderr, \"*** Error creating signals structure \"\n                  \"in the struct log variable %s\\n\", var->name);\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    rt_DestroyLogVar(sig->values);\n    FREE(sig->labels);\n    FREE(sig->plotStyles);\n    FREE(sig->dimensions);\n    FREE(sig->titles);\n    FREE(sig->blockNames);\n    FREE(sig->stateNames);\n    FREE(sig->crossMdlRef);\n    return(*errStatus);\n\n} /* end rt_InitSignalsStruct */\n\n\n/* Function: local_CreateStructLogVar ==========================================\n * Abstract:\n *      Create a logging variable in the structure format.\n *\n * Returns:\n *      ~= NULL  => success, returns the log variable created.\n *      == NULL  => failure, error message set in the simstruct.\n */\nstatic StructLogVar *local_CreateStructLogVar(\n    RTWLogInfo              *li,\n    const real_T            startTime,\n    const real_T            finalTime,\n    const real_T            inStepSize,\n    const char_T            **errStatus,\n    const char_T            *varName,\n    boolean_T               logTime,\n    int_T                   maxRows,\n    int_T                   decimation,\n    real_T                  sampleTime,\n    const RTWLogSignalInfo  *sigInfo,\n    const char_T            *blockName)\n{\n    StructLogVar *var;\n    LogInfo      *logInfo = rtliGetLogInfo(li);\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    if ( (var = calloc(1, sizeof(StructLogVar))) == NULL ) goto ERROR_EXIT;\n\n    var->numActiveFields = 2;\n\n    /* Setup the structure name using varName and nameModifier */\n    rt_LoadModifiedLogVarName(li,varName,var->name);\n\n    /* time field */\n    if (logTime) {\n        /* need to create a LogVar to log time */\n        int_T dims = 1;\n        var->time = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                               inStepSize, errStatus,\n                                               &TIME_FIELD_NAME, SS_DOUBLE, \n                                               NULL,\n                                               0, 0, 0, 1,\n                                               1, &dims, NO_LOGVALDIMS, \n                                               NULL, NULL, maxRows,\n                                               decimation, sampleTime, 0);\n        if (var->time == NULL) goto ERROR_EXIT;\n    } else {\n        /* create a dummy MatrixData to write out time as an empty matrix */\n        BuiltInDTypeId dt     = rt_GetActualDTypeID(SS_DOUBLE);\n        size_t         nbytes = sizeof(MatrixData);\n        MatrixData     *time;\n\n        if ( (var->time = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n        time = var->time;\n\n        (void)memcpy(time->name, &TIME_FIELD_NAME, mxMAXNAM);\n        time->nRows   = 0;\n        time->nCols   = 0;\n        time->nDims   = 0;\n        time->re      = NULL;\n        time->im      = NULL;\n        time->dTypeID = dt;\n        time->mxID    = rt_GetMxIdFromDTypeId(dt);\n        time->elSize  = rt_GetSizeofDataType(dt);\n        time->logical = 0U;\n        time->complex = 0U;\n    }\n    var->logTime = logTime;\n\n    /* signals field */\n    if (sigInfo) {\n        if (rt_InitSignalsStruct(li,startTime,finalTime,inStepSize,errStatus,\n                                 var,maxRows,decimation,sampleTime,sigInfo)) {\n            goto ERROR_EXIT;\n        }\n    }\n\n    /* blockName Field */\n    if (blockName != NULL) {\n        int_T  dataLen = (int_T)strlen(blockName);\n        size_t nbytes;\n        size_t dataOffset = sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (var->blockName = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        (void)memcpy(var->blockName->name, &BLOCKNAME_FIELD_NAME, mxMAXNAM);\n        var->blockName->nRows   = (dataLen) ? 1 : 0;\n        var->blockName->nCols   = dataLen;\n\n        var->blockName->nDims   = 1;\n        var->blockName->dims    = var->blockName->_dims;\n        var->blockName->dims[0] = dataLen;\n        {\n            /*LINTED E_BAD_PTR_CAST_ALIGN*/\n            unsigned short *data = (unsigned short*)(((char_T*) (var->blockName))+dataOffset);\n            int_T   i;\n\n            for (i=0; i<dataLen; i++) {\n                data[i] = (uint8_T)blockName[i];\n            }\n            var->blockName->re  = data;\n        }\n        var->blockName->im      = NULL;\n        var->blockName->dTypeID = SS_INT16;\n        var->blockName->mxID    = mxCHAR_CLASS;\n        var->blockName->elSize  = sizeof(short);\n        var->blockName->logical = 0U;\n        var->blockName->complex = 0U;\n\n        ++var->numActiveFields;\n    }\n\n    /* Add this struct log var to the linked list in log info */\n    {\n        StructLogVar *list = logInfo->structLogVarsList;\n\n        if (list != NULL) {\n            while (list->next != NULL) {\n                list = list->next;\n            }\n            list->next = var;\n        } else {\n            logInfo->structLogVarsList = var;\n        }\n    }\n\n    return(var); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Error creating log variable %s\\n\", varName);\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    rt_DestroyStructLogVar(var);\n    return(NULL);\n\n} /* end local_CreateStructLogVar */\n\n\n/* Function: rt_StartDataLoggingForOutput ======================================\n * Abstract:\n */\nstatic const char_T *rt_StartDataLoggingForOutput(RTWLogInfo   *li,\n                                                  const real_T startTime,\n                                                  const real_T finalTime,\n                                                  const real_T stepSize,\n                                                  const char_T **errStatus)\n{\n    const char_T   *varName;\n    real_T         sampleTime = stepSize;\n    int_T          maxRows    = rtliGetLogMaxRows(li);\n    int_T          decimation = rtliGetLogDecimation(li);\n    int_T          logFormat  = rtliGetLogFormat(li);\n    boolean_T      logTime    = (logFormat==2) ? 1 : 0;\n\n    LogInfo *       logInfo;\n    logInfo = rtliGetLogInfo(li);\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    /* outputs */\n    varName = rtliGetLogY(li);\n    if (varName[0] != '\\0') {\n        int_T                  i;\n        int_T                  ny;\n        int_T                  yIdx;\n        char_T                 name[mxMAXNAM];\n        const char_T           *cp        = strchr(varName,',');\n        LogSignalPtrsType      ySigPtrs   = rtliGetLogYSignalPtrs(li);\n        const RTWLogSignalInfo *yInfo     = rtliGetLogYSignalInfo(li);\n\n        /* count the number of variables (matrices or structures) to create */\n        for (ny=1; cp != NULL; ny++) {\n            cp = strchr(cp+1,',');\n        }\n        logInfo->ny = ny;\n\n        if (logFormat==0) {\n            if ( (logInfo->y = calloc(ny,sizeof(LogVar*))) == NULL ) {\n                *errStatus = rtMemAllocError;\n                goto ERROR_EXIT;\n            }\n        } else {\n            if ( (logInfo->y = calloc(ny,sizeof(StructLogVar*))) == NULL ) {\n                *errStatus = rtMemAllocError;\n                goto ERROR_EXIT;\n            }\n        }\n\n        for (i = yIdx = 0, cp = varName; i < ny; i++) {\n            int_T        len;\n            const char_T *cp1 = strchr(cp+1,',');\n\n            if (cp1 != NULL) {\n                /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n                len = (int_T)(cp1 - cp);\n                if (len >= mxMAXNAM) len = mxMAXNAM - 1;\n            } else {\n                len = mxMAXNAM - 1;\n            }\n            (void)strncpy(name, cp, len);\n            name[len] = '\\0';\n\n            if (ny > 1 && ySigPtrs[i] == NULL) {\n                goto NEXT_NAME;\n            }\n\n            if (logFormat == 0) {\n                int            numCols;\n                int            nDims;\n                const int      *dims;\n                BuiltInDTypeId dataType;\n                int            isComplex;\n\n                if (ny == 1) {\n                    int_T op;\n\n                    numCols = yInfo[0].numCols[0];\n                    for (op = 1; op < yInfo[0].numSignals; op++) {\n                        numCols += yInfo[0].numCols[op];\n                    }\n                    /*\n                     * If we have only one \"matrix\" outport,\n                     * we can still log it as a matrix\n                     */\n                    if (yInfo[0].numSignals == 1) {\n                        nDims = yInfo[0].numDims ? yInfo[0].numDims[0] : 1;\n                        dims  = yInfo[0].dims;\n                    } else {\n                        nDims = 1;\n                        dims  = &numCols;\n                    }\n\n                    dataType  = yInfo[0].dataTypes[0];\n                    isComplex = yInfo[0].complexSignals[0];\n                } else {\n                    numCols   = yInfo[yIdx].numCols[0];\n                    nDims     = yInfo[yIdx].numDims ? yInfo[yIdx].numDims[0] : 1;\n                    dims      = yInfo[yIdx].dims;\n                    dataType  = yInfo[yIdx].dataTypes[0];\n                    isComplex = yInfo[yIdx].complexSignals[0];\n                }\n\n                logInfo->y[yIdx] = rt_CreateLogVarWithConvert(\n                    li, startTime, finalTime,\n                    stepSize, errStatus,\n                    name,\n                    dataType,\n                    yInfo[yIdx].dataTypeConvert,\n                    0,isComplex,\n                    0,numCols,nDims,dims,\n                    NO_LOGVALDIMS, NULL, NULL,\n                    maxRows,decimation,\n                    sampleTime,1);\n                if (logInfo->y[yIdx] == NULL)  goto ERROR_EXIT;\n            } else {\n                logInfo->y[yIdx] = local_CreateStructLogVar(li, startTime,\n                                                            finalTime, stepSize,\n                                                            errStatus, name,\n                                                            logTime, maxRows,\n                                                            decimation, sampleTime,\n                                                            &yInfo[yIdx], NULL);\n                if (logInfo->y[yIdx] == NULL) goto ERROR_EXIT;\n            }\n            ++yIdx;\n        NEXT_NAME:\n            cp = cp1;\n            if (cp != NULL && *cp == ',') cp++;\n        }\n    }\n\n    return(NULL); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Errors occurred when starting data logging.\\n\");\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    if (logInfo) { /* polyspace DEFECT:USELESS_IF [No action planned:Unset] \n                     \"Defense coding.\" */\n        rt_DestroyLogVar(logInfo->logVarsList);\n        logInfo->logVarsList = NULL;\n        rt_DestroyStructLogVar(logInfo->structLogVarsList);\n        logInfo->structLogVarsList = NULL;\n        FREE(logInfo->y);\n        logInfo->y = NULL;\n    }\n    return(*errStatus);\n\n} /* end rt_StartDataLoggingForOutput */\n\n\n/* Function: rt_ReallocLogVar ==================================================\n * Abstract:\n *   Allocate more memory for the data buffers in the log variable.\n *   Exit if unable to allocate more memory.\n */\nstatic void rt_ReallocLogVar(LogVar *var, boolean_T isVarDims)\n{\n    void *tmp;\n    int_T nCols = var->data.nCols;\n    int_T nRows;\n    size_t elSize = var->data.elSize;\n\n    if (isVarDims)\n    {\n        nRows = var->data.nRows + DEFAULT_BUFFER_SIZE;\n    }\n    else\n    {\n        nRows = var->data.nRows == 0 ? 1 : 2*var->data.nRows;\n    }\n    \n    tmp = realloc(var->data.re, nRows*nCols*elSize);\n    if (tmp == NULL) {\n        (void)fprintf(stderr,\n                      \"*** Memory allocation error.\\n\");\n        (void)fprintf(stderr, \"\"\n                      \"    varName          = %s%s\\n\"\n                      \"    nRows            = %d\\n\"\n                      \"    nCols            = %d\\n\"\n                      \"    elementSize      = %lu\\n\"\n                      \"    Current Size     = %.16g\\n\"\n                      \"    Failed resize    = %.16g\\n\\n\",\n                      var->data.name,\n                      var->data.complex ? \" (real part)\" : \"\",\n                      var->data.nRows,\n                      var->data.nCols,\n                      (unsigned long)  var->data.elSize,\n                      (double)nRows*nCols*elSize,\n                      (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n        exit(1);\n    }\n    var->data.re = tmp;\n\n    if (var->data.complex) {\n        tmp = realloc(var->data.im, nRows*nCols*elSize);\n        if (tmp == NULL) {\n            (void)fprintf(stderr,\n                          \"*** Memory allocation error.\\n\");\n            (void)fprintf(stderr, \"\"\n                          \"    varName          = %s (complex part)\\n\"\n                          \"    nRows            = %d\\n\"\n                          \"    nCols            = %d\\n\"\n                          \"    elementSize      = %lu\\n\"\n                          \"    Current Size     = %.16g\\n\"\n                          \"    Failed resize    = %.16g\\n\\n\",\n                          var->data.name,\n                          var->data.nRows,\n                          var->data.nCols,\n                          (unsigned long)  var->data.elSize,\n                          (double)nRows*nCols*elSize,\n                          (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n            exit(1);\n        }\n        var->data.im = tmp;\n    }\n    var->data.nRows = nRows;\n\n    /* Also reallocate memory for \"valueDimensions\" \n       when logging the variable-size signal\n    */\n    if(isVarDims){\n        int_T k;\n        \n        nCols = var->valDims->nCols;\n        nRows = var->valDims->nRows + DEFAULT_BUFFER_SIZE;\n        elSize = sizeof(real_T);\n        tmp = realloc(var->valDims->dimsData, nRows*nCols*elSize);\n        if (tmp == NULL) {\n            (void)fprintf(stderr,\n                          \"*** Memory allocation error.\\n\");\n            (void)fprintf(stderr, \"\"\n                          \"    varName          = %s\\n\"\n                          \"    nRows            = %d\\n\"\n                          \"    nCols            = %d\\n\"\n                          \"    elementSize      = %lu\\n\"\n                          \"    Current Size     = %.16g\\n\"\n                          \"    Failed resize    = %.16g\\n\\n\",\n                          var->valDims->name,\n                          var->valDims->nRows,\n                          var->valDims->nCols,\n                          (unsigned long)  elSize,\n                          (double)nRows*nCols*elSize,\n                          (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n            exit(1);\n        }\n\n        /*\n         * valueDimensions data is stored in array format and must be\n         * adjusted after reallocation (see also rt_FixupLogVar())\n         *\n         * Example: maxRows = 4; nRows = 4; nDims = 3;\n         * Before realloc of the logVar, the locations of data are as below:\n         * (x, y, z -- useful data / o -- junk, don't care)\n         * a[0] = x    a[4] = y    a[8] = z\n         * a[1] = x    a[5] = y    a[9] = z\n         * a[2] = x    a[6] = y    a[10]= z\n         * a[3] = x    a[7] = y    a[11]= z\n         *\n         * After realloc of the logVar (suppose 2 extra rows are added),\n         * the locations of data are as below:\n         * a[0] = x    a[6] = y    a[12]= o\n         * a[1] = x    a[7] = y    a[13]= o\n         * a[2] = x    a[8] = z    a[14]= o\n         * a[3] = x    a[9] = z    a[15]= o\n         * a[4] = y    a[10]= z    a[16]= o\n         * a[5] = y    a[11]= z    a[17]= o\n         *\n         * The data must be adjusted as below:\n         * a[0] = x    a[6] = y    a[12]= z\n         * a[1] = x    a[7] = y    a[13]= z\n         * a[2] = x    a[8] = y    a[14]= z\n         * a[3] = x    a[9] = y    a[15]= z\n         * a[4] = o    a[10]= o    a[16]= o\n         * a[5] = o    a[11]= o    a[17]= o\n         */\n        for(k = var->data.nDims-1; k > 0; k--){\n            (void) memcpy((real_T*)tmp + k*nRows, \n                          (real_T*)tmp + k*var->valDims->nRows,\n                          elSize * var->valDims->nRows);\n        }\n\n        var->valDims->dimsData = tmp;\n        var->valDims->nRows = nRows;\n    }\n\n} /* end rt_ReallocLogVar */\n\nconst char_T *rt_UpdateLogVarWithDiscontiguousData(LogVar                 *var,\n                                             int8_T**               data,\n                                             const int_T            *segmentLengths,\n                                             int_T                  nSegments,\n                                             RTWPreprocessingFcnPtr *preprocessingPtrs);\n                                             \n/* Function: rt_UpdateLogVarWithDiscontinuousData ==============================\n * Abstract:\n *      Log one row of the LogVar with data that is not contiguous.\n */\nconst char_T *rt_UpdateLogVarWithDiscontiguousData(LogVar                 *var,\n                                             int8_T**               data,\n                                             const int_T            *segmentLengths,\n                                             int_T                  nSegments,\n                                             RTWPreprocessingFcnPtr *preprocessingPtrs)\n{\n    size_t elSize = 0;\n    size_t offset = 0;\n    int    segIdx = 0;\n\n    if (++var->numHits % var->decimation) return(NULL);\n    var->numHits = 0;\n\n    /*\n     * Reallocate or wrap the LogVar\n     */\n    if (var->rowIdx == var->data.nRows) {\n        if (var->okayToRealloc == 1) {\n            rt_ReallocLogVar(var, false);\n        } else {\n            /* Circular buffer */\n            var->rowIdx = 0;\n            ++(var->wrapped); /* increment the wrap around counter */\n        }\n    }\n\n    /* This function is only used to log states, there's no var-dims issue. */\n    elSize = var->data.elSize;\n    offset = (size_t)(elSize * var->rowIdx * var->data.nCols);\n\n    if (var->data.complex) {\n        char_T *dstRe = (char_T*)(var->data.re) + offset;\n        char_T *dstIm = (char_T*)(var->data.im) + offset;\n\n        for (segIdx = 0; segIdx < nSegments; segIdx++) {\n            int_T         nEl  = segmentLengths[segIdx];\n            char_T *src        = (char_T *)data[segIdx];\n            int_T         el;\n\n            /* preprocess data in-place before logging */\n            RTWPreprocessingFcnPtr preprocessingPtr = preprocessingPtrs[segIdx];\n            if (preprocessingPtr != NULL) {\n                src = malloc(elSize * nEl * 2);\n                preprocessingPtr(src, (void *)data[segIdx]);\n            }\n\n            if (src == NULL) {\n                const char_T *errorMessage = \"Could not allocate memory for logging.\";\n                fprintf(stderr,\"%s.\\n\", errorMessage);\n                return(errorMessage);\n            }\n            else {\n                for (el = 0; el < nEl; el++) {\n                    (void)memcpy(dstRe, src, elSize);\n                    dstRe += elSize;   src += elSize;\n                    (void)memcpy(dstIm, src, elSize);\n                    dstIm += elSize;   src += elSize;\n                }\n            }\n\n            /* free temporarily declared data */\n            if (preprocessingPtr != NULL) {\n                free( src );\n            }\n        }\n    } else {\n        char_T *dst = (char_T*)(var->data.re) + offset;\n\n        for (segIdx = 0; segIdx < nSegments; segIdx++) {\n            size_t      segSize = elSize*segmentLengths[segIdx];\n            char_T *src         = (void *) data[segIdx];\n\n            /* preprocess data in-place before logging */\n            RTWPreprocessingFcnPtr preprocessingPtr = preprocessingPtrs[segIdx];\n            if (preprocessingPtr != NULL) {\n                src = malloc(segSize);\n                preprocessingPtr(src, data[segIdx]);\n            }\n            if (src == NULL) {\n                const char_T *errorMessage = \"Could not allocate memory for logging.\";\n                fprintf(stderr,\"%s.\\n\", errorMessage);\n                return(errorMessage);            }\n            else {\n                (void)memcpy(dst, src, segSize);\n                dst += segSize;\n            }\n\n            /* free temporarily declared data */\n            if (preprocessingPtr != NULL) {\n                free( src );\n            }\n        }\n    }\n\n    ++var->rowIdx;\n    return(NULL);\n\n} /* end rt_UpdateLogVarWithDiscontinuousData */\n\n\n/*==================*\n * Visible routines *\n *==================*/\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_CreateLogVarWithConvert ========================================\n * Abstract:\n *\tCreate a logging variable.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nLogVar *rt_CreateLogVarWithConvert(\n    RTWLogInfo        *li,\n    const real_T      startTime,\n    const real_T      finalTime,\n    const real_T      inStepSize,\n    const char_T      **errStatus,\n    const char_T      *varName,\n    BuiltInDTypeId    inpDataTypeID,\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo,\n    int_T             logical,\n    int_T             complex,\n    int_T             frameData,\n    int_T             nCols,\n    int_T             nDims,\n    const int_T       *dims,\n    LogValDimsStat    logValDimsStat,\n    void              **currSigDims,\n    int_T             *currSigDimsSize,\n    int_T             maxRows,\n    int_T             decimation,\n    real_T            sampleTime,\n    int_T             appendToLogVarsList)\n{\n    int_T          usingDefaultBufSize = 0;\n#ifdef NO_LOGGING_REALLOC\n    int_T          okayToRealloc       = 0;\n#else\n    int_T          okayToRealloc       = 1;\n#endif\n    LogVar         *var                = NULL;\n    /*inpDataTypeID is the rt_LoggedOutputDataTypeId*/\n    BuiltInDTypeId dTypeID             = (BuiltInDTypeId)inpDataTypeID; \n    size_t         elementSize         = rt_GetSizeofDataType(dTypeID);\n    int_T          frameSize;\n    int_T          nRows;\n    int_T          nColumns;\n\n    /*===================================================================*\n     * Determine the frame size if the data is frame based               *\n     *===================================================================*/\n    frameSize = frameData ? dims[0] : 1;\n\n    /*===================================================================*\n     * Calculate maximum number of rows needed in the buffer             *\n     *===================================================================*/\n\n    if (finalTime > startTime && finalTime != rtInf) {\n        real_T nPoints;            /* Tfinal is finite  ===>  nRows can be  */\n        real_T stepSize;           /* computed since the StepSize is fixed  */\n\n        if (sampleTime == -2.0) {  /* The signal being logged is constant,  *\n                                    * Hence, only one data point is logged. */\n            stepSize = finalTime;\n        } else if (sampleTime == -1.0 || sampleTime == 0.0) {\n                                /* Signal being logged is either inside a    *\n                                 * triggered sub-system or it is continuous. */\n            stepSize = inStepSize;\n        } else {                /* Discrete signal */\n            stepSize = sampleTime;\n        }\n\n        if (stepSize == 0.0) {\n            /* small initial value, so as to exercise the realloc code */\n            nRows = maxRows+1;\n            okayToRealloc = 1;\n        } else {\n            nPoints = 1.0 + floor((finalTime-startTime)/stepSize);\n\n            /*\n             * Add one more data point if needed.\n             */\n            if ( stepSize*(nPoints-1.0) < (finalTime-startTime) ) {\n                nPoints += 1.0;\n            }\n\n            /*\n             * Actual number of points to log = nPoints * size of\n             * each frame if data is frame-based\n             */\n            nPoints = frameData ? (nPoints * frameSize) : nPoints;\n\n            nPoints /= decimation;\n            if (nPoints != floor(nPoints)) {\n                nPoints += 1.0;\n            }\n            nRows = (nPoints <= INT_MAX) ? ((int_T) nPoints) : INT_MAX;\n        }\n        /*\n         * If maxRows is specified, and if this number is less\n         * than the number we computed (nRows) then use maxRows.\n         */\n        if ((maxRows > 0) && (maxRows < nRows)) {\n            nRows = maxRows;\n            okayToRealloc = 0;\n        }\n    } else if (finalTime == startTime) {\n        /*\n         * Number of rows to log is equal to 1 if not frame-based and\n         * equal to frame size if frame-based\n         */\n        nRows = frameData ? frameSize : 1;\n\n        /*\n         * If maxRows is specified, and if this number is less\n         * than the number we computed (nRows) then use maxRows.\n         */\n        if ((maxRows > 0) && (maxRows < nRows)) {\n            nRows = maxRows;\n            okayToRealloc = 0;\n        }\n    } else if (maxRows > 0) {     /* maxRows is specified => nRows=maxRows  */\n        nRows = maxRows;\n        okayToRealloc = 0;\n    } else {\n\n        if (inStepSize == 0) {\n            /* small initial value, so as to exercise the realloc code */\n            nRows = maxRows+1;\n            okayToRealloc = 1;\n        } else {                    /* Use a default value for nRows          */\n            usingDefaultBufSize = 1;\n            nRows = DEFAULT_BUFFER_SIZE;\n            okayToRealloc = 0;  /* No realloc with infinite stop time */\n            (void)fprintf(stdout, \"*** Using a default buffer of size %d for \"\n                          \"logging variable %s\\n\", nRows, varName);\n        }\n    }\n\n    /*\n     * Figure out the number of columns that the log variable should have.\n     * If the data is not frame based, then number of columns should equal\n     * nCols that is provided as input to the function. If the data is\n     * frame-based, then the number of columns should be equal to the\n     * number of channels = nCols/frameSize = dims[1];\n     */\n    nColumns = frameData ? dims[1] : nCols;\n\n    /*\n     * Error out if the size of the circular buffer is absurdly large, this\n     * error message is more informative than the one we get when we try to\n     * malloc this many number of bytes in one fell swoop.\n     */\n    {\n        double tmpDbl = ((double)elementSize)*((double)nRows)*\n                                              ((double)nColumns);\n\n        if (tmpDbl >= UINT_MAX) {\n            (void)fprintf(stderr,\n                          \"\\n*** Memory required to log variable '%s' is too\"\n                          \"\\n    big. Use the 'Limit rows to last:' and (or)\"\n                          \"\\n    'Decimation:' options to reduce the required\"\n                          \"\\n    memory size.\\n\", varName);\n            (void)fprintf(stderr, \"*** Details:\\n\"\n                          \"       varName         = %s\\n\"\n                          \"       nRows           = %d\\n\"\n                          \"       nCols           = %d\\n\"\n                          \"       elementSize     = %lu\\n\"\n                          \"       Bytes Required  = %.16g\\n\\n\",\n                          varName, nRows, nColumns, (unsigned long)\n                          elementSize, tmpDbl);\n            goto ERROR_EXIT;\n        }\n    }\n\n    /* Allocate memory for the log variable */\n    if ( (var = calloc(1, sizeof(LogVar))) == NULL ) {\n        (void)fprintf(stderr, \"*** Error allocating memory for logging %s\\n\",\n                      varName);\n        goto ERROR_EXIT;\n    }\n\n    /* Allocate memory for the circular buffer (real part) */\n    if ( (var->data.re = malloc(nRows*nColumns*elementSize)) == NULL ) {\n        (void)fprintf(stderr,\n                      \"*** Error allocating memory for the circular buffer\\n\");\n        (void)fprintf(stderr, \"*** Details:\\n\"\n                      \"       varName         = %s\\n\"\n                      \"       nRows           = %d\\n\"\n                      \"       nCols           = %d\\n\"\n                      \"       elementSize     = %lu\\n\"\n                      \"       Bytes Requested = %.16g\\n\\n\",\n                      varName, nRows, nColumns, (unsigned long) elementSize,\n                      ((double)elementSize)*((double)nRows)*((double)nColumns));\n        goto ERROR_EXIT;\n    }\n\n    /* Allocate memory for the circular buffer for the imaginary part */\n    if (complex) {\n        if ( (var->data.im = malloc(nRows*nColumns*elementSize)) == NULL ) {\n            (void)fprintf(stderr,\n                          \"*** Error allocating memory for the circular buffer \"\n                          \"for logging the imaginary part of %s\\n\", varName);\n            (void)fprintf(stderr, \"*** Details:\\n\"\n                          \"       varName         = %s\\n\"\n                          \"       nRows           = %d\\n\"\n                          \"       nCols           = %d\\n\"\n                          \"       elementSize     = %lu\\n\"\n                          \"       Bytes Requested = %.16g\\n\\n\",\n                          varName, nRows, nColumns, (unsigned long) elementSize,\n                          ((double)elementSize)*((double)nRows)*\n                                                 ((double)nColumns));\n            goto ERROR_EXIT;\n        }\n    }\n    /*\n     * Initialize the fields in LogVar structure.\n     */\n    if (appendToLogVarsList) {\n        rt_LoadModifiedLogVarName(li,varName,var->data.name);\n    } else {\n        var->data.name[mxMAXNAM-1] = '\\0';\n        (void)strncpy(var->data.name,varName,mxMAXNAM-1);\n    }\n    var->data.nCols           = nColumns;\n    var->data.nRows           = nRows;\n\n    var->data.nDims           = frameData ? 1 : nDims;\n    if (var->data.nDims > 2) {\n        var->data.dims = (int_T*)malloc(sizeof(int_T)*var->data.nDims);\n    } else {\n        var->data.dims = var->data._dims;\n    }\n    if (frameData) {\n        var->data.dims[0] = nColumns;\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        (void)memcpy(var->data.dims, dims, (size_t)(nDims*sizeof(int_T)));\n    }\n\n    var->data.dTypeID         = dTypeID;\n    var->data.elSize          = elementSize;\n\n    var->data.dataTypeConvertInfo = rt_GetDataTypeConvertInfo(\n        pDataTypeConvertInfo, dTypeID);\n\n    var->data.mxID            = rt_GetMxIdFromDTypeId(dTypeID);\n    /* over-ride logical bit if data type is boolean */\n    logical = dTypeID == SS_BOOLEAN ? 1 : 0;\n    var->data.logical         = (logical)   ? matLOGICAL_BIT : 0x0;\n    var->data.complex         = (complex)   ? matCOMPLEX_BIT : 0x0;\n    var->data.frameData       = frameData;\n    var->data.frameSize       = (frameData) ? frameSize : 1;\n\n    /* fill up valDims field */\n    if(logValDimsStat == NO_LOGVALDIMS){\n        /* All signals are fixed-size, no need to log valueDimensions field */\n        var->valDims     = NULL;\n        /* Set these pointers to NULLs in this case */\n        var->coords      = NULL;\n        var->strides     = NULL;\n        var->currStrides = NULL;\n    }\n    else{\n        if ( (var->valDims = calloc(1, sizeof(ValDimsData))) == NULL ) {\n            goto ERROR_EXIT;\n        }\n\n        (void)memcpy(var->valDims->name, &VALUEDIMENSIONS_FIELD_NAME, mxMAXNAM);\n\n        if (logValDimsStat == LOGVALDIMS_EMPTYMX) {\n            /* At least one signal is variable-size, \n               but the current signal is fixed-size. \n               Therefore, create a dummy MatrixData to write out valueDimensions \n               as an empty matrix. \n            */\n            var->valDims->nRows = 0;\n            var->valDims->nCols = 0;\n            var->valDims->currSigDims = NULL;\n            var->valDims->currSigDimsSize = NULL;\n            var->valDims->dimsData = NULL;\n            /* Set these pointers to NULLs in this case */\n            var->coords      = NULL;\n            var->strides     = NULL;\n            var->currStrides = NULL;\n        } else { /* The current signal is a variable-size signal. */\n            /* The \"valueDimensions\" must be double, so re-assign element size */\n            elementSize = sizeof(real_T);\n\n            /* When signals are frame-based, 'valueDimensions' has 1 column */\n            if(frameData){\n                /* When signal is frame-based, the first dimension is always fixed, \n                   so we only need to record the second dimension.\n                   e.g. Two frame-based signals [10x4] and [10x3], \n                   'valueDimensions' and 'currSigDims'\n                   only record 4 or 3.\n                */\n                nColumns = 1;\n                var->valDims->currSigDims = (void**) (currSigDims + 1);\n                var->valDims->currSigDimsSize = (int_T*) (currSigDimsSize + 1);\n            } else { /* non-frame based */\n                nColumns = nDims;\n                var->valDims->currSigDims = (void**) currSigDims;\n                var->valDims->currSigDimsSize = (int_T*) currSigDimsSize;\n            }\n            \n            /* Allocate memory for the circular buffer */\n            if ( (var->valDims->dimsData = malloc(nRows*nColumns*elementSize)) == NULL ) {\n                (void)fprintf(stderr,\n                              \"*** Error allocating memory for the circular buffer\\n\");\n                (void)fprintf(stderr, \"*** Details:\\n\"\n                              \"       varName         = %s\\n\"\n                              \"       nRows           = %d\\n\"\n                              \"       nCols           = %d\\n\"\n                              \"       elementSize     = %lu\\n\"\n                              \"       Bytes Requested = %.16g\\n\\n\",\n                              var->valDims->name, nRows, nColumns, (unsigned long) elementSize,\n                              ((double)elementSize)*((double)nRows)*((double)nColumns));\n                goto ERROR_EXIT;\n            }\n            var->valDims->nRows = nRows;\n            var->valDims->nCols = nColumns;\n\n            /* Allocate memory for these dynamic arrays */\n            {\n                size_t nbytes = var->data.nDims*sizeof(int_T);\n                if( ((var->coords = calloc(nbytes, 1)) == NULL)\n                    ||((var->strides = calloc(nbytes, 1)) == NULL)\n                    ||((var->currStrides = calloc(nbytes, 1)) == NULL) )\n                    goto ERROR_EXIT;\n            }\n        }\n    }\n\n    var->rowIdx               = 0;\n    var->wrapped              = 0;\n    var->nDataPoints          = 0;\n    var->usingDefaultBufSize  = usingDefaultBufSize;\n    var->okayToRealloc        = okayToRealloc;\n    var->decimation           = decimation;\n    var->numHits              = -1;  /* so first point gets logged */\n\n    /* Add this log var to list in log info, if necessary */\n    if (appendToLogVarsList) {\n        LogInfo *logInfo = (LogInfo*) rtliGetLogInfo(li);\n        LogVar  *varList = logInfo->logVarsList;\n\n        if (varList != NULL) {\n            while (varList->next != NULL) {\n                varList = varList->next;\n            }\n            varList->next = var;\n        } else {\n            logInfo->logVarsList = var;\n        }\n    }\n\n    return(var); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    \n    *errStatus = rtMemAllocError;\n    rt_DestroyLogVar(var);\n    return(NULL);\n\n} /* end rt_CreateLogVarWithConvert */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_CreateLogVar ===================================================\n * Abstract:\n *\tCreate a logging variable.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nLogVar *rt_CreateLogVar(RTWLogInfo        *li,\n                               const real_T      startTime,\n                               const real_T      finalTime,\n                               const real_T      inStepSize,\n                               const char_T      **errStatus,\n                               const char_T      *varName,\n                               BuiltInDTypeId    inpDataTypeID,\n                               int_T             logical,\n                               int_T             complex,\n                               int_T             frameData,\n                               int_T             nCols,\n                               int_T             nDims,\n                               const int_T       *dims,\n                               LogValDimsStat    logValDimsStat,\n                               void              **currSigDims,\n                               int_T             *currSigDimsSize,\n                               int_T             maxRows,\n                               int_T             decimation,\n                               real_T            sampleTime,\n                               int_T             appendToLogVarsList)\n{\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo = NULL;\n\n    return rt_CreateLogVarWithConvert(li,\n                                      startTime,\n                                      finalTime,\n                                      inStepSize,\n                                      errStatus,\n                                      varName,\n                                      inpDataTypeID,\n                                      pDataTypeConvertInfo,\n                                      logical,\n                                      complex,\n                                      frameData,\n                                      nCols,\n                                      nDims,\n                                      dims,\n                                      logValDimsStat,\n                                      currSigDims,\n                                      currSigDimsSize,\n                                      maxRows,\n                                      decimation,\n                                      sampleTime,\n                                      appendToLogVarsList);\n\n} /* end rt_CreateLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_CreateStructLogVar =============================================\n * Abstract:\n *\tCreate a logging variable in the structure format.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nStructLogVar *rt_CreateStructLogVar(RTWLogInfo              *li,\n                                           const real_T            startTime,\n                                           const real_T            finalTime,\n                                           const real_T            inStepSize,\n                                           const char_T            **errStatus,\n                                           const char_T            *varName,\n                                           boolean_T               logTime,\n                                           int_T                   maxRows,\n                                           int_T                   decimation,\n                                           real_T                  sampleTime,\n                                           const RTWLogSignalInfo  *sigInfo,\n                                           const char_T            *blockName)\n{\n\n    return( local_CreateStructLogVar(li,\n                                     startTime,\n                                     finalTime,\n                                     inStepSize,\n                                     errStatus,\n                                     varName,\n                                     logTime,\n                                     maxRows,\n                                     decimation,\n                                     sampleTime,\n                                     sigInfo,\n                                     blockName));\n\n} /* end rt_CreateStructLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_StartDataLoggingWithStartTime ==================================\n * Abstract:\n *      Initialize data logging info based upon the following settings cached\n *      in the RTWLogging data structure of the SimStruct.\n *\n * Return value is:\n *\t== NULL  => success\n *\t!= NULL  => failure (the return value is a pointer that points to the\n *                           error message, which is also set in the simstruct)\n */\nconst char_T *rt_StartDataLoggingWithStartTime(RTWLogInfo   *li,\n                                                      const real_T startTime,\n                                                      const real_T finalTime,\n                                                      const real_T stepSize,\n                                                      const char_T **errStatus)\n{\n    const char_T   *varName;\n    LogInfo        *logInfo;\n    real_T         sampleTime = stepSize;\n    int_T          maxRows    = rtliGetLogMaxRows(li);\n    int_T          decimation = rtliGetLogDecimation(li);\n    int_T          logFormat  = rtliGetLogFormat(li);\n    boolean_T      logTime    = (logFormat==2) ? 1 : 0;\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    if ((logInfo=calloc(1,sizeof(LogInfo))) == NULL) {\n        *errStatus = rtMemAllocError;\n        goto ERROR_EXIT;\n    }\n    rtliSetLogInfo(li, (void*)logInfo);\n\n    /* time */\n    varName = rtliGetLogT(li);\n    if (varName[0] != '\\0') {\n        int_T dims = 1;\n        logInfo->t = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                stepSize, errStatus,\n                                                varName,SS_DOUBLE,\n                                                NULL,\n                                                0,0,0,1,1,\n                                                &dims, NO_LOGVALDIMS, NULL, NULL,\n                                                maxRows,decimation,\n                                                sampleTime,1);\n        if (logInfo->t == NULL) goto ERROR_EXIT;\n    }\n\n    /* states */\n    if ( rtliGetLogX(li)[0] != '\\0' ||  rtliGetLogXFinal(li)[0] != '\\0' ) {\n        const RTWLogSignalInfo  *xInfo = rtliGetLogXSignalInfo(li);\n\n        if (logFormat == 0) {                                /* Matrix Format */\n            int            numCols;\n            int            nDims;\n            const int      *dims;\n            BuiltInDTypeId dataType;\n            int            isComplex;\n            int_T          sIdx;\n\n            const RTWLogDataTypeConvert *pDTConvInfo;\n\n            numCols = xInfo[0].numCols ? xInfo[0].numCols[0] : 0;\n            for (sIdx = 1; sIdx < xInfo[0].numSignals; sIdx++) {\n                numCols += xInfo[0].numCols[sIdx];\n            }\n            /* If we have only one \"matrix\" state, we can log as a matrix */\n            if (xInfo[0].numSignals == 1) {\n                nDims     = xInfo[0].numDims ? xInfo[0].numDims[0] : 1;\n                dims      = xInfo[0].dims;\n            } else {\n                nDims     = 1;\n                dims      = &numCols;\n            }\n            dataType  = xInfo[0].dataTypes ? xInfo[0].dataTypes[0] : 0;\n            isComplex = xInfo[0].complexSignals ? xInfo[0].complexSignals[0] : 0;\n\n            pDTConvInfo = xInfo[0].dataTypeConvert;\n\n            if (rtliGetLogX(li)[0] != '\\0') {\n                logInfo->x = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                        stepSize, errStatus,\n                                                        rtliGetLogX(li),dataType,\n                                                        pDTConvInfo,\n                                                        0,\n                                                        isComplex,0,numCols,nDims,dims,\n                                                        NO_LOGVALDIMS, NULL, NULL,\n                                                        maxRows,decimation,sampleTime,1);\n                if (logInfo->x == NULL)  goto ERROR_EXIT;\n            }\n            if (rtliGetLogXFinal(li)[0] != '\\0') {\n                logInfo->xFinal = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                             stepSize, errStatus,\n                                                             rtliGetLogXFinal(li),dataType,\n                                                             pDTConvInfo,\n                                                             0,isComplex,0,numCols,nDims,\n                                                             dims, NO_LOGVALDIMS, NULL, \n                                                             NULL, 1,decimation,\n                                                             sampleTime,1);\n                if (logInfo->xFinal == NULL)  goto ERROR_EXIT;\n            }\n        } else {                                          /* Structure Format */\n            if (rtliGetLogX(li)[0] != '\\0') {\n                logInfo->x = local_CreateStructLogVar(li, startTime, finalTime,\n                                                      stepSize, errStatus,\n                                                      rtliGetLogX(li), logTime,\n                                                      maxRows, decimation,\n                                                      sampleTime, xInfo, NULL);\n                if (logInfo->x == NULL) goto ERROR_EXIT;\n            }\n            if (rtliGetLogXFinal(li)[0] != '\\0') {\n                logInfo->xFinal = local_CreateStructLogVar(li, startTime, finalTime,\n                                                           stepSize, errStatus,\n                                                           rtliGetLogXFinal(li),\n                                                           logTime,1,decimation,\n                                                           sampleTime,xInfo,NULL);\n                if (logInfo->xFinal == NULL) goto ERROR_EXIT;\n            }\n        }\n    }\n\n    /* outputs */\n    *errStatus = rt_StartDataLoggingForOutput(li,startTime,finalTime,\n                                              stepSize,errStatus);\n    if (*errStatus != NULL)  goto ERROR_EXIT;\n\n    return(NULL); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Errors occurred when starting data logging.\\n\");\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    if (logInfo) {\n        rt_DestroyLogVar(logInfo->logVarsList);\n        logInfo->logVarsList = NULL;\n        rt_DestroyStructLogVar(logInfo->structLogVarsList);\n        logInfo->structLogVarsList = NULL;\n        FREE(logInfo);\n        rtliSetLogInfo(li,NULL);\n    }\n    return(*errStatus);\n\n} /* end rt_StartDataLoggingWithStartTime */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StartDataLogging ===============================================\n * Abstract:\n */\nconst char_T *rt_StartDataLogging(RTWLogInfo   *li,\n                                         const real_T finalTime,\n                                         const real_T stepSize,\n                                         const char_T **errStatus)\n{\n    return rt_StartDataLoggingWithStartTime(li,\n                                            0.0,\n                                            finalTime,\n                                            stepSize,\n                                            errStatus);\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_UpdateLogVar ===================================================\n * Abstract:\n *\tCalled to log data for a log variable.\n */\nvoid rt_UpdateLogVar(LogVar *var, const void *data, boolean_T isVarDims)\n{\n    size_t        elSize    = var->data.elSize;\n    const  char_T *cData    = data;\n    const  int_T  frameData = var->data.frameData;\n    const  int_T  frameSize = frameData ? (var->data.frameSize) : 1;\n    const  int_T  logWidth  = var->data.nCols;\n    BuiltInDTypeId dTypeID  = var->data.dTypeID;\n\n    size_t offset        = 0;\n    char_T *currRealRow  = NULL;\n    char_T *currImagRow  = NULL;\n    int_T  pointSize     = (int_T)((var->data.complex) ? rt_GetSizeofComplexType(dTypeID) : elSize);\n\n    int    i, j, k;\n\n    /* The following variables will be used for \n       logging variable-size signals */\n    const  int_T  nDims = var->data.nDims;\n    const  int_T  *dims = var->data.dims;\n    const  void   * const *currDimsPtr = NULL;\n    const  int_T  *currDimsSizePtr = NULL;\n\n    /* The following variables will be used for \n       logging \"valueDimensions\" field */\n    size_t offset_valDims   = 0;\n    char_T *currValDimsRow  = NULL;\n    size_t elSize_valDims   = sizeof(real_T);\n    real_T currentSigDims   = 0;\n    int_T  nRows_valDims    = 0;\n    int_T  logWidth_valDims = 0;\n\n    for (i = 0; i < frameSize; i++) {\n        if (++var->numHits % var->decimation) continue;\n        var->numHits = 0;\n\n        if (var->rowIdx == var->data.nRows) {\n            if (var->okayToRealloc == 1) {\n                rt_ReallocLogVar(var, isVarDims);\n            } else {\n                /* Circular buffer */\n                var->rowIdx = 0;\n                ++(var->wrapped); /* increment the wrap around counter */\n            }\n        }\n\n        if(isVarDims){\n            currDimsPtr = (const void * const *) var->valDims->currSigDims;\n            currDimsSizePtr = (const int_T*) var->valDims->currSigDimsSize;\n            logWidth_valDims = frameData ? 1 : var->valDims->nCols;\n            nRows_valDims = var->valDims->nRows;\n\n            var->strides[0] = 1;\n            var->currStrides[0] = 1;\n\n            for (k = 1; k < nDims; k++){\n                int32_T currDimsVal=0;\n                switch (currDimsSizePtr[k-1]) {\n                  case 1:\n                    currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                  case 2:\n                    currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                  case 4:\n                    currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                }\n                var->strides[k] = var->strides[k-1] * dims[k-1];\n                var->currStrides[k] = var->currStrides[k-1] * currDimsVal;\n            }\n        }\n\n        offset       = (size_t)(elSize * var->rowIdx * logWidth);\n        currRealRow  = ((char_T*) (var->data.re)) + offset;\n        currImagRow  = (var->data.complex) ?\n                       ((char_T*) (var->data.im)) + offset :  NULL;\n\n        /* update logging data */\n        for (j = 0; j < logWidth; j++) {\n\n            boolean_T inRange = true;\n            int idx = j;\n\n            /* Check whether the currently logged value is in range or not.\n               For fixed-size signal logging, always inRange = true; idx = j;\n               For variable-size signal logging, use strides, coordinates\n               and current strides to decide whether the currently logged\n               data is in range or not and its location in the logging \n               matrix.\n             */\n            if(isVarDims){\n                int rem = j;\n                idx = 0;\n                for(k = nDims-1; k>=0; k--){\n                    int32_T currDimsVal=0;\n                    switch (currDimsSizePtr[k]) {\n                      case 1:\n                        currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+k));\n                        break;\n                      case 2:\n                        currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+k));\n                        break;\n                      case 4:\n                        currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+k));\n                        break;\n                    }\n                    var->coords[k] = rem / var->strides[k];\n                    if( var->coords[k] >= currDimsVal ){\n                        inRange = false;\n                        break;\n                    }\n                    rem = rem - var->coords[k] * var->strides[k];\n                }\n                if(inRange){\n                    idx = var->coords[0];\n                    for (k = 1; k < nDims; k++){\n                        idx += var->coords[k] * var->currStrides[k];\n                    }\n                }\n            }\n            \n            if (!var->data.dataTypeConvertInfo.conversionNeeded) {\n                /* NO  conversion needed\n                 */ \n                if (inRange) {\n                    /* If in range, fill in data */\n                    const char *cDataPoint = cData + (i+frameSize*idx) * pointSize;\n\n                    (void) memcpy(currRealRow, cDataPoint, elSize);\n                    currRealRow += elSize;\n                    if (var->data.complex) {\n                        (void) memcpy(currImagRow, cDataPoint + pointSize/2, elSize);\n                        currImagRow += elSize;\n                    }\n                } else {\n                    /* If out of range, fill in NaN or 0:\n                       1) For bool, int32, uint32, int16, uint16, etc,\n                          memset to zeros;\n                       2) For fixed-point data type, NaN conversion is not\n                          allowed, memset to zeros.\n                    */\n                    if (dTypeID == SS_DOUBLE) {\n                       ((real_T*)(currRealRow))[0] = rtNaN;\n                    } else if (dTypeID == SS_SINGLE){\n                        ((real32_T*)(currRealRow))[0] = rtNaNF;\n                    } else {\n                        (void) memset(currRealRow, 0, elSize);\n                    }\n                    \n                    currRealRow += elSize;\n                    if (var->data.complex) {\n                        /* For imaginary part, fill in 0 */\n                        (void) memset(currImagRow, 0, elSize);\n                        currImagRow += elSize;\n                    }\n                }\n            }\n            else\n            {\n                /* YES conversion needed\n                 */ \n                DTypeId dataTypeIdOriginal = \n                    var->data.dataTypeConvertInfo.dataTypeIdOriginal;\n                int_T DpSize = (int_T)((var->data.complex) ? \n                                       rt_GetSizeofComplexType(dataTypeIdOriginal) : \n                                       rt_GetSizeofDataType(dataTypeIdOriginal));\n\n                DTypeId dataTypeIdLoggingTo = \n                    var->data.dataTypeConvertInfo.dataTypeIdLoggingTo;\n\n                int bitsPerChunk = var->data.dataTypeConvertInfo.bitsPerChunk;\n                int numOfChunk =  var->data.dataTypeConvertInfo.numOfChunk;\n                unsigned int isSigned = var->data.dataTypeConvertInfo.isSigned;\n\n                double fracSlope = var->data.dataTypeConvertInfo.fracSlope;\n                int    fixedExp  = var->data.dataTypeConvertInfo.fixedExp;\n                double bias      = var->data.dataTypeConvertInfo.bias;\n\n                double curRealValue = -0.12345678987654;\n                double curImagValue = -0.12345678987654;\n\n                int_T adjIndexIfComplex = (var->data.complex) ? 2 : 1;\n\n                if(inRange){\n                    if(numOfChunk > 1)\n                    {\n                        /* For multiword */\n                        const char *pInData = (const char *)(cData);\n                        int dtSize = bitsPerChunk*numOfChunk/8;\n                        pInData += ((i+frameSize*idx) * adjIndexIfComplex) * dtSize;\n                        \n                        curRealValue = rt_GetDblValueFromOverSizedData(pInData, bitsPerChunk, numOfChunk, \n                                                                       isSigned, fracSlope, fixedExp, bias);\n                        if (var->data.complex) {\n                            curImagValue = rt_GetDblValueFromOverSizedData((pInData+dtSize), bitsPerChunk, numOfChunk, \n                                                                           isSigned, fracSlope, fixedExp, bias);\n                        }\n                    }\n                    else\n                    {\n                        /* if in range, fill in data that is converted first */\n                        switch ( dataTypeIdOriginal )\n                        {\n                          case SS_DOUBLE:\n                            {\n                                const real_T *pInData = (const real_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const real_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_SINGLE:\n                            {\n                                const real32_T *pInData = (const real32_T *)(cData + (i+frameSize*idx)* DpSize);\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const real32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT8:\n                            {\n                                const int8_T *pInData = (const int8_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int8_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT8:\n                            {\n                                const uint8_T *pInData = (const uint8_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint8_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT16:\n                            {\n                                const int16_T *pInData = (const int16_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int16_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT16:\n                            {\n                                const uint16_T *pInData = (const uint16_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint16_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT32:\n                            {\n                                const int32_T *pInData = (const int32_T *)(cData + (i+frameSize*idx)* DpSize);\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT32:\n                            {\n                                const uint32_T *pInData = (const uint32_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_BOOLEAN:\n                            {\n                                const boolean_T *pInData = ((const boolean_T *)(cData));\n                                \n                                pInData += (i+frameSize*idx) * adjIndexIfComplex;\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          default: \n                            {\n                                /* For biglong */\n                                const char *pInData = (const char *)(cData);\n                                int dtSize = bitsPerChunk*numOfChunk/8;\n                                pInData += ((i+frameSize*idx) * adjIndexIfComplex) * dtSize;\n                                \n                                curRealValue = rt_GetDblValueFromOverSizedData(pInData, bitsPerChunk, numOfChunk, \n                                                                               isSigned, fracSlope, fixedExp, bias);\n                                if (var->data.complex) {\n                                    curImagValue = rt_GetDblValueFromOverSizedData((pInData+dtSize), bitsPerChunk, numOfChunk, \n                                                                                   isSigned, fracSlope, fixedExp, bias);\n                                }\n                            }\n                            break;\n                        } /* -- end of switch -- */\n                    }\n                } else {\n                    /* if out of range, just fill NaN or 0 */\n                    if(dTypeID == SS_DOUBLE || dTypeID == SS_SINGLE){\n                        /* vijay 4/11/2013: DO NOT CALL ldexp() with NaN below as it causes \n                         * lcc-win64 to generate inf instead of NaN as output. \n                         * Just use rtNaN directly */\n                        curRealValue = rtNaN;\n                    }\n                    else{\n                        curRealValue = ldexp( 0, fixedExp ) + bias;\n                    }\n                    if (var->data.complex) {\n                        /* fill 0 in imaginary part*/\n                        curImagValue = ldexp( 0, fixedExp ) + bias;\n                    }\n                }\n\n                switch ( dataTypeIdLoggingTo )\n                {\n                  case SS_DOUBLE:\n                    {\n                        *((real_T *)currRealRow) = (real_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((real_T *)currImagRow) = (real_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_SINGLE:\n                    {\n                        *((real32_T *)currRealRow) = (real32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((real32_T *)currImagRow) = (real32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT8:\n                    {\n                        *((int8_T *)currRealRow) = (int8_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int8_T *)currImagRow) = (int8_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT8:\n                    {\n                        *((uint8_T *)currRealRow) = (uint8_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint8_T *)currImagRow) = (uint8_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT16:\n                    {\n                        *((int16_T *)currRealRow) = (int16_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int16_T *)currImagRow) = (int16_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT16:\n                    {\n                        *((uint16_T *)currRealRow) = (uint16_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint16_T *)currImagRow) = (uint16_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT32:\n                    {\n                        *((int32_T *)currRealRow) = (int32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int32_T *)currImagRow) = (int32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT32:\n                    {\n                        *((uint32_T *)currRealRow) = (uint32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint32_T *)currImagRow) = (uint32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_BOOLEAN:\n                    {\n                        *((boolean_T *)currRealRow) = (boolean_T)(curRealValue != 0.0);\n\n                        if (var->data.complex) {\n\n                            *((boolean_T *)currImagRow) = (boolean_T)(curImagValue != 0.0);\n                        }\n                    }\n                    break;\n                } /* -- end of switch -- */\n\n                currRealRow += elSize;\n                if (var->data.complex) {\n                    currImagRow += elSize;\n                }\n            }\n        }\n\n        if(isVarDims){ /* update \"valueDimensions\" field */\n            for(j = 0; j < logWidth_valDims; j ++){\n                int32_T currDimsVal=0;\n                switch (currDimsSizePtr[j]) {\n                  case 1:\n                    currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+j));\n                    break;\n                  case 2:\n                    currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+j));\n                    break;\n                  case 4:\n                    currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+j));\n                    break;\n                }\n                offset_valDims  = (size_t)(elSize_valDims *( var->rowIdx + nRows_valDims * j));\n                currValDimsRow  = ((char_T*) (var->valDims->dimsData)) + offset_valDims;\n\n                /* convert int_T to real_T */\n                currentSigDims = (real_T) currDimsVal;\n                (void) memcpy(currValDimsRow, &currentSigDims, elSize_valDims);\n                currValDimsRow += elSize_valDims;\n            }\n        }\n        \n        ++var->rowIdx;\n    }\n\n    return;\n\n} /* end rt_UpdateLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n \n \n/* Function: rt_UpdateStructLogVar =============================================\n * Abstract:\n *      Called to log data for a structure log variable.\n */\nvoid rt_UpdateStructLogVar(StructLogVar *var, const real_T *t, const void *data)\n{\n    LogVar       *values = var->signals.values;\n    const char_T *signal = data;\n    boolean_T *isVarDims = var->signals.isVarDims;\n    int i = 0;\n\n    /* time */\n    if (var->logTime) {\n        rt_UpdateLogVar(var->time, t, false);\n    }\n\n    /* signals */\n    while (values) {\n        size_t elSz = values->data.elSize;\n\n        rt_UpdateLogVar(values, signal, isVarDims[i]);\n\n        if (values->data.complex) elSz *= 2;\n        signal += elSz * values->data.nCols;\n\n        values = values->next;\n        i++;\n    }\n\n} /* end rt_UpdateStructLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * g1614989:Refactoring this function to accept number of elements\n *          instead of accepting signalInfo and index.\n */\nvoid* rt_getTempMemory(LogVar* var, int_T numEls);\n\nvoid* rt_getTempMemory(LogVar* var, int_T numEls)\n{\n    size_t elSize  = var->data.elSize;\n    size_t cmplxMult = var->data.complex ? 2 : 1;\n    /*\n     * g1689750: With multiword support for mat file logging in row major array layout, we need to allocate more space to\n     * store the data when the transpose operation is being performed. The additional space is required to store multiple\n     * chunks that each multi word contains.\n     */\n    size_t numOfChunks = var->data.dataTypeConvertInfo.conversionNeeded ? var->data.dataTypeConvertInfo.numOfChunk : 1;\n    void* tempMemory = malloc(elSize * numEls * cmplxMult * numOfChunks);\n    return tempMemory;\n}\n\n/*\n* g1614989:This function processes the signal data if a function pointer is available and then logs the data.\n*          If a function pointer is not present, signal data is logged without any processing.\n*          The idx parameter specifies which information from the SignalInfo to be used for processing and logging.\n*          When idx is -1, the provided signal info is to be used for processing and logging the data.\n*/\nvoid rt_preProcessAndLogDataWithIndex(const RTWLogSignalInfo *signalInfo, int_T idx, LogVar* val, const void * data, boolean_T isVarDims);\n\nvoid rt_preProcessAndLogDataWithIndex(const RTWLogSignalInfo *signalInfo, int_T idx, LogVar* val, const void * data, boolean_T isVarDims)\n{\n    RTWPreprocessingFcnPtr preprocessingPtr = NULL;\n    int_T numEls = -1;\n    if (idx == -1) {\n        preprocessingPtr = *(signalInfo->preprocessingPtrs);\n        numEls = *(signalInfo->numCols);\n    }\n    else {\n        preprocessingPtr = signalInfo->preprocessingPtrs[idx];\n        numEls = signalInfo->numCols[idx];\n    }\n\n    if (preprocessingPtr != NULL) {\n        void* curData = rt_getTempMemory(val, numEls);\n        preprocessingPtr(curData, data);\n        rt_UpdateLogVar(val, curData, isVarDims);\n        free(curData);\n    }\n    else {\n        rt_UpdateLogVar(val, data, isVarDims);\n    }\n}\n\n/*\n* g1614989:This function is called when each signal has a specific RTWLogSignalInfo structure defined.\n*/\n\nvoid rt_preProcessAndLogData(RTWLogSignalInfo signalInfo, LogVar* val, const void * data, boolean_T isVarDims);\n\nvoid rt_preProcessAndLogData(RTWLogSignalInfo signalInfo, LogVar* val, const void * data, boolean_T isVarDims)\n{\n    rt_preProcessAndLogDataWithIndex(&signalInfo, -1, val, data, isVarDims);\n}\n \n/* Function: rt_UpdateTXYLogVars ===============================================\n * Abstract:\n *\tUpdate the xFinal,T,X,Y variables that are being logged.\n */\nconst char_T *rt_UpdateTXYLogVars(RTWLogInfo *li, time_T *tPtr)\n{\n    return rt_UpdateTXXFYLogVars(li, tPtr, true);\n}\n \n/* Function: rt_UpdateTXXFYLogVars =============================================\n * Abstract:\n *\tUpdate xFinal and/or the T,X,Y variables that are being logged\n */\nconst char_T *rt_UpdateTXXFYLogVars(RTWLogInfo *li, time_T *tPtr, boolean_T updateTXY)\n{\n    LogInfo *logInfo     = rtliGetLogInfo(li);\n    int_T   matrixFormat = (rtliGetLogFormat(li) == 0);\n    const RTWLogSignalInfo* yInfo = rtliGetLogYSignalInfo(li);\n    const RTWLogSignalInfo* xInfo = rtliGetLogXSignalInfo(li);\n\n    /* time */\n    if (logInfo->t != NULL && updateTXY) {\n        rt_UpdateLogVar(logInfo->t, tPtr, false);\n    }\n\n    if (matrixFormat) {                                      /* MATRIX_FORMAT */\n        /* states */\n        if (logInfo->x != NULL || logInfo->xFinal != NULL) {\n            int8_T**               segAddr     = _rtliGetLogXSignalPtrs(li);\n            const int_T            *segLengths = xInfo->numCols;\n            int_T                  nSegments   = xInfo->numSignals;\n            RTWPreprocessingFcnPtr* preprocessingPtrs = xInfo->preprocessingPtrs;\n\n            if (logInfo->x != NULL && updateTXY) {\n                const char_T *errorMessage = rt_UpdateLogVarWithDiscontiguousData(logInfo->x, segAddr,\n                                                                                  segLengths, nSegments, \n                                                                                  preprocessingPtrs);\n                if (errorMessage != NULL) return(errorMessage);\n            }\n            if (logInfo->xFinal != NULL) {\n                const char_T *errorMessage = rt_UpdateLogVarWithDiscontiguousData(logInfo->xFinal, segAddr,\n                                                                                  segLengths, nSegments, \n                                                                                  preprocessingPtrs);\n                if (errorMessage != NULL) return(errorMessage);\n            }\n        }\n        /* outputs */\n        if (logInfo->y != NULL && updateTXY) {\n            LogVar **var = (LogVar**) (logInfo->y);\n            int_T  ny    = logInfo->ny;\n            int_T  i;\n            int    yIdx;\n            LogSignalPtrsType data = rtliGetLogYSignalPtrs(li);\n\n            for (i = 0, yIdx = 0; i < ny; i++) {\n                if (data[i] != NULL) {\n                    /* \n                       When outputs are logged in Matrix format, \n                       no variable-size signal logging is allowed.\n                    */\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *          Function pointer is now identified by using \n                     *          Y Signal Info instead of iterating over pre-processing \n                     *          function pointers.\n                    */ \n                    rt_preProcessAndLogData(yInfo[yIdx], var[yIdx], data[i], false);\n                    yIdx++;\n                }\n            }\n        }\n    } else {                                              /* STRUCTURE_FORMAT */\n        /* states */\n        if (logInfo->x != NULL && updateTXY) {\n            int_T             i;\n            StructLogVar      *var = logInfo->x;\n            LogVar            *val = var->signals.values;\n            int_T             nsig = var->signals.numSignals;\n            LogSignalPtrsType data = rtliGetLogXSignalPtrs(li);\n\n            /* time */\n            if (var->logTime) {\n                rt_UpdateLogVar(var->time, tPtr, false);\n            }\n\n            /* signals */\n            for (i = 0; i < nsig; i++) {\n                /* g1614989:Code refactoring and fix for logging issue.\n                 *         Function pointer is now identified by using \n                 *         X Signal Info instead of iterating over pre-processing \n                 *         function pointers.\n                 */\n                rt_preProcessAndLogDataWithIndex(xInfo, i, val, data[i], false);\n                val = val->next;\n            }\n        }\n\n        /* outputs */\n        if (logInfo->y != NULL && updateTXY) {\n            int_T             ny      = logInfo->ny;\n            LogSignalPtrsType data    = rtliGetLogYSignalPtrs(li);\n            StructLogVar      **var   = (StructLogVar**) (logInfo->y);\n\n            if (ny == 1) {\n                int_T  i;\n                int_T  dataIdx;\n                LogVar *val = var[0]->signals.values;\n                int_T  nsig = var[0]->signals.numSignals;\n                boolean_T   *isVarDims = var[0]->signals.isVarDims;\n\n                /* time */\n                if (var[0]->logTime) {\n                    rt_UpdateLogVar(var[0]->time, tPtr, false);\n                }\n\n                /* signals */\n                for (i = 0, dataIdx = 0; i < nsig; i++) {                    \n                    while (data[dataIdx] == NULL) {\n                        ++dataIdx;\n                    }\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *         Function pointer is now identified by using \n                     *         Y Signal Info instead of iterating over pre-processing \n                     *         function pointers.\n                     */\n                    rt_preProcessAndLogDataWithIndex(yInfo, i, val, data[dataIdx], isVarDims[i]);\n                    dataIdx++;\n                    val = val->next;\n                }\n            } else {\n                int_T  i;\n                int_T  dataIdx;\n\n                for (i = 0, dataIdx = 0; i < ny && var[i] != NULL; i++) {\n                    LogVar *val = var[i]->signals.values;\n                    boolean_T   *isVarDims = var[i]->signals.isVarDims;\n\n                    /* time */\n                    if (var[i]->logTime) {\n                        rt_UpdateLogVar(var[i]->time, tPtr, false);\n                    }\n\n                    /* signals */\n                    while (data[dataIdx] == NULL) {\n                        ++dataIdx;\n                    }\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *         Function pointer is now identified by using \n                     *         Y Signal Info instead of iterating over pre-processing \n                     *         function pointers.\n                     */\n                    rt_preProcessAndLogData(yInfo[i], val, data[dataIdx], isVarDims[0]);\n                    dataIdx++;\n                    val = val->next;\n                }\n            }\n        }\n        /* final state */\n        if (logInfo->xFinal != NULL) {\n            StructLogVar *xf  = logInfo->xFinal;\n            LogVar       *val = xf->signals.values;\n            int_T        nsig = xf->signals.numSignals;\n            int_T        i;\n\n            /* time */\n            if (xf->logTime) {\n                rt_UpdateLogVar(xf->time, tPtr, false);\n            }\n\n            /* signals */\n            for (i = 0; i < nsig; i++) {\n                LogSignalPtrsType data = rtliGetLogXSignalPtrs(li);\n                /* g1614989:Code refactoring and fix for logging issue.\n                 *         Function pointer is now identified by using \n                 *         X Signal Info instead of iterating over pre-processing \n                 *         function pointers.\n                 */\n                rt_preProcessAndLogDataWithIndex(xInfo, i, val, data[i], false);\n                val = val->next;\n            }\n        }\n    }\n    return(NULL);\n} /* end rt_UpdateTXXFYLogVars */\n\n\n#ifdef __cplusplus\n}\n#endif\n          \n\n          \n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StopDataLoggingImpl =======================================\n * Abstract:\n *\tWrite logged data to model.mat and free memory.\n */\nvoid rt_StopDataLoggingImpl(const char_T *file, RTWLogInfo *li, boolean_T isRaccel)\n{\n    FILE          *fptr;\n    LogInfo       *logInfo     = (LogInfo*) rtliGetLogInfo(li);\n    LogVar        *var         = logInfo->logVarsList;\n    StructLogVar  *svar        = logInfo->structLogVarsList;\n    /* At this time, verbose is only needed if running rapid accelerator\n     * simulations. */\n    int           verbose      = isRaccel ? 0: 1;\n\n    boolean_T     emptyFile    = 1; /* assume */\n    boolean_T     errFlag      = 0;\n    const char_T  *msg;\n\n    /*******************************\n     * Create MAT file with header *\n     *******************************/\n    if ((fptr=fopen(file,\"w+b\")) == NULL) {\n        (void)fprintf(stderr,\"*** Error opening %s\",file);\n        goto EXIT_POINT;\n    }\n    if (rt_WriteMat5FileHeader(fptr)) {\n        (void)fprintf(stderr,\"*** Error writing to %s\",file);\n        goto EXIT_POINT;\n    }\n\n    /**************************************************\n     * First log all the variables in the LogVar list *\n     **************************************************/\n    while (var != NULL) {\n        if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n            (void)fprintf(stderr,\"*** Error writing %s due to: %s\\n\",file,msg);\n            errFlag = 1;\n            break;\n        }\n        if (var->nDataPoints > 0 || isRaccel) {\n            MatItem item;\n\n            item.type   = matMATRIX;\n            item.nbytes = 0; /* not yet known */\n            item.data   = &(var->data);\n            if (rt_WriteItemToMatFile(fptr, &item, MATRIX_ITEM)) {\n                (void)fprintf(stderr,\"*** Error writing log variable %s to \"\n                              \"file %s\",var->data.name, file);\n                errFlag = 1;\n                break;\n            }\n            emptyFile = 0;\n        }\n        var = var->next;\n    }\n    /* free up some memory by destroying the log var list here */\n    rt_DestroyLogVar(logInfo->logVarsList);\n    logInfo->logVarsList = NULL;\n\n    /*******************************************************\n     * Next log all the variables in the StructLogVar list *\n     *******************************************************/\n    while (svar != NULL) {\n        MatItem item;\n\n        if (svar->logTime) {\n            var = svar->time;\n            if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n                (void)fprintf(stderr, \"*** Error writing %s due to: %s\\n\",\n                              file, msg);\n                errFlag = 1;\n                break;\n            }\n        }\n\n        var = svar->signals.values;\n        while (var) {\n            if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n                (void)fprintf(stderr, \"*** Error writing %s due to: %s\\n\",\n                              file, msg);\n                errFlag = 1;\n                break;\n            }\n            var = var->next;\n        }\n\n        item.type   = matMATRIX;\n        item.nbytes = 0; /* not yet known */\n        item.data   = svar;\n\n        if (rt_WriteItemToMatFile(fptr, &item, STRUCT_LOG_VAR_ITEM)) {\n            (void)fprintf(stderr,\"*** Error writing structure log variable \"\n                          \"%s to file %s\",svar->name, file);\n            errFlag = 1;\n            break;\n        }\n        emptyFile = 0;\n\n        svar = svar->next;\n    }\n\n    /******************\n     * Close the file *\n     ******************/\n    (void)fclose(fptr);\n    if (emptyFile || errFlag) {\n        (void)remove(file);\n    } else {\n        if( verbose ) {\n            (void)printf(\"** created %s **\\n\\n\", file);\n        }\n    }\n\n EXIT_POINT:\n\n    /****************\n     * free logInfo *\n     ****************/\n    rt_DestroyLogVar(logInfo->logVarsList);\n    logInfo->logVarsList = NULL;\n    rt_DestroyStructLogVar(logInfo->structLogVarsList);\n    logInfo->structLogVarsList = NULL;\n    FREE(logInfo->y);\n    logInfo->y = NULL;\n    FREE(logInfo);\n    rtliSetLogInfo(li,NULL);\n\n} /* end rt_StopDataLoggingImpl */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StopDataLogging ================================================\n * Abstract:\n *\tWrite logged data to model.mat and free memory.\n */\nvoid rt_StopDataLogging(const char_T *file, RTWLogInfo *li)\n{\n    rt_StopDataLoggingImpl(file,li,false);\n\n} /* end rt_StopDataLogging */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#else /*!defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)*/\n\n#define rt_StartDataLogging(li, finalTime, stepSize, errStatus) NULL /* do nothing */\n#define rt_UpdateTXYLogVars(li, tPtr) NULL /* do nothing */\n#define rt_StopDataLogging(file, li) { (void(file)); } /* use file quiet unused macro warning */ /* do nothing */\n\n#endif /*!defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)*/\n\n\n\n/* [eof] rt_logging.c */\n\n/* LocalWords:  Tfinal MAXNAM nonfinite DType PWS RSim Fixup logvar DDEFAULT th\n * LocalWords:  curr Realloc realloc inp biglong vijay ldexp TXY eof XFinal th\n * LocalWords:  TXXFY NULL typedefs ret polyspace NUL\n */\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true,"showProtectedV2Report":true}};